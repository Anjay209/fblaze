<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CertQuest Dashboard</title>
  <link rel="stylesheet" href="mentor.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/feather-icons"></script>
  
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
</head>
<body>

  <!-- Top Nav -->
  <div class="top-header">
    <div class="nav-left">üåê</div>
    <div class="nav-title">Dashboard <span class="new-badge">(New!)</span></div>
    <div class="nav-right">
  <input type="text" id="navbarSearch" placeholder="Search CertQuest..." />
  <span class="search-icon" id="navbarSearchIcon">üîç</span>
  <div id="searchDropdown"></div>
</div>
  </div>

  <!-- Section Header -->
  <div class="section-header-background">
    <div class="section-header-inline">
      <h1 class="unit-title"><span class="name">Mentor Dashboard</span></h1>
    </div><div class="question-tabs">
        <div class="tab active" onclick="selectTab(this)">Dashboard</div>
        <div class="tab" onclick="selectTab(this)">Assignments</div> 
        <div class="tab" onclick="selectTab(this)">Meetings</div> 
      </div>
      <div class="tab-underline"></div>
  </div>
  <div class="main-layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="logo">CQ</div>
      <ul class="nav-icons">
        <li>üè† <span class="nav-label">Dashboard</span></li>
        <li>üìä <span class="nav-label">Stats</span></li>
        <li>üéØ <span class="nav-label">Goals</span></li>
        <li>üìÖ <span class="nav-label">Schedule</span></li>
        <li>‚öôÔ∏è <span class="nav-label">Settings</span></li>
      </ul>
    </aside>

  <main class="content">
    <h2><span class="title" style="color: #007cf0; margin-bottom: 20px; margin-left: -80px;">Your Mentees</span></h2><br>
    <div class="cards" id="menteesCards">
        
      </div>

<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; margin-left: -5vw; width: 72vw;">
  <h3 class="accuracy-title" style="margin:0; font-size:1.45rem; color:#177cf6; font-weight:700;">MCQ Accuracy Over Time</h3>
  <div style="display: flex; align-items: center; gap: 0.5rem;">
    <label for="compFilter" style="font-size:1.05rem; color:#1459b7; font-weight:500;">Competition:</label>
    <select id="compFilter" style="font-size:1.04rem; padding: 0.17rem 0.9rem; border-radius: 8px; border: 1px solid #b3cef6; background: #f8fbff;">
      <option value="all">All</option>
      <!-- options inserted by JS -->
    </select>
  </div>
</div>

<div class="chart-container">
  <canvas id="mcqChart"></canvas>
</div>
<br>
<h3 class="accuracy-title">Recent Activity</h3> 
<div class="chart-container" id="recentActivityContainer">
  <!-- JS will populate here -->
</div>


</div>
<div id="summaryModal" class="modal">
  <div class="modal-content" style="max-width:420px; padding: 2.1rem 2.2rem 2rem;">
    <span class="close" onclick="closeSummaryModal()" style="top:20px; right: 24px;">&times;</span>
    <h2 style="margin-bottom: 1.3rem; font-size: 1.5rem;">Summary for Anjay Parthsarathy</h2>

    <div style="margin-bottom: 2.2rem; display: flex; gap: 2.4rem; align-items: flex-end;">
  <div>
    <div class="num-answered" style="font-size: 2.2rem; font-weight: 700; color: #007cf0; letter-spacing:-1px;">38</div>
    <div style="font-size: 1.03rem; color: #888; margin-top:0.2rem;">Questions answered<br>this week</div>
  </div>
  <div>
    <div class="mcq-accuracy" style="font-size: 2.2rem; font-weight: 700; color: #0a50b8; letter-spacing:-1px;">81%</div>
    <div style="font-size: 1.03rem; color: #888; margin-top:0.2rem;">MCQ<br>Accuracy</div>
  </div>
</div>


   <div style="margin-bottom: 1.25rem;">
 <!-- Competency section: clean two-column alignment -->
<div class="competency-grid" style="display: grid; grid-template-columns: max-content 1fr; column-gap: 1.3rem; row-gap: 0.6rem; margin-bottom: 1.35rem;">
  <!-- This will be filled by JS -->
</div>


  </div>
</div>





  </main>
  <script src="https://cdn.jsdelivr.net/npm/meilisearch@latest/dist/bundles/meilisearch.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
window.addEventListener('load', async function () {
  const db = firebase.firestore();
  const auth = firebase.auth();

  // 1. Get mentor info and competitions
  const user = auth.currentUser || await new Promise(resolve => firebase.auth().onAuthStateChanged(resolve));
  if (!user) return;
  const userDoc = await db.collection('users').doc(user.uid).get();
  const userData = userDoc.data();
  let mentorComps = Array.isArray(userData.mentorCompetition)
    ? userData.mentorCompetition
    : [userData.mentorCompetition].filter(Boolean);

  // 2. Find all mentees matching any of the mentor's competitions
  const usersSnap = await db.collection('users').get();
  const mentees = [];
  usersSnap.forEach(doc => {
    if (doc.id === user.uid) return;
    const d = doc.data();
    let comps = Array.isArray(d.competitions) ? d.competitions : [d.competitions].filter(Boolean);
    if (comps.some(c => mentorComps.includes(c))) {
      mentees.push({
        id: doc.id,
        name: d.name || d.fullName || d.email || '(unnamed)',
        grade: d.grade || '',
        comps: comps.filter(Boolean)
      });
    }
  });

  // Populate mentee cards
  const menteesCards = document.getElementById('menteesCards');
  menteesCards.innerHTML = '';

  mentees.forEach(mentee => {
    const card = document.createElement('div');
    card.className = 'schoolhouse-card';
    const compsString = mentee.comps && mentee.comps.length ? mentee.comps.join(', ') : '';

    card.innerHTML = `
      <div class="card-icon"><img src="assets/forum.png" class="feature-box-icon"></div>
      <div class="card-content">
        <h3>${mentee.name}</h3>
        <p class="desc">
          ${mentee.grade ? mentee.grade + ' Grade' : ''}${(mentee.grade && compsString) ? ' ‚Ä¢ ' : ''}
          ${compsString}
        </p>
        <button class="view-summary-link" onclick="openSummaryModal('${mentee.id}', '${mentee.name}')">View Summary ‚Üí</button>
      </div>
    `;
    menteesCards.appendChild(card);
  });

    // ========== COMPETITION DROPDOWN POPULATE ==========

  const compFilter = document.getElementById('compFilter');
  if (compFilter) {
    // Remove old options except "All"
    compFilter.innerHTML = '<option value="all">All</option>';
    mentorComps.forEach(c => {
      if (!c) return;
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c;
      compFilter.appendChild(opt);
    });

    compFilter.addEventListener('change', function() {
      // (Placeholder for filtering logic)
      console.log('Selected competition:', this.value);
    });
  }

  // === Add this right after mentees are built ===
window.menteeIdNameMap = {};
mentees.forEach(m => window.menteeIdNameMap[m.id] = m.name);


  // 3. Store global data for modal AND prepare chart data
  window.globalMenteeData = {};
  let maxBuckets = 10;
  let allData = {};

  // Set up live listener for recent activity as soon as mentees are known
const menteeIds = mentees.map(m => m.id);
if (menteeIds.length > 0) {
  setupRecentActivityListener(menteeIds);
}


  for (let mentee of mentees) {
    let qs = await db.collection('assignments')
      .where('to', '==', mentee.id)
      .where('type', 'in', ['written','quiz'])
      .where('status', '==', 'complete')
      .orderBy('createdAt')
      .get();
    
    let accuracyArr = [];
    let rawAssignments = [];
    
    qs.forEach(doc => {
      let d = doc.data();
      
      // Store raw assignment data for modal
      rawAssignments.push({
        ...d,
        id: doc.id,
        createdAt: d.createdAt
      });
      
      // Process for chart - only include assignments with valid numeric scores
      if (typeof d.score === "number" && typeof d.maxScore === "number" && d.maxScore > 0) {
        accuracyArr.push(Math.round((d.score/d.maxScore)*100));
        console.log(`Chart data for ${mentee.name}: ${d.score}/${d.maxScore} = ${Math.round((d.score/d.maxScore)*100)}%`);
      } else {
        console.log(`Skipping assignment for chart (${mentee.name}):`, { score: d.score, maxScore: d.maxScore });
      }
    });
    
    // Store for modal use
    window.globalMenteeData[mentee.id] = {
      name: mentee.name,
      assignments: rawAssignments
    };
    
    // Prepare chart data
    while (accuracyArr.length < maxBuckets) accuracyArr.push(null);
    allData[mentee.name] = accuracyArr.slice(0, maxBuckets);
  }

  // 4. Draw the Chart.js chart
  const palette = [
    'rgba(44,98,255,1)',  'rgba(41,188,255,1)', 'rgba(151,196,255,1)',
    'rgba(94,235,189,1)', 'rgba(255,144,85,1)', 'rgba(236,86,173,1)'
  ];
  const fillPalette = [
    'rgba(44,98,255,0.08)', 'rgba(41,188,255,0.07)', 'rgba(151,196,255,0.07)',
    'rgba(94,235,189,0.07)', 'rgba(255,144,85,0.07)', 'rgba(236,86,173,0.07)'
  ];
  
  const menteeNames = Object.keys(allData);
  const datasets = menteeNames.map((name, i) => ({
    label: name,
    data: allData[name].map(v => v !== null ? v/100 : null),
    fill: 'origin',
    backgroundColor: fillPalette[i % fillPalette.length],
    borderColor: palette[i % palette.length],
    borderWidth: 3.5,
    tension: 0.48,
    pointRadius: 7,
    pointBorderWidth: 2.8,
    pointBackgroundColor: '#fff',
    pointBorderColor: palette[i % palette.length],
    showLine: true
  }));

  const questionBuckets = Array.from({length: maxBuckets}, (_, i) => (i+1)*10);

  const canvas = document.getElementById('mcqChart');
  if (window.mcqChartObj) window.mcqChartObj.destroy();
  window.mcqChartObj = new Chart(canvas, {
    type: 'line',
    data: { labels: questionBuckets, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: true,
          labels: {
            color: '#226',
            font: { size: 24, weight: 'bold', family: 'Inter, sans-serif' },
            padding: 20,
            usePointStyle: true,
            pointStyle: 'circle'
          }
        }
      },
      scales: {
        x: {
          title: {
            display: true,
            text: 'Your accuracy / every 10 questions',
            font: { size: 19, weight: 'bold' }
          },
          grid: { color: '#e7ecfa', lineWidth: 1.4 },
          ticks: { color: '#444', font: { size: 17, family: 'Inter, sans-serif' } }
        },
        y: {
          min: 0, max: 1, beginAtZero: true,
          title: {
            display: true,
            text: 'Accuracy (%)',
            font: { size: 19, weight: 'bold' }
          },
          ticks: {
            callback: v => Math.round(v*100) + '%',
            color: '#444', font: { size: 17, family: 'Inter, sans-serif' }
          },
          grid: { color: '#e7ecfa', lineWidth: 1.4 }
        }
      },
      elements: { line: { cubicInterpolationMode: 'monotone' } }
    }
  });
  updateMcqChart("all");


  console.log('Dashboard loaded successfully', {
    mentees: mentees.length,
    globalData: Object.keys(window.globalMenteeData).length
  });
});

function updateMcqChart(selectedComp = "all") {
  // mentees, allData, fillPalette, palette are in the parent scope
  let filteredMentees = mentees;
  if (selectedComp !== "all") {
    filteredMentees = mentees.filter(m => m.comps.includes(selectedComp));
  }
  let menteeNames = filteredMentees.map(m => m.name);

  const datasets = menteeNames.map((name, i) => ({
    label: name,
    data: allData[name].map(v => v !== null ? v/100 : null),
    fill: 'origin',
    backgroundColor: fillPalette[i % fillPalette.length],
    borderColor: palette[i % palette.length],
    borderWidth: 3.5,
    tension: 0.48,
    pointRadius: 7,
    pointBorderWidth: 2.8,
    pointBackgroundColor: '#fff',
    pointBorderColor: palette[i % palette.length],
    showLine: true
  }));

  window.mcqChartObj.data.datasets = datasets;
  window.mcqChartObj.update();
}


// ==================== COMPETITION DROPDOWN POPULATE AND HANDLER ====================

// Put this AFTER your Chart.js chart drawing code (after window.mcqChartObj)
window.addEventListener('load', function () {
  // Make sure mentorComps is defined from your user data
  const compFilter = document.getElementById('compFilter');
  if (!compFilter) return;

  // Remove old options except "All"
  compFilter.innerHTML = '<option value="all">All</option>';

  // Add options for each competition you mentor
  mentorComps.forEach(c => {
    if (!c) return;
    const opt = document.createElement('option');
    opt.value = c;
    opt.textContent = c;
    compFilter.appendChild(opt);
  });

  compFilter.addEventListener('change', function() {
  updateMcqChart(this.value);
});

});


// Fixed openSummaryModal function
// Replace your openSummaryModal function with this corrected version
async function openSummaryModal(menteeId, menteeName) {
  const modal = document.getElementById("summaryModal");
  modal.classList.add("show");
  modal.querySelector('h2').textContent = `Summary for ${menteeName}`;
  try {
    const menteeData = window.globalMenteeData && window.globalMenteeData[menteeId];
    if (!menteeData) {
      modal.querySelector('.num-answered').textContent = "0";
      modal.querySelector('.mcq-accuracy').textContent = "0%";
      const grid = modal.querySelector('.competency-grid');
      if (grid) grid.innerHTML = '';
      return;
    }
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    let questionsThisWeek = 0, totalCorrect = 0, totalQuestions = 0;
    let competencyStats = {};
    menteeData.assignments.forEach(assignment => {
      const score = assignment.score, maxScore = assignment.maxScore;
      const correctCompetencies = assignment.correctCompetencies || [];
      const allCompetencies = assignment.competencies || [];
      if (typeof score === 'number' && typeof maxScore === 'number' && maxScore > 0) {
        totalCorrect += score;
        totalQuestions += maxScore;
        let createdAt;
        if (assignment.createdAt && assignment.createdAt.toDate) {
          createdAt = assignment.createdAt.toDate();
        } else if (assignment.createdAt) {
          createdAt = new Date(assignment.createdAt);
        }
        if (createdAt && createdAt >= weekAgo) questionsThisWeek += maxScore;
      }
      correctCompetencies.forEach(c => {
        if (!competencyStats[c]) competencyStats[c] = { total: 0, correct: 0 };
        competencyStats[c].correct += 1;
      });
      allCompetencies.forEach(c => {
        if (!competencyStats[c]) competencyStats[c] = { total: 0, correct: 0 };
        competencyStats[c].total += 1;
      });
    });
    let bestComp = null, worstComp = null, bestAcc = -1, worstAcc = 101;
    Object.keys(competencyStats).forEach(c => {
      const stat = competencyStats[c];
      if (stat.total > 0) {
        const acc = Math.round((stat.correct / stat.total) * 100);
        if (acc > bestAcc) { bestAcc = acc; bestComp = c; }
        if (acc < worstAcc) { worstAcc = acc; worstComp = c; }
      }
    });
    bestComp = bestComp || 'n/a';
    worstComp = worstComp || 'n/a';
    bestAcc = bestAcc === -1 ? 0 : bestAcc;
    worstAcc = worstAcc === 101 ? 0 : worstAcc;
    const overallAccuracy = totalQuestions > 0 ? Math.round((totalCorrect / totalQuestions) * 100) : 0;
    modal.querySelector('.num-answered').textContent = questionsThisWeek;
    modal.querySelector('.mcq-accuracy').textContent = overallAccuracy + "%";
    const grid = modal.querySelector('.competency-grid');
    if (grid) {
      grid.innerHTML = `
        <div style="font-weight: 600; text-align: left;">Best Competency:</div>
        <div style="display: flex; align-items: center; gap: 0.6rem;">
          <span style="color: #059669; font-weight: 500;">${bestComp}</span>
          <span style="background: #e6f5ef; color: #059669; font-size: 0.98rem; border-radius: 8px; padding: 3px 13px; font-weight: 600;">${bestAcc}%</span>
        </div>
        <div style="font-weight: 600; text-align: left;">Weakest Competency:</div>
        <div style="display: flex; align-items: center; gap: 0.6rem;">
          <span style="color: #f59e42; font-weight: 500;">${worstComp}</span>
          <span style="background: #fff5e6; color: #d97706; font-size: 0.98rem; border-radius: 8px; padding: 3px 13px; font-weight: 600;">${worstAcc}%</span>
        </div>
      `;
    }
  } catch (error) {
    console.error('‚ùå Error in openSummaryModal:', error);
    modal.querySelector('.num-answered').textContent = "0";
    modal.querySelector('.mcq-accuracy').textContent = "0%";
    const grid = modal.querySelector('.competency-grid');
    if (grid) grid.innerHTML = '';
  }
}


</script>



 <script>
  const firebaseConfig = {
    apiKey: "AIzaSyDGYp9sBwOWBdu9W46Q6XFp9zfLCrEsaO4",
    authDomain: "certquest-94959.firebaseapp.com",
    projectId: "certquest-94959",
    storageBucket: "certquest-94959.appspot.com",
    messagingSenderId: "323956529033",
    appId: "1:323956529033:web:e9c9c6a3c7668b8a72f358",
    measurementId: "G-F5JHTGGN6K"
  };

  if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

  // Tab selection + underline animation
    function selectTab(selectedTab) {
      const tabText = selectedTab.textContent.trim();
  
      // Redirect if "Create" is clicked
      if (tabText === "Dashboard") {
        window.location.href = "mentor.html"; // replace with your correct path
        return;
      }

      if (tabText === "Assignments") {
        window.location.href = "assigned.html"; // replace with your correct path
        return;
      }

      if (tabText === "Meetings") {
        window.location.href = "meeting.html"; // replace with your correct path
        return;
      }
  
      // Handle in-page tab selection
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => tab.classList.remove('active'));
      selectedTab.classList.add('active');
  
      const underline = document.querySelector('.tab-underline');
      underline.style.transform = `translateX(${selectedTab.offsetLeft}px)`;
      underline.style.width = `${selectedTab.offsetWidth}px`;
    }
  
    // On page load: position underline
    window.addEventListener('load', () => {
      const activeTab = document.querySelector('.tab.active');
      const underline = document.querySelector('.tab-underline');
      if (activeTab && underline) {
        underline.style.transform = `translateX(${activeTab.offsetLeft}px)`;
        underline.style.width = `${activeTab.offsetWidth}px`;
      }
  
      feather.replace(); // renders all feather icons
    });

    
  
    // Accordion toggle logic
    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const icon = button.querySelector('.chevron-icon');
  
      const isActive = button.classList.contains('active');
  
      if (isActive) {
        button.classList.remove('active');
        content.style.maxHeight = null;
        if (icon) icon.classList.remove('rotate');
      } else {
        button.classList.add('active');
        content.style.maxHeight = content.scrollHeight + "px";
        if (icon) icon.classList.add('rotate');
      }
    }

    function renderRecentActivity(assignments, containerId = 'recentActivityContainer') {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.innerHTML = '';

  // Sort by date, descending
  assignments = assignments
    .filter(a => a.completedAt || a.createdAt) // Only ones with a date
    .sort((a, b) => {
      const adate = a.completedAt?.toDate?.() || a.createdAt?.toDate?.() || new Date(0);
      const bdate = b.completedAt?.toDate?.() || b.createdAt?.toDate?.() || new Date(0);
      return bdate - adate;
    })
    .slice(0, 10); // Limit to last 10 activities

  assignments.forEach(a => {
    const dateObj = a.completedAt?.toDate?.() || a.createdAt?.toDate?.() || new Date();
    const dateStr = dateObj.toLocaleDateString(undefined, {
      month: 'short', day: 'numeric', year: 'numeric'
    });
    // Dot color: green for perfect, yellow for completed, gray otherwise
    let dotColor = 'gray';
    if (a.status === 'complete' && a.score === a.maxScore) dotColor = 'green';
    else if (a.status === 'complete') dotColor = 'yellow';

    const name = window.menteeIdNameMap?.[a.to] || 'Student';

    const title = a.title || (a.type ? a.type.charAt(0).toUpperCase() + a.type.slice(1) + " Assignment" : "Assignment");
    const scoreStr = (typeof a.score === 'number' && typeof a.maxScore === 'number')
      ? `<b>${a.score}/${a.maxScore}</b>`
      : `<b>‚Äî</b>`;

    container.innerHTML += `
      <div class="result-row">
        <span class="dot ${dotColor}"></span>
        <span class="result-title">${name} ‚Ä¢ ${title}</span>
        <span class="result-date">${dateStr}</span>
        <span class="result-score">${scoreStr}</span>
      </div>
    `;
  });

  if (assignments.length === 0) {
    container.innerHTML = '<div style="color:#999; padding:1rem;">No recent activity.</div>';
  }
}



// Helper to fetch mentees by competition overlap (CertQuest logic)
async function getMenteesByCompetition(user) {
  const userDoc = await firebase.firestore().collection('users').doc(user.uid).get();
  const userData = userDoc.data();

  // Get mentor's competitions
  let mentorComps = [];
  if (Array.isArray(userData.mentorCompetition)) mentorComps = userData.mentorCompetition;
  else if (typeof userData.mentorCompetition === 'string' && userData.mentorCompetition.trim() !== '')
    mentorComps = [userData.mentorCompetition.trim()];

  if (mentorComps.length === 0) return [];

  // Pull all users, filter by competition overlap
  const usersSnapshot = await firebase.firestore().collection('users').get();
  let mentees = [];
  usersSnapshot.forEach(doc => {
    const other = doc.data();
    if (doc.id === user.uid) return; // skip self
    let otherComps = [];
    if (Array.isArray(other.competitions)) otherComps = other.competitions;
    else if (typeof other.competitions === 'string' && other.competitions.trim() !== '')
      otherComps = [other.competitions.trim()];
    const overlap = otherComps.some(comp => mentorComps.includes(comp));
    if (comps.some(c => mentorComps.includes(c))) {
  mentees.push({
    id: doc.id,
    name: d.name || d.fullName || d.email || '(unnamed)',
    grade: d.grade || '',
    comps: comps.filter(Boolean) // competitions as array
  });
}

  });
  return mentees;
}





  function closeSummaryModal() {
    document.getElementById("summaryModal").classList.remove("show");
  }

  // ============ MEILISEARCH INTEGRATION ============
    // Meilisearch client setup (adjust if you use a different host)
    const client = new MeiliSearch({ host: 'http://127.0.0.1:7700' });
    const index = client.index('content');
    const searchBox = document.getElementById('navbarSearch');
    const searchDropdown = document.getElementById('searchDropdown');
    const searchIcon = document.getElementById('navbarSearchIcon');

    if (searchBox && searchDropdown) {
      searchBox.addEventListener('input', async function(e) {
        const query = e.target.value.trim();
        if (!query) {
          searchDropdown.style.display = 'none';
          searchDropdown.innerHTML = '';
          return;
        }
        try {
          const result = await index.search(query, { limit: 5 });
          if (!result.hits.length) {
            searchDropdown.style.display = 'none';
            searchDropdown.innerHTML = '';
            return;
          }
          searchDropdown.style.display = 'block';
          searchDropdown.innerHTML = result.hits.map(doc => `
            <div class="dropdown-result" tabindex="0" data-url="${doc.url}">
              <b>${doc.title}</b><br>
              <span style="font-size:12px;color:#888;">${doc.category || ''}${doc.tags ? ' | ' + doc.tags.join(', ') : ''}</span>
            </div>
          `).join('');
        } catch (err) {
          searchDropdown.style.display = 'none';
          searchDropdown.innerHTML = '';
        }
      });

      // Handle result click
      searchDropdown.addEventListener('click', function(e) {
        const target = e.target.closest('.dropdown-result');
        if (target && target.dataset.url) {
          window.location = target.dataset.url;
        }
      });

      // Optional: Allow Enter key to open first result
      searchBox.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && searchDropdown.innerHTML) {
          const first = searchDropdown.querySelector('.dropdown-result');
          if (first && first.dataset.url) {
            window.location = first.dataset.url;
          }
        }
      });

      // Hide dropdown on outside click
      document.addEventListener('click', function(e) {
        if (!searchBox.contains(e.target) && !searchDropdown.contains(e.target)) {
          searchDropdown.style.display = 'none';
        }
      });

      // Click magnifier icon triggers search
      if (searchIcon) {
        searchIcon.addEventListener('click', () => {
          searchBox.dispatchEvent(new Event('input'));
        });
      }
    }
    // =========== END MEILISEARCH ============

    function setupRecentActivityListener(menteeIdsArray) {
  // Remove previous listener if set
  if (window.recentActivityUnsub) window.recentActivityUnsub();

  // Firestore 'in' queries max out at 10 elements, so batch if needed
  const db = firebase.firestore();
  const batchSize = 10;
  const allActivities = [];
  let batchesDone = 0;
  let batches = [];
  for (let i = 0; i < menteeIdsArray.length; i += batchSize) {
    batches.push(menteeIdsArray.slice(i, i + batchSize));
  }

  function renderAllActivities() {
    // Merge and sort all, show latest 10
    const merged = allActivities
      .sort((a, b) => {
        const adate = a.completedAt?.toDate?.() || a.createdAt?.toDate?.() || new Date(0);
        const bdate = b.completedAt?.toDate?.() || b.createdAt?.toDate?.() || new Date(0);
        return bdate - adate;
      })
      .slice(0, 10);
    renderRecentActivity(merged); // <-- Calls your existing function!
  }

  window.recentActivityUnsub = () => {}; // No-op, to chain unsubs

  batches.forEach((idBatch, idx) => {
    const unsub = db.collection('assignments')
      .where('to', 'in', idBatch)
      .where('status', '==', 'complete')
      .orderBy('completedAt', 'desc')
      .limit(10)
      .onSnapshot(snapshot => {
        // For this batch, replace its segment in the array
        allActivities.splice(
          idx * batchSize,
          batchSize,
          ...snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }))
        );
        batchesDone++;
        if (batchesDone === batches.length) {
          renderAllActivities();
        }
      });
    // Unsub logic
    window.recentActivityUnsub = (function(oldUnsub) {
      return function() {
        unsub();
        if (oldUnsub) oldUnsub();
      }
    })(window.recentActivityUnsub);
  });
}

</script>


  
</body>
</html>
