<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FBLAZE Dashboard</title>
  <link rel="stylesheet" href="calendar1.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
  <script src="https://unpkg.com/feather-icons"></script>
</head>
<body>
  <div class="min-h-screen text-white overflow-hidden">
    <!-- Galaxy Background -->
    <div class="galaxy-background">
      <div class="galaxy-gradient"></div>
      <div class="stars-container" id="starsContainer"></div>
      <div class="nebula nebula-1"></div>
      <div class="nebula nebula-2"></div>
      <div class="nebula nebula-3"></div>
    </div>

    <!-- Header -->
    <div class="blaze-header">
      <div class="blaze-header-content">
        <div class="header-left">
          <button class="hamburger-menu" id="hamburgerMenu" onclick="toggleMobileNav()" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <h1 class="blaze-logo">FBLAZE</h1>
        </div>
        <h1 class="blaze-logo desktop-logo">FBLAZE</h1>
        <nav class="blaze-nav" id="mainNav">
          <button class="mobile-nav-close" onclick="toggleMobileNav()" aria-label="Close menu">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
          <a href="../home3.html" class="nav-link">Home</a>
          <a href="javascript:void(0)" onclick="toggleNotificationPanel()" class="nav-link">
            Notifications
            <span id="notificationBadge" class="notification-badge" style="display: none;">0</span>
          </a>
          <a href="../practice.html" class="nav-link">Practice</a>
          <a href="../Forum/forum.html" class="nav-link">Forum</a>
          <a href="calendar1.html" class="nav-link">Calendar</a>
        </nav>
      </div>
    </div>

    <!-- Main Content -->
    <div class="calendar-container">
      <!-- Hero Section -->
      <div class="calendar-hero">
        <h1 class="calendar-hero-title">
          Your
          <br />
          <span class="calendar-hero-gradient">Calendar</span>
        </h1>
        <p class="calendar-hero-subtitle">See your scheduled events from your calendar events links.</p>
      </div>

      <!-- Info Banner -->
      <div class="info-banner">
        <div class="info-icon">i</div>
        <p class="info-text">Showing all events</p>
      </div>

      <!-- Tabs -->
      <div class="calendar-tabs">
        <button class="calendar-tab active" data-tab="all">All</button>
        <button class="calendar-tab" data-tab="pending">Pending</button>
        <button class="calendar-tab" data-tab="rescheduled">Rescheduled</button>
        <button class="calendar-tab" data-tab="upcoming">Upcoming</button>
        <button class="calendar-tab" data-tab="cancelled">Cancelled</button>
      </div>

      <!-- Events List -->
      <div class="events-list" id="eventsList">
        <!-- Events will be dynamically inserted here -->
      </div>

      <!-- CTA -->
      <div class="calendar-cta">
        <p class="cta-label">Stay on Top</p>
        <h2 class="cta-title">Never miss a meeting or study session.</h2>
        <p class="cta-desc">Schedule mentor meetings, study groups, and competitions. Keep your grind organized.</p>
        <button class="cta-button" id="ctaScheduleBtn">Schedule Now</button>
      </div>
    </div>
  </div> 

  <!-- Notification Panel -->
  <div id="notificationPanel" class="notification-panel hidden">
    <div class="notification-panel-header">
      <h3 class="notification-panel-title">NOTIFICATIONS</h3>
      <button onclick="toggleNotificationPanel()" class="close-notifications">‚úï</button>
    </div>
    <div id="notificationList" class="notification-list"></div>
  </div>

  <div class="modal-backdrop hidden"></div>
<div class="competency-modal hidden">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Schedule a Meeting</h2>
      <span class="close-modal">‚úï</span>
    </div>
    <form id="scheduleForm" action="https://formspree.io/f/yourFormID" method="POST">
      <input type="hidden" id="meetingId" name="meetingId" value="" />

      <label>Name:</label>
      <input type="text" name="name" required />
      <label>Email:</label>
      <input type="email" name="email" required />
      <label>Preferred Date & Time:</label>
      <input type="datetime-local" name="datetime" required />
      <label>Competition:</label>
<select id="meetingComp" name="meetingComp" required>
  <option value="">Select Competition...</option>
  <!-- dynamically populated options go here -->
</select>

      <label>Message:</label>
      <textarea name="message" placeholder="Add a short note..."></textarea>
      <button type="submit">Submit</button>
    </form>
    <div id="confirmation" class="hidden">
      <p>Your meeting has been requested successfully!</p>
    </div>
  </div>
</div>


<div class="rsvp-modal hidden">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Meeting Invitation</h2>
      <span class="rsvp-close">‚úï</span>
    </div>
    <div class="rsvp-message"></div>
    <div class="rsvp-actions">
      <button id="rsvpAccept" class="btn-accept">Accept</button>
      <button id="rsvpDecline" class="btn-decline">Decline</button>
      <button class="rsvp-close btn-neutral">Decide Later</button>
    </div>
  </div>
</div>

<!-- Add this right after the rsvp-modal div -->
<div class="choice-modal hidden">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Meeting Options</h2>
      <span class="close-choice-modal">‚úï</span>
    </div>
    <div class="choice-options">
      <button id="rsvpChoiceBtn" class="choice-btn">RSVP</button>
      <button id="editChoiceBtn" class="choice-btn">Edit Meeting</button>
    </div>
  </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/meilisearch@latest/dist/bundles/meilisearch.umd.min.js"></script>

 <script>

  // ========== GLOBAL STATE ==========
  let writtenQuestions = [];
  let currentQuestionIndex = 0;
  let writtenAnswers = {};
  let writtenTimer = null;
  let writtenTimeRemaining = 0;
  let progressInterval = null;
  let currentProgress = 0;
  
  // ========== LOADER FUNCTIONS ==========
  function showLoader() {
    const loader = document.getElementById("assignmentLoader");
    if (loader) {
      loader.style.display = "flex";
      startCircularProgress();
    }
  }
  
  function hideLoader() {
    completeCircularProgress();
    setTimeout(() => {
      stopCircularProgress();
      const loader = document.getElementById("assignmentLoader");
      if (loader) {
        loader.style.display = "none";
      }
    }, 300);
  }
  
  // ========== CIRCULAR PROGRESS FUNCTIONS ==========
  function updateCircularProgress(progress) {
    const fill = document.getElementById('circularProgressFill');
    const text = document.getElementById('circularProgressText');
    
    if (fill && text) {
      const circumference = 2 * Math.PI * 45;
      const offset = circumference - (progress / 100) * circumference;
      fill.style.strokeDashoffset = offset;
      text.textContent = Math.round(progress) + '%';
    }
  }
  
  function startCircularProgress() {
    currentProgress = 0;
    updateCircularProgress(0);
    
    progressInterval = setInterval(() => {
      currentProgress += 2;
      if (currentProgress > 95) {
        currentProgress = 95;
      }
      updateCircularProgress(currentProgress);
    }, 100);
  }
  
  function completeCircularProgress() {
    if (progressInterval) {
      clearInterval(progressInterval);
      progressInterval = null;
    }
    updateCircularProgress(100);
  }
  
  function stopCircularProgress() {
    if (progressInterval) {
      clearInterval(progressInterval);
      progressInterval = null;
    }
    currentProgress = 0;
  }
  
  // ========== QUESTION GENERATION ==========
  function getQuestionCount(timeStr) {
    if (!timeStr) return 5;
    const normalized = timeStr.toString().toLowerCase();
    if (normalized.includes("15")) return 10;
    if (normalized.includes("10")) return 7;
    if (normalized.includes("5")) return 5;
    return 5;
  }
  
  async function generatePersonalizedQuestionsWithGPT(formData) {
    const questionCount = getQuestionCount(formData.time);
    const competenciesText = formData.competencies.join(', ');
  
    let prompt = `Generate ${questionCount} FBLA-style multiple choice questions.
  - Difficulty: ${formData.difficulty}
  - Competencies to cover: ${competenciesText}
  - Each question must have exactly 4 options and 1 correct answer
  - Questions must be standalone, realistic for FBLA, and never reference "the document", "the text", "as stated", etc.
  - Use business, finance, marketing, management, economics, law, and related topics depending on the competencies.`
  
    prompt += `\n\nReturn ONLY valid JSON array in format:
  [
    {
      "text": "Question text?",
      "competency": "Marketing",
      "correctAnswer": "Correct option text",
      "options": ["A", "B", "C", "D"],
      "difficulty": "${formData.difficulty}",
      "source": "gpt_generated"
    }
  ]`;
  
    try {
      const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({
        messages: [
          { role: "system", content: `You are an expert FBLA written-competition exam designer.
  
  Your role is to generate ORIGINAL, competition-accurate FBLA-style multiple-choice questions that match the structure, rigor, tone, and professional standards of official FBLA written tests.
  
  You must follow ALL rules below.
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  CORE FBLA PHILOSOPHY
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  FBLA written tests assess professional correctness, precision, and applied business literacy.
  
  They do NOT assess creativity, opinion, or open-ended reasoning.
  
  Each question must test exactly ONE concept.
  
  Questions must be concise, objective, and professionally worded.
  
  Avoid unnecessary narrative unless the question type explicitly requires a scenario.
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  APPROVED FBLA QUESTION ARCHETYPES
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Every question MUST clearly belong to ONE of the following archetypes:
  
  1. Definition / Term Identification  
     - Identifying the correct term based on a definition  
     - Selecting the correct meaning of a professional word or concept  
  
  2. Classification / Category Recognition  
     - Determining where an item belongs within a professional category system  
     - Examples include document types, account categories, system types, business forms, or classifications  
  
  3. Procedural / Workflow Knowledge  
     - Understanding the stages of a professional workflow specific to the competition area  
     - Identifying where information originates within that workflow  
     - Determining which document, tool, or action is appropriate at a given stage  
     - Recognizing correct sequencing of professional tasks within the domain  
  
  4. Tool-to-Function Matching  
     - Matching software features, commands, utilities, or tools to their correct purpose  
     - Selecting the correct function used to accomplish a professional task  
  
  5. Quantitative / Calculation Application  
     - Performing single-step or limited multi-step calculations  
     - Selecting the correct numeric result based on provided data  
     - Avoid unnecessary complexity or advanced math  
  
  6. Language Precision & Usage  
     - Correct use of professional vocabulary  
     - Distinguishing homophones, word meanings, spelling, grammar, and standard usage  
  
  7. Error Detection / Exception Identification  
     - Identifying what is incorrect, misspelled, or does NOT belong  
     - Using negation ("NOT") carefully and intentionally  
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  QUESTION STRUCTURE RULES
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Each question must assess ONE idea only.  
  ‚Ä¢ Do not combine multiple concepts in one question.  
  ‚Ä¢ Avoid ambiguous wording.  
  ‚Ä¢ Use professional, neutral language.
  
  Acceptable stem styles include:
  - "Which of the following‚Ä¶"
  - "What term best describes‚Ä¶"
  - "The document used to‚Ä¶"
  - "Which action should be taken‚Ä¶"
  - "Which of the following is NOT‚Ä¶"
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ANSWER CHOICE DESIGN (CRITICAL)
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Each question MUST include exactly FOUR answer choices.
  
  Answer choices must:
  ‚Ä¢ Be the same grammatical form  
  ‚Ä¢ Be similar in length  
  ‚Ä¢ Belong to the same conceptual family  
  
  Wrong answer choices (distractors) must be plausible and realistic.
  
  Allowed distractor strategies include:
  ‚Ä¢ Closely related terms within the same category  
  ‚Ä¢ Common student misconceptions  
  ‚Ä¢ Incorrect step within a workflow  
  ‚Ä¢ Reversed or misapplied professional rules  
  ‚Ä¢ Visually or linguistically similar words  
  ‚Ä¢ Typical calculation or classification errors  
  
  Never include joke answers or obviously incorrect options.
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  DIFFICULTY CALIBRATION
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Easy:
  ‚Ä¢ Direct recall or recognition  
  ‚Ä¢ Minimal traps  
  
  Medium:
  ‚Ä¢ Requires discrimination between similar concepts  
  ‚Ä¢ Includes common misconceptions  
  
  Hard:
  ‚Ä¢ Includes negation ("NOT")  
  ‚Ä¢ Requires precise rule awareness  
  ‚Ä¢ Uses subtle wording differences  
  ‚Ä¢ Penalizes shallow memorization  
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  CONTENT INTEGRITY RULES
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ All questions must be ORIGINAL.  
  ‚Ä¢ Do NOT copy real FBLA questions.  
  ‚Ä¢ Do NOT closely paraphrase known questions.  
  ‚Ä¢ Use authentic structure only, not replicated wording.
  
  Questions must feel realistic for competitive FBLA written events at the regional, state, or national level.
  
  When study materials are provided, extract concepts, facts, names, dates, laws, and details from them. Present this information as established business knowledge. NEVER mention "the study guide", "the document", "the material", or use phrases like "according to", "as stated in", or "mentioned in".
  
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  OUTPUT REQUIREMENTS
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ Generate ONLY the requested number of questions.  
  ‚Ä¢ Each question must have exactly four answer options.  
  ‚Ä¢ Only ONE option may be correct.  
  ‚Ä¢ Output valid JSON only.  
  ‚Ä¢ Do not include explanations, commentary, or headings.  
  
  You are writing as a professional exam author ‚Äî not as a tutor or teacher.` },
          { role: "user", content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt }
        ]
      });
  
      const data = response.data;
      let content = data.content || data.choices?.[0]?.message?.content || data;
      
      if (typeof content !== 'string') {
        content = JSON.stringify(content);
      }
      
      content = content.trim();
      content = content.replace(/```json|```/g, "");
      const jsonStart = content.indexOf('[');
      const jsonEnd = content.lastIndexOf(']') + 1;
      
      if (jsonStart !== -1 && jsonEnd > jsonStart) {
        content = content.slice(jsonStart, jsonEnd);
      }
      
      const generated = JSON.parse(content);
      console.log(`‚úÖ Generated ${generated.length} GPT questions`);
      return generated;
  
    } catch (err) {
      console.error("‚ùå GPT error:", err);
      return getFallbackQuestions(questionCount, formData.competencies);
    }
  }
  
  function getFallbackQuestions(count, competencies) {
    const fallbackQuestions = [
      {
        text: "What is the primary purpose of parliamentary procedure?",
        competency: "Parliamentary Procedure",
        correctAnswer: "To make meetings more efficient",
        options: [
          "To make meetings more efficient",
          "To give the president more power",
          "To eliminate debate",
          "To make meetings longer"
        ]
      },
      {
        text: "Which motion is used to end a meeting?",
        competency: "Parliamentary Procedure",
        correctAnswer: "Adjourn",
        options: ["Adjourn", "Recess", "Postpone", "Table"]
      },
      {
        text: "What is the most effective way to communicate in business?",
        competency: "Business Communication",
        correctAnswer: "Clear and concise messaging",
        options: [
          "Clear and concise messaging",
          "Using complex terminology",
          "Lengthy detailed explanations",
          "Informal casual language"
        ]
      }
    ];
    
    const result = [];
    for (let i = 0; i < count; i++) {
      result.push(fallbackQuestions[i % fallbackQuestions.length]);
    }
    return result;
  }
  
  // ========== ASSIGNMENT FUNCTIONS ==========

  async function acceptAssignmentNow() {
  console.log("\nüöÄ ACCEPT ASSIGNMENT NOW\n");
  
  showLoader();

  const assignment = window.currentAssignment;
  
  if (!assignment) {
    console.error("‚ùå No assignment");
    hideLoader();
    return;
  }

  console.log("üìã Assignment type:", assignment.type);

  try {
    // Mark as seen
    if (window.latestAssignmentId) {
      const updateData = {
        status: "seen",
        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
        acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
      };

      if (assignment.type === 'written') {
        updateData.score = 0;
        updateData.maxScore = assignment.writtenQuestions?.length || 10;
      }

      try {
        await db.collection('assignments').doc(window.latestAssignmentId).update(updateData);
        console.log("‚úÖ Assignment marked as seen");
      } catch (error) {
        console.error("‚ùå Error marking as seen:", error);
      }
    }

    // Handle speaking/case
    if (assignment.type === 'speaking' || assignment.type === 'case') {
      console.log("üé§ Speaking/case assignment");
      document.getElementById('cq-assignment-modal').style.display = 'none';
      hideLoader();
      openCameraModal();
      return;
    }

    // Handle written
    if (assignment.type === 'written') {
      console.log("‚úçÔ∏è Written assignment");
      console.log("‚è≥ CIRCULAR PROGRESS LOADER VISIBLE");

      const competencies = assignment.competencies;
      const questionCount = assignment.totalQuestions || 10;
      const difficulty = assignment.difficulty || 'medium';

      if (!competencies || competencies.length === 0) {
        console.warn("‚ö†Ô∏è No competencies");
        hideLoader();
        return;
      }

      // FETCH COMPETITION ID FROM FIREBASE
      console.log("üìä Fetching competition ID from Firebase...");
      let competitionId = assignment.competitionId 
        || window.currentCompetition?.id 
        || window.competitionId 
        || window.currentUser?.competitions?.[0];

      if (!competitionId) {
        try {
          const userId = firebase.auth().currentUser?.uid;
          if (userId) {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists && userDoc.data().competitions?.[0]) {
              competitionId = userDoc.data().competitions[0];
              console.log("‚úÖ Fetched competition from Firebase:", competitionId);
            }
          }
        } catch (err) {
          console.warn("‚ö†Ô∏è Could not fetch competition from Firebase:", err);
        }
      }

      console.log("üéØ Competition ID:", competitionId);

      // FETCH BASELINE
      console.log("üìä Fetching baseline...");
      let baselineText = "";

      if (competitionId) {
        try {
          const competitionDoc = await db.collection('competitions').doc(competitionId).get();
          if (competitionDoc.exists) {
            const baseline = competitionDoc.data().baseline || {};
            if (baseline.text) {
              baselineText = baseline.text;
              console.log("‚úÖ Baseline fetched:", baselineText.length, "characters");
            }
          }
        } catch (err) {
          console.warn("‚ö†Ô∏è Baseline fetch failed");
        }
      } else {
        console.log("‚ö†Ô∏è No competition ID, skipping baseline");
      }

      // FETCH GPT CONTEXT
      console.log("ü§ñ Fetching GPT context...");
      let gptContextData = {};

      try {
        const userId = firebase.auth().currentUser?.uid;
        if (userId) {
          const userTrainingDoc = await db.collection('userTraining').doc(userId).get();
          if (userTrainingDoc.exists && userTrainingDoc.data().gptTrainingContext) {
            gptContextData = userTrainingDoc.data().gptTrainingContext;
            console.log("‚úÖ GPT context fetched");
          }
        }
      } catch (err) {
        console.warn("‚ö†Ô∏è GPT context fetch failed");
      }

      // BUILD CONTEXT STRING - Let GPT filter intelligently
      console.log("üß† Building context with full baseline + training data...");
      let contextString = "";
      
      if (baselineText) {
        contextString += "=== COMPETITION BASELINE STUDY MATERIAL ===\n";
        contextString += "Use the following baseline material to generate questions focused on: " + competencies.join(", ") + "\n";
        contextString += "Filter and extract the most relevant information for the specified competencies.\n\n";
        contextString += baselineText + "\n\n";
      }
      
      if (gptContextData.content) {
        contextString += "=== USER BACKGROUND AND TRAINING CONTEXT ===\n";
        contextString += "Consider the user's background when generating questions:\n";
        contextString += gptContextData.content;
      }
      
      window.__CERTQUEST_CONTEXT__ = contextString;
      console.log("‚úÖ Context ready:", contextString.length, "chars");
      console.log("üìö Competencies to focus on:", competencies);

      // GENERATE QUESTIONS
      console.log("üß† Generating questions WITH FULL BASELINE + TRAINING DATA...");
      console.log("‚è≥ LOADER PROGRESS BAR VISIBLE & ANIMATING");
      
      const questions = await generatePersonalizedQuestionsWithGPT({
        competencies,
        time: 15,
        difficulty,
        questionCount
      });

      console.log("‚úÖ Generated", questions.length, "questions");

      // UPDATE ASSIGNMENT
      const updatedAssignment = {
        ...assignment,
        generatedQuestions: questions,
        baselineText,
        gptContext: gptContextData
      };

      window.currentAssignment = updatedAssignment;
      window.writtenQuestions = questions;

      console.log("üì¶ Opening modal...");

      // OPEN MODAL
      document.getElementById('cq-assignment-modal').style.display = 'none';
      await openWrittenPracticeModal(updatedAssignment);
    }

  } catch (error) {
    console.error("‚ùå Error:", error);
    hideLoader();
  }
}


/**
 * Gathers baseline data for competencies from the competitions collection
 */
async function gatherBaselineData(competitionId, competencies) {
  try {
    if (!competitionId) {
      console.warn("‚ö†Ô∏è No competition ID provided");
      return {};
    }

    const competitionDoc = await db
      .collection('competitions')
      .doc(competitionId)
      .get();

    if (!competitionDoc.exists) {
      console.warn("‚ö†Ô∏è Competition not found:", competitionId);
      return {};
    }

    const competitionData = competitionDoc.data();
    console.log("üìÑ Full competition data structure:", competitionData);
    console.log("üìÑ Baseline field:", competitionData.baseline);

    const baseline = {};

    // Extract baseline for each competency from competition.baseline
    competencies.forEach(competencyId => {
      const competencyBaseline = competitionData.baseline?.[competencyId];

      if (competencyBaseline) {
        baseline[competencyId] = competencyBaseline;
        console.log(`‚úÖ Found baseline for ${competencyId}:`, competencyBaseline);
      } else {
        console.log(`‚ö†Ô∏è No baseline found for competency: ${competencyId}`);
      }
    });

    console.log("üìä Final baseline object:", baseline);
    return baseline;
  } catch (error) {
    console.error("‚ùå Error gathering baseline data:", error);
    return {};
  }
}

  async function openWrittenPracticeModal(assignment) {
    console.log("Opening written practice modal with assignment:", assignment);
  
    try {
      currentQuestionIndex = 0;
      writtenAnswers = {};
      if (!window.writtenAnswers) {
        window.writtenAnswers = {};
      }
  
      const timeInMinutes = parseInt(assignment.time) || 15;
      writtenTimeRemaining = timeInMinutes * 60;
  
      // Check if window.writtenQuestions exists (from "create your own" flow)
      if (window.writtenQuestions && window.writtenQuestions.length > 0) {
        console.log("‚úÖ Using window.writtenQuestions from create your own flow");
        writtenQuestions = window.writtenQuestions;
      } else if (assignment.writtenQuestions && assignment.writtenQuestions.length > 0) {
        // Use assignment's preloaded questions
        writtenQuestions = assignment.writtenQuestions;
        window.writtenQuestions = assignment.writtenQuestions;
      } else {
        // Generate new questions via GPT
        console.log("‚ö° No preloaded questions, generating via GPT...");
        assignment.writtenQuestions = await generatePersonalizedQuestionsWithGPT({
          time: assignment.time || "15 mins",
          difficulty: assignment.difficulty || "Medium",
          competencies: assignment.competencies || ["General"],
          type: "written"
        });
        writtenQuestions = assignment.writtenQuestions;
        window.writtenQuestions = assignment.writtenQuestions;
      }
  
      console.log("‚úÖ Written questions ready:", writtenQuestions);
  
      // Show modal and create stars
      const modal = document.getElementById('quizModal');
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      createQuizStars();
      loadWrittenQuestion();
      startWrittenTimer();
  
    } catch (err) {
      console.error("‚ùå Error in openWrittenPracticeModal:", err);
      alert("Could not load written practice. Please try again.");
    } finally {
      hideLoader();
      console.log("üõë Loader hidden inside openWrittenPracticeModal");
    }
  }
  
  function loadWrittenQuestion() {
    // Use window.writtenQuestions if available (for "create your own"), otherwise use local writtenQuestions
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    const question = questions[currentQuestionIndex];
    if (!question) {
      console.error("No question found at index", currentQuestionIndex);
      return;
    }
    
    console.log("Loading question", currentQuestionIndex + 1, ":", question.question || question.text);
    
    const assignmentTitle = window.currentAssignment?.title || 'Written Practice';
    const difficulty = window.currentAssignment?.difficulty || 'Easy';
    document.getElementById('quizTitle').textContent = `${difficulty} ${assignmentTitle}`;
    document.getElementById('quizProgress').textContent = 
      `Question ${currentQuestionIndex + 1} of ${questions.length}`;
    
    document.getElementById('questionCompetency').textContent = question.competency || 'General';
    const questionTextEl = document.getElementById('questionText');
    questionTextEl.textContent = question.question || question.text;
    questionTextEl.style.color = '#fff';
    
    const optionsContainer = document.getElementById('optionsContainer');
    const answers = window.writtenAnswers || writtenAnswers;
    const previousAnswer = answers[currentQuestionIndex];
    
    optionsContainer.innerHTML = question.options.map((option, index) => {
      const isSelected = previousAnswer === option;
      return `
        <button class="practice-quiz-option-btn ${isSelected ? 'selected' : ''}" data-option="${option}">
          <div class="practice-quiz-option-radio ${isSelected ? 'selected' : ''}">
            ${isSelected ? '<div class="practice-quiz-option-dot"></div>' : ''}
          </div>
          <span class="practice-quiz-option-text">${option}</span>
        </button>
      `;
    }).join('');
    
    const options = optionsContainer.querySelectorAll('.practice-quiz-option-btn');
    options.forEach(optionBtn => {
      optionBtn.addEventListener('click', function(e) {
        options.forEach(opt => {
          opt.classList.remove("selected");
          const radio = opt.querySelector('.practice-quiz-option-radio');
          radio.classList.remove("selected");
          radio.innerHTML = '';
        });
        
        this.classList.add('selected');
        const radio = this.querySelector('.practice-quiz-option-radio');
        radio.classList.add('selected');
        radio.innerHTML = '<div class="practice-quiz-option-dot"></div>';
        
        // Save to both window.writtenAnswers and local writtenAnswers
        if (window.writtenAnswers) {
          window.writtenAnswers[currentQuestionIndex] = this.dataset.option;
        } else {
          writtenAnswers[currentQuestionIndex] = this.dataset.option;
        }
        console.log("Answer saved:", currentQuestionIndex, "->", this.dataset.option);
      });
    });
    
    updateWrittenProgress();
    updateWrittenNavButtons();
  }
  
  function updateWrittenProgress() {
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
    document.getElementById('progressFill').style.width = `${progress}%`;
    document.getElementById('progressPercent').textContent = Math.round(progress);
  }
  
  function updateWrittenNavButtons() {
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    
    prevBtn.disabled = currentQuestionIndex === 0;
    
    if (currentQuestionIndex === questions.length - 1) {
      nextBtn.style.display = 'none';
      submitBtn.style.display = 'block';
    } else {
      nextBtn.style.display = 'block';
      submitBtn.style.display = 'none';
    }
  }
  
  function previousQuestion() {
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    if (currentQuestionIndex > 0) {
      currentQuestionIndex--;
      loadWrittenQuestion();
    }
  }
  
  function nextQuestion() {
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    if (currentQuestionIndex < questions.length - 1) {
      currentQuestionIndex++;
      loadWrittenQuestion();
    }
  }
  
  function startWrittenTimer() {
    clearInterval(writtenTimer);
    
    console.log("Starting timer with", writtenTimeRemaining, "seconds");
    updateTimerDisplay();
    
    writtenTimer = setInterval(() => {
      writtenTimeRemaining--;
      updateTimerDisplay();
      
      if (writtenTimeRemaining <= 0) {
        console.log("Time's up! Auto-submitting...");
        clearInterval(writtenTimer);
        submitQuiz();
      }
    }, 1000);
  }
  
  function updateTimerDisplay() {
    const minutes = Math.floor(writtenTimeRemaining / 60);
    const seconds = writtenTimeRemaining % 60;
    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    const timerElement = document.getElementById('quizTimer');
    if (timerElement) {
      timerElement.textContent = timeString;
      
      if (writtenTimeRemaining <= 60) {
        timerElement.style.color = '#ef4444';
      } else if (writtenTimeRemaining <= 300) {
        timerElement.style.color = '#f97316';
      } else {
        timerElement.style.color = '#fb923c';
      }
    }
  }
  
  function createQuizStars() {
    const starsContainer = document.getElementById('quizStarsContainer');
    if (!starsContainer) return;
    
    starsContainer.innerHTML = '';
    
    for (let i = 0; i < 200; i++) {
      const star = document.createElement('div');
      star.className = 'practice-quiz-star';
      
      const size = Math.random() * 3 + 0.5;
      const duration = Math.random() * 4 + 2;
      const delay = Math.random() * 2;
      const randomLeft = Math.random() * 100;
      const randomTop = Math.random() * 100;
      const randomOpacity = Math.random() * 0.9 + 0.3;
      
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = randomLeft + '%';
      star.style.top = randomTop + '%';
      star.style.opacity = randomOpacity;
      star.style.animation = `practice-quiz-twinkle ${duration}s ease-in-out infinite`;
      star.style.animationDelay = delay + 's';
      star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
      
      starsContainer.appendChild(star);
    }
  }
  
  function closeQuizModal() {
    const modal = document.getElementById('quizModal');
    if (modal) {
      modal.style.display = 'none';
    }
    document.body.style.overflow = 'auto';
    clearInterval(writtenTimer);
    writtenQuestions = [];
    currentQuestionIndex = 0;
    writtenAnswers = {};
    writtenTimeRemaining = 0;
    writtenTimer = null;
  }
  
  async function submitQuiz() {
    // Check if this is a written practice assignment
    const hasWrittenQuestions = (window.writtenQuestions && window.writtenQuestions.length > 0) || 
                                (writtenQuestions && writtenQuestions.length > 0);
    
    if (hasWrittenQuestions) {
      if (window.latestAssignmentId) {
        await submitWrittenPractice();
        return;
      } else {
        await submitWrittenPracticeForCreateYourOwn();
        return;
      }
    }
  }
  
  async function submitWrittenPractice() {
    try {
      console.log("=== SUBMITTING WRITTEN PRACTICE ===");
      clearInterval(writtenTimer);
      
      if (!window.latestAssignmentId) {
        console.error("‚ùå CRITICAL ERROR: No assignment ID found!");
        alert("Error: No assignment ID found. Cannot submit written practice.");
        closeQuizModal();
        return;
      }
      
      const questions = writtenQuestions;
      const answers = writtenAnswers;
      
      let score = 0;
      const competencyStats = {};
      const detailedAnswers = [];
      const totalQuestions = questions.length;
      
      questions.forEach((question, index) => {
        const userAnswer = answers[index];
        const correctAnswer = question.correctAnswer;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) score++;
        
        const competency = question.competency;
        if (!competencyStats[competency]) {
          competencyStats[competency] = { total: 0, correct: 0 };
        }
        competencyStats[competency].total++;
        if (isCorrect) competencyStats[competency].correct++;
        
        detailedAnswers.push({
          questionIndex: index,
          question: question.question || question.text,
          competency: competency,
          userAnswer: userAnswer || "No answer",
          correctAnswer: correctAnswer,
          isCorrect: isCorrect
        });
      });
      
      const originalTime = parseInt(window.currentAssignment?.time) * 60 || 900;
      const timeSpent = originalTime - writtenTimeRemaining;
      const percentage = Math.round((score / totalQuestions) * 100);
      
      const updateData = {
        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
        score: score,
        totalQuestions: totalQuestions,
        maxScore: totalQuestions,
        competencyStats: competencyStats,
        timeSpent: timeSpent,
        detailedAnswers: detailedAnswers,
        competencies: Object.keys(competencyStats),
        correctCompetencies: Object.entries(competencyStats)
          .filter(([_, stats]) => stats.correct === stats.total)
          .map(([comp, _]) => comp),
        percentage: percentage,
        submittedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      
      await db.collection('assignments').doc(window.latestAssignmentId).update(updateData);
      console.log("‚úÖ Assignment updated successfully");
      
      const resultsData = {
        message: `Excellent work! You scored ${score}/${totalQuestions}`,
        assignmentName: window.currentAssignment?.title || 'Written Practice',
        competencyStats: competencyStats,
        score: score,
        totalQuestions: totalQuestions,
        percentage: percentage,
        timeSpent: timeSpent
      };
      
      closeQuizModal();
      
      showCongratsModal(resultsData);
      
      window.latestAssignmentId = null;
      window.currentAssignment = null;
      
    } catch (error) {
      console.error("‚ùå Written practice submission error:", error);
      alert("Failed to submit practice: " + error.message);
    }
  }
  
  async function submitWrittenPracticeForCreateYourOwn() {
    try {
      console.log("=== SUBMITTING CREATE YOUR OWN WRITTEN PRACTICE ===");
      clearInterval(writtenTimer);
      
      const questions = window.writtenQuestions || writtenQuestions;
      const answers = window.writtenAnswers || writtenAnswers;
      
      if (!questions || questions.length === 0) {
        console.error("‚ùå CRITICAL ERROR: No questions found!");
        alert("Error: No questions found. Cannot submit written practice.");
        closeQuizModal();
        return;
      }
      
      let score = 0;
      const competencyStats = {};
      const detailedAnswers = [];
      const totalQuestions = questions.length;
      
      questions.forEach((question, index) => {
        const userAnswer = answers[index];
        const correctAnswer = question.correctAnswer;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) score++;
        
        const competency = question.competency;
        if (!competencyStats[competency]) {
          competencyStats[competency] = { total: 0, correct: 0 };
        }
        competencyStats[competency].total++;
        if (isCorrect) competencyStats[competency].correct++;
        
        detailedAnswers.push({
          questionIndex: index,
          question: question.question || question.text,
          competency: competency,
          userAnswer: userAnswer || "No answer",
          correctAnswer: correctAnswer,
          isCorrect: isCorrect
        });
      });
      
      const timeStr = document.getElementById('quizTitle')?.textContent?.match(/\d+/)?.[0] || '15';
      const originalTime = parseInt(timeStr) * 60 || 900;
      const timeSpent = originalTime - writtenTimeRemaining;
      const percentage = Math.round((score / totalQuestions) * 100);
      
      const resultsData = {
        message: `Excellent work! You scored ${score}/${totalQuestions}`,
        assignmentName: 'Written Practice',
        competencyStats: competencyStats,
        score: score,
        totalQuestions: totalQuestions,
        percentage: percentage,
        timeSpent: timeSpent
      };
      
      closeQuizModal();
      
      showCongratsModal(resultsData);
      
      window.writtenQuestions = null;
      window.writtenAnswers = null;
      
    } catch (error) {
      console.error("‚ùå Create your own written practice submission error:", error);
      alert("Failed to submit practice: " + error.message);
    }
  }
  
  function showCongratsModal(results) {
    const modal = document.getElementById('congratsModal');
    
    const percentage = results.percentage || Math.round((results.score / results.totalQuestions) * 100);
    
    document.getElementById('congratsTitle').textContent = 'Congratulations!';
    document.getElementById('congratsScore').textContent = `${results.score}/${results.totalQuestions}`;
    document.getElementById('congratsSubtitle').innerHTML = 
      `Excellent work! You scored <span id="congratsScoreSpan" style="background: linear-gradient(to right, #ef4444, #f97316, #eab308); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900; font-size: 1.75rem;">${results.score}/${results.totalQuestions}</span>`;
    
    document.getElementById('congratsAssignmentName').textContent = results.assignmentName || 'Written Practice';
    
    const competenciesContainer = document.getElementById('congratsCompetencies');
    if (results.competencyStats && Object.keys(results.competencyStats).length > 0) {
      competenciesContainer.innerHTML = Object.entries(results.competencyStats).map(([comp, stats]) => {
        const percentage = Math.round((stats.correct / stats.total) * 100);
        const isFull = stats.correct === stats.total;
        return `
          <div class="congrats-competency-item">
            <div class="congrats-competency-header">
              <span class="congrats-competency-name">${comp}</span>
              <span class="congrats-competency-score">${stats.correct}/${stats.total} correct</span>
            </div>
            <div class="congrats-competency-progress-bar">
              <div class="congrats-competency-progress-fill ${isFull ? 'full' : ''}" style="width: ${percentage}%"></div>
            </div>
          </div>
        `;
      }).join('');
    } else {
      competenciesContainer.innerHTML = '<p style="color: #94a3b8; text-align: center;">No competency breakdown available</p>';
    }
    
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    createCongratsStars();
  }
  
  function createCongratsStars() {
    const starsContainer = document.getElementById('congratsStarsContainer');
    if (!starsContainer) return;
    
    starsContainer.innerHTML = '';
    
    for (let i = 0; i < 200; i++) {
      const star = document.createElement('div');
      star.className = 'practice-quiz-star';
      
      const size = Math.random() * 3 + 0.5;
      const duration = Math.random() * 4 + 2;
      const delay = Math.random() * 2;
      const randomLeft = Math.random() * 100;
      const randomTop = Math.random() * 100;
      const randomOpacity = Math.random() * 0.9 + 0.3;
      
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = randomLeft + '%';
      star.style.top = randomTop + '%';
      star.style.opacity = randomOpacity;
      star.style.animation = `practice-quiz-twinkle ${duration}s ease-in-out infinite`;
      star.style.animationDelay = delay + 's';
      star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
      
      starsContainer.appendChild(star);
    }
  }
  
  function closeCongratsModal() {
    const modal = document.getElementById('congratsModal');
    if (modal) {
      modal.style.display = 'none';
    }
    document.body.style.overflow = 'auto';
  }
  
  function snoozeAssignment() {
    closeAssignmentModal();
  }
  
  // ========== MODAL FUNCTIONS ==========
  function openFullAssignmentModal(assignment) {
    // Set the modal title
    document.getElementById('cq-assignment-title').innerText = assignment.title || "New Assignment";
    
    // Show info section, hide quiz section
    document.getElementById('cq-assignment-info').style.display = 'block';
    document.getElementById('cq-assignment-quiz').style.display = 'none';
    
    // Fill in all assignment details
    const fieldsElement = document.getElementById('cq-assignment-fields');
    if (fieldsElement) {
        if (assignment.type === "speaking" || assignment.type === "case") {
            // Speaking/Case assignment format
            const q1 = assignment.questions && assignment.questions[0] ? assignment.questions[0] : "No question provided";
            const q2 = assignment.questions && assignment.questions[1] ? assignment.questions[1] : "No question provided";
            
            fieldsElement.innerHTML = `
                <div><b>Type:</b> ${assignment.type === "speaking" ? "Speaking" : "Case"} Assignment</div>
                <div><b>Competencies:</b> ${assignment.competencies ? assignment.competencies.join(', ') : 'n/a'}</div>
                <div><b>Description:</b> ${assignment.description || 'n/a'}</div>
                <div><b>Questions:</b></div>
                <ul>
                    <li>${q1}</li>
                    <li>${q2}</li>
                </ul>
            `;
        } else {
            // Regular assignment format
            fieldsElement.innerHTML = `
                <div><b>Time:</b> ${assignment.time || 'n/a'}</div>
                <div><b>Competencies:</b> ${assignment.competencies ? assignment.competencies.join(', ') : 'n/a'}</div>
                <div><b>Questions:</b><br> <span style="font-weight:400; color:#374151">${assignment.questions || 'n/a'}</span></div>
                <div><b>Difficulty:</b> ${assignment.difficulty || 'n/a'}</div>
                <div><b>Simulate:</b> ${assignment.simulate ? "Yes" : "No"}</div>
            `;
        }
  
        if (assignment.trainingPDFs && assignment.trainingPDFs.length > 0) {
            assignment.trainingPDFs.forEach(pdf => {
                const pdfBox = document.createElement('div');
                pdfBox.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; margin: 8px 0; border-radius: 8px; cursor: pointer; font-weight: 500;';
                pdfBox.textContent = pdf.name || 'Training Document';
                pdfBox.onclick = () => downloadPDF(pdf);
                fieldsElement.appendChild(pdfBox);
            });
        }
    }
    
    // Show the modal
    document.getElementById('cq-assignment-modal').style.display = 'block';
  }
  
  function closeAssignmentModal() {
    document.getElementById('cq-assignment-modal').style.display = 'none';
  }

  // Mobile Navigation Toggle
  window.toggleMobileNav = function() {
    const nav = document.getElementById('mainNav');
    const hamburger = document.getElementById('hamburgerMenu');
    
    if (nav && hamburger) {
      nav.classList.toggle('active');
      hamburger.classList.toggle('active');
      document.body.style.overflow = nav.classList.contains('active') ? 'hidden' : '';
    }
  };
  
  // Close mobile nav when clicking a nav link
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.blaze-nav .nav-link').forEach(link => {
      link.addEventListener('click', () => {
        if (window.innerWidth <= 768) {
          toggleMobileNav();
        }
      });
    });
  });

  // --- FIREBASE SETUP ---

  const db = firebase.firestore();
  const auth = firebase.auth();

  document.addEventListener("DOMContentLoaded", () => {
    // Create stars for background
    function createStars() {
      const starsContainer = document.getElementById("starsContainer");
      if (!starsContainer) return;
      
      for (let i = 0; i < 200; i++) {
        const star = document.createElement("div");
        star.className = "star";
        const size = Math.random() * 3 + 0.5;
        const duration = Math.random() * 4 + 2;
        const delay = Math.random() * 2;
        const randomLeft = Math.random() * 100;
        const randomTop = Math.random() * 100;
        const randomOpacity = Math.random() * 0.9 + 0.3;
        
        star.style.width = size + 'px';
        star.style.height = size + 'px';
        star.style.left = randomLeft + '%';
        star.style.top = randomTop + '%';
        star.style.opacity = randomOpacity;
        star.style.animation = `twinkle ${duration}s ease-in-out infinite`;
        star.style.animationDelay = delay + 's';
        star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
        
        starsContainer.appendChild(star);
      }
    }
    
    createStars();

    // --- Cache DOM elements ---
    const elements = {
      modal: document.querySelector(".competency-modal"),
      backdrop: document.querySelector(".modal-backdrop"),
      openBtn: document.getElementById("ctaScheduleBtn"),
      ctaBtn: document.getElementById("ctaScheduleBtn"),
      closeBtns: document.querySelectorAll(".close-modal"),
      form: document.getElementById("scheduleForm"),
      confirmation: document.getElementById("confirmation"),
      eventsList: document.getElementById("eventsList"),
      meetingComp: document.getElementById("meetingComp"),
      tabs: document.querySelectorAll(".calendar-tab"),
      infoText: document.querySelector(".info-text"),
      rsvpModal: document.querySelector(".rsvp-modal"),
      rsvpMessage: document.querySelector(".rsvp-message"),
      acceptBtn: document.getElementById("rsvpAccept"),
      declineBtn: document.getElementById("rsvpDecline"),
      laterBtn: document.querySelector(".rsvp-close"),
      choiceModal: document.querySelector(".choice-modal"),
      closeChoiceBtns: document.querySelectorAll(".close-choice-modal"),
      rsvpChoiceBtn: document.getElementById("rsvpChoiceBtn"),
      editChoiceBtn: document.getElementById("editChoiceBtn")
    };

    // Hide modals initially
    elements.modal?.classList.add("hidden");
    elements.backdrop?.classList.add("hidden");
    elements.confirmation?.classList.add("hidden");
    elements.rsvpModal?.classList.add("hidden");

    // --- Utility Functions ---
    const utils = {
      parseLocalDateTime: (str) => {
        if (!str) return new Date();
        const [date, time] = str.split("T");
        const [y, m, d] = date.split("-").map(Number);
        const [h, min] = time?.split(":").map(Number) || [0, 0];
        return new Date(y, m-1, d, h, min);
      },
      animateBanner: (newHtml) => {
        if (!elements.infoText) return;
        elements.infoText.classList.add("fade-out");
        setTimeout(() => {
          elements.infoText.innerHTML = newHtml;
          elements.infoText.classList.remove("fade-out");
        }, 300);
      },
      updateTabUnderline: (tab) => {
        if (!elements.underline || !tab) return;
        elements.underline.style.transform = `translateX(${tab.offsetLeft}px)`;
        elements.underline.style.width = `${tab.offsetWidth}px`;
      }
    };

    // --- Data Functions ---
    const dataHandler = {
      populateCompetitionOptions: async (current = "") => {
        if (!elements.meetingComp) return;
        
        elements.meetingComp.innerHTML = `<option value="">Select Competition‚Ä¶</option>`;
        const user = auth.currentUser || await new Promise(res => auth.onAuthStateChanged(res));
        if (!user) return;

        try {
          const snap = await db.collection("users").doc(user.uid).get();
          const data = snap.exists ? snap.data() : {};
          let comps = [];
          
          if (Array.isArray(data.competitions)) comps.push(...data.competitions);
          if (data.isMentor) {
            const mc = data.mentorCompetition;
            if (Array.isArray(mc)) comps.push(...mc);
            else if (mc) comps.push(mc);
          }
          if (current && !comps.includes(current)) comps.push(current);
          
          Array.from(new Set(comps)).forEach(c => {
            const opt = document.createElement("option");
            opt.value = c;
            opt.textContent = c;
            elements.meetingComp.appendChild(opt);
          });
        } catch (error) {
          console.error("Error loading competitions:", error);
        }
      },
      
      saveMeeting: async (meetingData, isEdit = false) => {
        try {
          const batch = db.batch();
          
          // Get all mentees in the competition
          const menteesQuery = db.collection("users")
            .where("competitions", "array-contains", meetingData.competition);
          
          // Get all mentors for the competition
          const mentorsQuery = db.collection("users")
            .where("mentorCompetition", "==", meetingData.competition);
          
          const [menteesSnapshot, mentorsSnapshot] = await Promise.all([
            menteesQuery.get(),
            mentorsQuery.get()
          ]);
          
          // Combine all unique user IDs
          const uids = new Set();
          menteesSnapshot.forEach(doc => uids.add(doc.id));
          mentorsSnapshot.forEach(doc => uids.add(doc.id));
          
          // Set the total users count (including creator)
          meetingData.rsvpStatus = meetingData.rsvpStatus || {};
          meetingData.rsvpStatus.totalUsers = uids.size;
          
          // Save meeting for all users
          uids.forEach(u => {
            const ref = db.collection("users").doc(u).collection("meetings").doc(meetingData.meetingId);
            batch.set(ref, meetingData, { merge: true });
          });

          await batch.commit();
          return true;
        } catch (error) {
          console.error("Error saving meeting:", error);
          return false;
        }
      }
    };

    // Modal backdrop functions


// Close modal when clicking backdrop
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('modal-backdrop')) {
    document.querySelectorAll('.competency-modal, .rsvp-modal, .choice-modal').forEach(modal => {
      hideModal(modal);
    });
  }
});

// Close modal when clicking close buttons
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('close-modal') || e.target.classList.contains('close')) {
    const modal = e.target.closest('.competency-modal, .rsvp-modal, .choice-modal');
    if (modal) hideModal(modal);
  }
});

    // --- Modal Functions ---
   // --- Modal Functions ---
const modalHandler = {
  currentModal: null,
  
  initModals: function() {
    elements.modal?.classList.add("hidden");
    elements.rsvpModal?.classList.add("hidden");
    elements.choiceModal?.classList.add("hidden");
    elements.backdrop?.classList.remove("active");
    elements.backdrop?.classList.add("hidden");
  },
  
  showModal: async function(meetingData = null) {
    this.closeAllModals();
    
    // Show backdrop first
    if (elements.backdrop) {
      elements.backdrop.classList.remove('hidden');
      elements.backdrop.classList.add('active');
    }
    
    // Show modal after backdrop
    if (elements.modal) {
      elements.modal.classList.remove('hidden');
    }
    document.body.classList.add("modal-open");
    document.body.style.overflow = 'hidden';
    
    // Reset or populate form
    if (elements.form) {
      elements.form.classList.remove("hidden");
      if (meetingData) {
        elements.form.name.value = meetingData.name || '';
        elements.form.email.value = meetingData.email || '';
        elements.form.datetime.value = meetingData.datetime || '';
        elements.form.message.value = meetingData.message || '';
        elements.form.meetingComp.value = meetingData.competition || '';
        elements.form.dataset.meetingId = meetingData.meetingId || '';
      } else {
        elements.form.reset();
        elements.form.dataset.meetingId = '';
      }
    }
    
    if (elements.confirmation) {
      elements.confirmation.classList.add("hidden");
    }
    
    await dataHandler.populateCompetitionOptions(meetingData?.competition);
    this.currentModal = 'edit';
  },

  showRsvpModal: function(meeting) {
    this.closeAllModals();
    
    try {
      const options = { 
        weekday: 'long', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit', 
        minute: '2-digit'
      };
      const meetingDate = new Date(meeting.datetime).toLocaleString('en-US', options);
      
      if (elements.rsvpMessage) {
        elements.rsvpMessage.innerHTML = `
          <div class="rsvp-header">
            <h3>Meeting Invitation</h3>
            <p>From: ${meeting.scheduledByName || "Mentor"}</p>
            <h4>${meeting.name}</h4>
          </div>
          <div class="rsvp-details">
            <p><strong>When:</strong> ${meetingDate}</p>
            <p><strong>Competition:</strong> ${meeting.competition || 'General'}</p>
            ${meeting.message ? `<p class="meeting-note">${meeting.message}</p>` : ''}
          </div>
        `;
      }
      
      if (elements.rsvpModal) {
        elements.rsvpModal.dataset.meetingId = meeting.meetingId;
        elements.rsvpModal.dataset.scheduledby = meeting.scheduledBy;
      }
      
      // Show backdrop with blur
      if (elements.backdrop) {
        elements.backdrop.classList.remove('hidden');
        elements.backdrop.classList.add('active');
      }
      
      // Show modal
      if (elements.rsvpModal) {
        elements.rsvpModal.classList.remove('hidden');
      }
      document.body.classList.add("modal-open");
      document.body.style.overflow = 'hidden';
      
      this.currentModal = 'rsvp';
    } catch (error) {
      console.error("Error showing RSVP modal:", error);
    }
  },

  showChoiceModal: function(meetingId) {
    this.closeAllModals();
    
    if (elements.choiceModal) {
      elements.choiceModal.dataset.meetingId = meetingId;
    }
    
    // Show backdrop with blur
    if (elements.backdrop) {
      elements.backdrop.classList.remove('hidden');
      elements.backdrop.classList.add('active');
    }
    
    // Show modal
    if (elements.choiceModal) {
      elements.choiceModal.classList.remove('hidden');
    }
    document.body.classList.add("modal-open");
    document.body.style.overflow = 'hidden';
    
    this.currentModal = 'choice';
  },

 closeAllModals: function() {
  // Hide all modals
  if (elements.modal) {
    elements.modal.classList.add("hidden");
  }
  if (elements.rsvpModal) {
    elements.rsvpModal.classList.add("hidden");
  }
  if (elements.choiceModal) {
    elements.choiceModal.classList.add("hidden");
  }
  
  // Hide backdrop
  if (elements.backdrop) {
    elements.backdrop.classList.remove("active");
    elements.backdrop.classList.add("hidden");
  }
  
  // Restore scroll
  document.body.classList.remove("modal-open");
  document.body.style.overflow = '';
  
  this.currentModal = null;
},

  closeModal: function() {
    if (elements.modal) {
      elements.modal.style.display = 'none';
      elements.modal.classList.add("hidden");
    }
    elements.backdrop?.classList.remove("active");
    elements.backdrop?.classList.add("hidden");
    document.body.classList.remove("modal-open");
    document.body.style.overflow = '';
    
    // Reset form state
    if (elements.form) {
      elements.form.reset();
      elements.form.classList.remove("hidden");
    }
    if (elements.confirmation) {
      elements.confirmation.classList.add("hidden");
    }
  },
  
  closeRsvpModal: function() {
    elements.rsvpModal?.classList.add("hidden");
    elements.backdrop?.classList.remove("active");
    elements.backdrop?.classList.add("hidden");
    document.body.classList.remove("modal-open");
    document.body.style.overflow = '';
  },
  
  closeChoiceModal: function() {
    elements.choiceModal?.classList.add("hidden");
    elements.backdrop?.classList.remove("active");
    elements.backdrop?.classList.add("hidden");
    document.body.classList.remove("modal-open");
    document.body.style.overflow = '';
  },

  checkBackdrop: function() {
    if ((elements.modal && !elements.modal.classList.contains("hidden")) || 
        (elements.rsvpModal && !elements.rsvpModal.classList.contains("hidden")) || 
        (elements.choiceModal && !elements.choiceModal.classList.contains("hidden"))) {
      return;
    }
    elements.backdrop?.classList.remove("active");
    elements.backdrop?.classList.add("hidden");
    document.body.classList.remove("modal-open");
    document.body.style.overflow = '';
  }
};

    // --- Event Listeners ---
    const setupEventListeners = () => {
      // Modal controls
      elements.closeBtns?.forEach(btn => btn.addEventListener("click", (e) => {
  e.preventDefault();
  modalHandler.closeAllModals();
}));

      // Backdrop click handler
     elements.backdrop?.addEventListener("click", (e) => {
  if (e.target === elements.backdrop) {
    modalHandler.closeAllModals();
  }
});

      elements.ctaBtn?.addEventListener("click", () => modalHandler.showModal());

      // Form submission
      elements.form?.addEventListener("submit", async e => {
        e.preventDefault();
        const user = auth.currentUser;
        if (!user) return alert("Please sign in first");

        const isEdit = !!elements.form.dataset.meetingId;
        const meetingId = elements.form.dataset.meetingId || db.collection("meetings").doc().id;
        const newDate = elements.form.datetime.value;
        
        let status = "pending";
        if (isEdit) {
          const orig = (await db.collection("users").doc(user.uid)
            .collection("meetings").doc(meetingId).get()).data() || {};
          status = (orig.datetime && orig.datetime !== newDate)
            ? "rescheduled" : (orig.status || "pending");
        }

        const meetingData = {
          meetingId,
          name: elements.form.name.value,
          email: elements.form.email.value,
          datetime: newDate,
          message: elements.form.message.value,
          competition: elements.form.meetingComp.value,
          scheduledBy: user.uid,
          status,
          rsvpStatus: {
            required: true,
            responses: { [user.uid]: "accepted" },
            totalUsers: 1
          },
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };

        try {
          const success = await dataHandler.saveMeeting(meetingData, isEdit);
          if (success) {
            // Show confirmation message
            elements.confirmation?.classList.remove("hidden");
            elements.form?.classList.add("hidden");
            
            // Close modal after 2 seconds
            setTimeout(() => {
  modalHandler.closeAllModals();
  // Reset form for next use
  elements.form?.reset();
  elements.form?.classList.remove("hidden");
  elements.confirmation?.classList.add("hidden");
}, 2000);
          }
        } catch (error) {
          console.error("Error saving meeting:", error);
          alert("Failed to save meeting. Please try again.");
        }
      });

      // Edit button handlers
      document.addEventListener("click", async (e) => {
        if (e.target.classList.contains("edit-meeting-btn")) {
          e.preventDefault();
          const eventCard = e.target.closest(".event-card-wrapper");
          const meetingId = eventCard?.dataset.id;
          if (!meetingId) return;

          const user = auth.currentUser;
          if (!user) return alert("Please sign in first");

          try {
            // Get the meeting document
            const doc = await db.collection("users").doc(user.uid)
              .collection("meetings").doc(meetingId).get();
            
            if (!doc.exists) return alert("Meeting not found!");
            
            const meetingData = doc.data();
            
            // Always show edit modal for everyone
            await modalHandler.showModal(meetingData);
            
          } catch (error) {
            console.error("Error loading meeting:", error);
            alert("Failed to load meeting details.");
          }
        }
      });

      // RSVP Choice
      elements.rsvpChoiceBtn?.addEventListener("click", async () => {
        const meetingId = elements.choiceModal?.dataset.meetingId;
        if (!meetingId) return;
        
        const user = auth.currentUser;
        if (!user) return;
        
        try {
          const doc = await db.collection("users").doc(user.uid)
            .collection("meetings").doc(meetingId).get();
          
          if (doc.exists) {
            modalHandler.closeAllModals();
            modalHandler.showRsvpModal(doc.data());
          }
        } catch (error) {
          console.error("Error loading meeting:", error);
          alert("Failed to load meeting details.");
        }
      });

      // Edit Choice
      elements.editChoiceBtn?.addEventListener("click", async () => {
        const meetingId = elements.choiceModal?.dataset.meetingId;
        if (!meetingId) return;
        
        const user = auth.currentUser;
        if (!user) return;
        
        try {
          const doc = await db.collection("users").doc(user.uid)
            .collection("meetings").doc(meetingId).get();
          
          if (doc.exists) {
            modalHandler.closeAllModals();
            await modalHandler.showModal(doc.data());
          }
        } catch (error) {
          console.error("Error loading meeting:", error);
          alert("Failed to load meeting details.");
        }
      });

      // Add close handler for choice modal
      elements.closeChoiceBtns?.forEach(btn => {
  btn.addEventListener("click", () => {
    modalHandler.closeAllModals();
  });
});

      // Tab switching
      elements.tabs?.forEach((tab, idx) => {
        tab.addEventListener("click", () => {
          elements.tabs.forEach(t => t.classList.remove("active"));
          tab.classList.add("active");

          const now = new Date();
          const nextWeek = new Date(now);
          nextWeek.setDate(now.getDate() + 7);

          document.querySelectorAll(".event-card-wrapper").forEach(ev => {
            const status = ev.querySelector(".status-badge")?.textContent.trim().toLowerCase() || "";
            const dt = utils.parseLocalDateTime(ev.dataset.datetime);
            
            let show = false;
            switch(idx) {
              case 0: show = true; break;
              case 1: show = status === "pending"; break;
              case 2: show = status === "rescheduled"; break;
              case 3: show = dt >= now && dt <= nextWeek; break;
              case 4: show = status === "cancelled"; break;
            }
            
            ev.style.display = show ? "" : "none";
          });

          const bannerMessages = [
            `Showing <b>all</b> events`,
            `Showing <b>pending</b> events`,
            `Showing <b>rescheduled</b> events`,
            `Showing events in the <b>next 7 days</b>`,
            `Showing <b>cancelled</b> events`
          ];
          utils.animateBanner(bannerMessages[idx] || bannerMessages[0]);
        });
      });

      // Search functionality
      if (window.MeiliSearch && elements.navbarSearch && elements.searchDD) {
        const client = new MeiliSearch({ host: "http://127.0.0.1:7700" });
        const index = client.index("content");

        elements.navbarSearch.addEventListener("input", async () => {
          const q = elements.navbarSearch.value.trim();
          if (!q) {
            elements.searchDD.style.display = "none";
            return;
          }

          try {
            const { hits } = await index.search(q, { limit: 5 });
            if (!hits.length) {
              elements.searchDD.style.display = "none";
              return;
            }

            elements.searchDD.innerHTML = hits.map(d => `
              <div class="dropdown-result" tabindex="0" data-url="${d.url}">
                <strong>${d.title}</strong><br>
                <small>${d.category || ""}${d.tags ? " | " + d.tags.join(",") : ""}</small>
              </div>
            `).join("");
            elements.searchDD.style.display = "block";
          } catch (error) {
            console.error("Search error:", error);
            elements.searchDD.style.display = "none";
          }
        });

        elements.searchDD.addEventListener("click", e => {
          const item = e.target.closest(".dropdown-result");
          if (item?.dataset.url) window.location.href = item.dataset.url;
        });

        document.addEventListener("click", e => {
          if (!elements.navbarSearch.contains(e.target) && !elements.searchDD.contains(e.target)) {
            elements.searchDD.style.display = "none";
          }
        });
      }

      // RSVP Accept Handler
      document.body.addEventListener("click", async (e) => {
  if (e.target && (e.target.id === "rsvpAccept" || 
      (e.target.classList.contains("rsvp-btn") && e.target.classList.contains("accept")))) {
    const user = auth.currentUser;
    if (!user) return alert("Please sign in!");

    // Get meeting ID from either modal or button
    let meetingId;
    let modal;
    if (e.target.id === "rsvpAccept") {
      modal = document.querySelector(".rsvp-modal");
      meetingId = modal?.dataset.meetingId;
    } else {
      meetingId = e.target.dataset.id;
    }

    if (!meetingId) return alert("Meeting ID not found!");

    try {
      // Get the meeting document from the current user's collection
      const userMeetingRef = db.collection("users").doc(user.uid)
        .collection("meetings").doc(meetingId);
      const userMeetingDoc = await userMeetingRef.get();

      if (!userMeetingDoc.exists) return alert("Meeting not found!");
      const meetingData = userMeetingDoc.data();

      // Get the creator's ID
      const creatorId = meetingData.scheduledBy;

      // Get all users in this competition (mentees and mentors)
      const menteesQuery = db.collection("users")
        .where("competitions", "array-contains", meetingData.competition);
      const mentorsQuery = db.collection("users")
        .where("mentorCompetition", "==", meetingData.competition);

      const [menteesSnap, mentorsSnap] = await Promise.all([
        menteesQuery.get(),
        mentorsQuery.get()
      ]);

      // Combine all user IDs
      const allUids = new Set();
      menteesSnap.forEach(doc => allUids.add(doc.id));
      mentorsSnap.forEach(doc => allUids.add(doc.id));
      allUids.add(creatorId); // Ensure creator is included

      // Create the updated responses object
      const updatedResponses = {
        ...(meetingData.rsvpStatus?.responses || {}),
        [user.uid]: "accepted"
      };

      // Calculate the new accepted count
      const acceptedCount = Object.values(updatedResponses).filter(v => v === "accepted").length;
      const totalUsers = allUids.size;

      // Prepare the update data
      const updateData = {
        "rsvpStatus.responses": updatedResponses,
        "rsvpStatus.totalUsers": totalUsers,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };

      // If this was a pending meeting, update the status
      if (meetingData.status === "pending") {
        updateData.status = "confirmed";
      }

      // Batch update all user's meeting documents
      const batch = db.batch();
      allUids.forEach(uid => {
        const ref = db.collection("users").doc(uid)
          .collection("meetings").doc(meetingId);
        batch.update(ref, updateData);
      });

      await batch.commit();
      
      // Close modal if it was open
      if (modal) {
        modal.classList.add("hidden");
        document.body.classList.remove("modal-open");
      }
      
      // Show success feedback
      alert("You've accepted this meeting!");
    } catch (error) {
      console.error("Error accepting meeting:", error);
      alert("Failed to accept meeting. Please try again.");
    }
  }
});

      // Decline button handler
      elements.declineBtn?.addEventListener("click", async () => {
        const meetingId = elements.rsvpModal?.dataset.meetingId;
        const user = auth.currentUser;
        if (!user || !meetingId) return;

        try {
          // First get the meeting data from creator's collection
          const creatorMeetingRef = db.collection("users").doc(user.uid)
            .collection("meetings").doc(meetingId);
          const meetingDoc = await creatorMeetingRef.get();
          
          if (!meetingDoc.exists) return;
          
          const meetingData = meetingDoc.data();
          const creatorId = meetingData.scheduledBy;
          
          // Get all users in this competition
          const allUsers = await db.collection("users")
            .where("competitions", "array-contains", meetingData.competition)
            .get();
          
          const batch = db.batch();
          
          // Update all instances
          allUsers.forEach(userDoc => {
            const ref = db.collection("users").doc(userDoc.id)
              .collection("meetings").doc(meetingId);
            batch.update(ref, {
              "rsvpStatus.responses": {
                ...meetingData.rsvpStatus.responses,
                [user.uid]: "declined"
              },
              status: "declined",
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
          });
          
        await batch.commit();
modalHandler.closeRsvpModal();  
location.reload();
        } catch (error) {
          console.error("Error declining meeting:", error);
          alert("Failed to decline meeting. Please try again.");
        }
      });

      elements.laterBtn?.addEventListener("click", modalHandler.closeRsvpModal);

      // Additional edit button handling
      document.addEventListener("click", async (e) => {
        if (e.target.classList.contains("edit-meeting-btn")) {
          const eventCard = e.target.closest(".event-card-wrapper");
          const meetingId = eventCard?.dataset.id;
          if (!meetingId) return;

          const user = auth.currentUser;
          if (!user) return alert("Please sign in first");

          try {
            const doc = await db.collection("users").doc(user.uid)
              .collection("meetings").doc(meetingId).get();
            
            if (doc.exists) {
              const meetingData = doc.data();
              if (meetingData.scheduledBy === user.uid) {
                // Creator can edit the meeting
                await modalHandler.showModal(meetingData);
              } else {
                // Non-creator can RSVP
                modalHandler.showRsvpModal(meetingData);
              }
            }
          } catch (error) {
            console.error("Error loading meeting:", error);
            alert("Failed to load meeting details.");
          }
        }
      });
    };

    // --- Render Functions ---
    const render = {
      meetingCard: (m) => {
        const d = new Date(m.datetime);
        const wd = d.toLocaleDateString("en-US", { weekday: "short" });
        const day = String(d.getDate()).padStart(2, "0");
        const tm = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        const isCreator = m.scheduledBy === auth.currentUser?.uid;
        const userResponse = m.rsvpStatus?.responses?.[auth.currentUser?.uid];
        const requiresResponse = m.rsvpStatus?.required && !userResponse && !isCreator;

        // Calculate RSVP counts
        const responses = m.rsvpStatus?.responses || {};
        const totalUsers = m.rsvpStatus?.totalUsers || Object.keys(responses).length || 1;
        const acceptedCount = Object.values(responses).filter(v => v === "accepted").length;

        // Determine status badge color
        const status = (m.status || 'pending').toLowerCase();
        let statusClass = 'status-pending';
        if (status === 'confirmed') statusClass = 'status-upcoming';
        else if (status === 'rescheduled') statusClass = 'status-rescheduled';
        else if (status === 'cancelled') statusClass = 'status-cancelled';

        // Determine card gradient based on status
        let cardGradient = 'event-card-red';
        if (status === 'rescheduled') cardGradient = 'event-card-green';
        else if (status === 'upcoming' || status === 'confirmed') cardGradient = 'event-card-orange';

        return `
          <div class="event-card-wrapper ${cardGradient}" data-id="${m.meetingId}" data-datetime="${m.datetime}">
            <div class="event-card-content">
              <div class="event-date-section">
                <p class="event-weekday">${wd}</p>
                <p class="event-day">${day}</p>
              </div>
              <div class="event-details">
                <p class="event-time-comp">${tm} ‚Ä¢ ${m.competition || 'General'}</p>
                <p class="event-name">${m.name}</p>
                <span class="status-badge ${statusClass}">${status}</span>
              </div>
              <div class="event-actions-section">
                <div class="event-rsvp-info">
                  <p class="event-scheduled-by">${isCreator ? 'You scheduled' : 'Scheduled'}</p>
                  <p class="event-accepted-count">${acceptedCount}/${totalUsers} accepted</p>
                </div>
                <button class="edit-meeting-btn" data-id="${m.meetingId}">Edit Meeting</button>
              </div>
            </div>
          </div>`;
      },

      eventsList: (meetings) => {
        if (!elements.eventsList) return;
        elements.eventsList.innerHTML = '';
        meetings.forEach(m => {
          elements.eventsList.insertAdjacentHTML("beforeend", render.meetingCard(m));
        });
      }
    };

    // --- Initialize ---
    const init = async () => {
      setupEventListeners();
      
      auth.onAuthStateChanged(user => {
        if (!user) return;
        
        // Setup notifications
        setupNotifications();
        
        // Load meetings
        db.collection("users").doc(user.uid)
          .collection("meetings")
          .orderBy("datetime")
          .onSnapshot(snap => {
            const meetings = snap.docs.map(doc => ({ ...doc.data(), meetingId: doc.id }));
            render.eventsList(meetings);
            
            // Check for pending RSVPs
            const pendingMeeting = meetings.find(m => 
              m.scheduledBy !== user.uid && 
              m.rsvpStatus?.required &&
              !m.rsvpStatus?.responses?.[user.uid]
            );
            
            if (pendingMeeting) {
              modalHandler.showRsvpModal(pendingMeeting);
            }
          }, error => {
            console.error("Meetings listener error:", error);
          });

        // Activate first tab
        if (elements.tabs && elements.tabs[0]) {
          elements.tabs[0].click();
        }
      });

      if (window.feather) feather.replace();
    };

    init();
  });

  // Notification Panel Toggle
  function toggleNotificationPanel() {
    const panel = document.getElementById("notificationPanel");
    if (!panel) return;
    
    if (panel.classList.contains("active")) {
      panel.classList.remove("active");
      setTimeout(() => panel.classList.add("hidden"), 300);
    } else {
      panel.classList.remove("hidden");
      setTimeout(() => panel.classList.add("active"), 10);
      loadNotifications();
    }
  }
  window.toggleNotificationPanel = toggleNotificationPanel;
  window.updateNotificationBadge = updateNotificationBadge;

  // Setup Notifications with Real-time Firebase Listener
  function setupNotifications() {
    const user = auth.currentUser;
    if (!user) return;
    
    const notificationList = document.getElementById("notificationList");
    if (!notificationList) return;
    
    // Real-time listener for notifications
    db.collection("notifications")
      .where("menteeId", "==", user.uid)
      .orderBy("timestamp", "desc")
      .limit(50)
      .onSnapshot((snapshot) => {
        notificationList.innerHTML = ''; // Clear existing
        
        if (snapshot.empty) {
          notificationList.innerHTML = '<div class="notification-empty">No notifications</div>';
          updateNotificationBadge(0);
          return;
        }
        
        snapshot.forEach((doc) => {
          const notif = doc.data();
          const item = document.createElement("div");
          item.className = `notification-item ${notif.read ? 'read' : 'unread'}`;
          
          // Format timestamp
          let timeText = "Just now";
          if (notif.timestamp && notif.timestamp.toDate) {
            const date = notif.timestamp.toDate();
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) timeText = "Just now";
            else if (diffMins < 60) timeText = `${diffMins}m ago`;
            else if (diffHours < 24) timeText = `${diffHours}h ago`;
            else timeText = `${diffDays}d ago`;
          }
          
          // Different content based on notification type
          let bodyContent = '';
          if (notif.type === 'assignment') {
            bodyContent = `
              <div class="notification-body">
                Type: ${notif.assignmentType || 'Quiz'}<br>
                ${notif.competencies ? `Competencies: ${Array.isArray(notif.competencies) ? notif.competencies.join(', ') : notif.competencies}<br>` : ''}
                ${notif.time ? `Time: ${notif.time}<br>` : ''}
                ${notif.difficulty ? `Difficulty: ${notif.difficulty}` : ''}
              </div>
            `;
          } else if (notif.type === 'mentor_comment') {
            bodyContent = `
              <div class="notification-body">
                ${notif.assignmentName ? `Assignment: ${notif.assignmentName}<br>` : ''}
                ${notif.comment ? `Comment: ${notif.comment}` : ''}
              </div>
            `;
          } else {
            bodyContent = `
              <div class="notification-body">
                ${notif.assignmentName ? `Assignment: ${notif.assignmentName}<br>` : ''}
                ${notif.score !== undefined ? `Score: ${notif.score}/${notif.totalQuestions || ''}` : ''}
              </div>
            `;
          }
          
          item.innerHTML = `
            <div class="notification-header">
              <strong class="notification-title">${notif.message || notif.title || 'Notification'}</strong>
              <span class="notification-time">${timeText}</span>
            </div>
            ${bodyContent}
          `;
          
          // Add click handler based on notification type
          if (notif.type === 'assignment' && notif.assignmentId) {
            item.style.cursor = 'pointer';
            item.addEventListener("click", () => {
              // Mark as read
              if (!notif.read) {
                doc.ref.update({ read: true });
              }
              item.classList.add("read");
              item.classList.remove("unread");
              
              // Fetch and show assignment details
              db.collection('assignments').doc(notif.assignmentId).get()
                .then(assignmentDoc => {
                  if (assignmentDoc.exists) {
                    window.currentAssignment = assignmentDoc.data();
                    window.latestAssignmentId = notif.assignmentId;
                    openFullAssignmentModal(assignmentDoc.data());
                  }
                })
                .catch(error => {
                  console.error("Error fetching assignment:", error);
                  alert("Could not load assignment details");
                });
            });
          } else {
            // Regular notification click handler
            item.style.cursor = 'pointer';
            item.addEventListener("click", () => {
              if (!notif.read) {
                doc.ref.update({ read: true });
              }
              item.classList.add("read");
              item.classList.remove("unread");
            });
          }
          
          notificationList.appendChild(item);
        });
        
        // Update notification badge count
        const unreadCount = snapshot.docs.filter(doc => !doc.data().read).length;
        updateNotificationBadge(unreadCount);
      }, (error) => {
        console.error("Error loading notifications:", error);
        notificationList.innerHTML = '<div class="notification-error">Error loading notifications</div>';
      });
  }

  // Update notification badge in nav
  function updateNotificationBadge(count) {
    const notificationLink = document.querySelector('a[onclick*="toggleNotificationPanel"]');
    if (notificationLink) {
      let notificationBadge = notificationLink.querySelector('.notification-badge');
      if (!notificationBadge && count > 0) {
        notificationBadge = document.createElement('span');
        notificationBadge.className = 'notification-badge';
        notificationBadge.textContent = count;
        notificationLink.style.position = 'relative';
        notificationLink.appendChild(notificationBadge);
      } else if (notificationBadge) {
        if (count > 0) {
          notificationBadge.style.display = 'inline-flex';
          notificationBadge.textContent = count;
        } else {
          notificationBadge.style.display = 'none';
        }
      }
    }
  }

  // Load Notifications (for initial load)
  function loadNotifications() {
    setupNotifications();
  }

  // ========== ASSIGNMENT MODAL FUNCTIONS ==========

  // Function to close assignment modal
 


 

  // Expose functions globally for onclick handlers
  window.acceptAssignmentNow = acceptAssignmentNow;
  window.closeAssignmentModal = closeAssignmentModal;
  window.openFullAssignmentModal = openFullAssignmentModal;
  window.snoozeAssignment = snoozeAssignment;
  window.closeQuizModal = closeQuizModal;
  window.previousQuestion = previousQuestion;
  window.nextQuestion = nextQuestion;
  window.submitQuiz = submitQuiz;
  window.closeCongratsModal = closeCongratsModal;

</script>

  <!-- Assignment Modal -->
  <div id="cq-assignment-modal" class="cq-modal" style="display: none;">
    <div class="cq-modal-content">
      <span class="cq-close" onclick="closeAssignmentModal()">&times;</span>
      <div id="cq-assignment-title" class="cq-modal-title">New Assignment</div>
      
      <!-- Assignment Info (shown first) -->
      <div id="cq-assignment-info">
        <div id="cq-assignment-fields" class="cq-modal-fields"></div>
        <div class="cq-modal-footer" style="margin-top:1.5rem; text-align:right;">
          <button class="cq-modal-btn" onclick="acceptAssignmentNow()">I'll do it now</button>
          <button class="cq-modal-btn" onclick="snoozeAssignment()">I'll do it later</button>
        </div>
      </div>
      
      <!-- Quiz Section (hidden initially) -->
      <div id="cq-assignment-quiz" style="display:none;">
        <div id="quizQuestions" class="cq-modal-fields"></div>
        <div class="cq-modal-footer">
          <button class="cq-modal-btn" id="submitQuizBtn" disabled>Submit Answers</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Quiz Modal - Fullscreen -->
  <div id="quizModal" style="display: none;" class="practice-quiz-fullscreen">
    <!-- Galaxy Background -->
    <div class="practice-quiz-galaxy-bg">
      <div class="practice-quiz-galaxy-gradient"></div>
      <div class="practice-quiz-stars-container" id="quizStarsContainer"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-1"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-2"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-3"></div>
    </div>

    <!-- Top Bar -->
    <div class="practice-quiz-topbar">
      <div class="practice-quiz-topbar-content">
        <div>
          <h1 id="quizTitle" class="practice-quiz-topbar-title">Easy Written Practice</h1>
          <p class="practice-quiz-topbar-subtitle">
            <span id="quizProgress">Question 1 of 14</span>
          </p>
        </div>
        
        <div class="practice-quiz-topbar-right">
          <div class="practice-quiz-timer-section">
            <p class="practice-quiz-timer-label">Time Remaining</p>
            <p id="quizTimer" class="practice-quiz-timer-value">14:53</p>
          </div>
          
          <button class="practice-quiz-close-btn" onclick="closeQuizModal()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="practice-quiz-main">
      <!-- Competency Badge -->
      <div class="practice-quiz-competency-badge">
        <span id="questionCompetency" class="practice-quiz-competency-text">Business Communication</span>
      </div>

      <!-- Question -->
      <div class="practice-quiz-question-section">
        <h2 id="questionText" class="practice-quiz-question">Loading question...</h2>
        <p class="practice-quiz-question-hint">Select the best answer from the options below</p>
      </div>

      <!-- Answer Options -->
      <div id="optionsContainer" class="practice-quiz-options">
        <!-- Options will be populated dynamically -->
      </div>

      <!-- Progress Section -->
      <div class="practice-quiz-progress-section">
        <div class="practice-quiz-progress-header">
          <p class="practice-quiz-progress-label">Overall Progress</p>
          <p class="practice-quiz-progress-value"><span id="progressPercent">0</span>/100</p>
        </div>
        <div class="practice-quiz-progress-bar">
          <div class="practice-quiz-progress-fill" id="progressFill"></div>
        </div>
      </div>

      <!-- Navigation Buttons -->
      <div class="practice-quiz-actions">
        <button id="prevBtn" class="practice-quiz-prev-btn" onclick="previousQuestion()" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
          Previous Question
        </button>
        <button id="nextBtn" class="practice-quiz-next-btn" onclick="nextQuestion()">Next Question</button>
        <button id="submitBtn" class="practice-quiz-submit-btn" onclick="submitQuiz()" style="display: none;">Submit Quiz</button>
      </div>
    </div>
  </div>

  <!-- Congratulations Modal - Fullscreen -->
  <div id="congratsModal" class="practice-quiz-fullscreen" style="display:none;">
    <!-- Galaxy Background -->
    <div class="practice-quiz-galaxy-bg">
      <div class="practice-quiz-galaxy-gradient"></div>
      <div class="practice-quiz-stars-container" id="congratsStarsContainer"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-1"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-2"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-3"></div>
    </div>

    <!-- Main Content - Centered -->
    <div class="practice-quiz-main" style="display: flex; align-items: center; justify-content: center; min-height: calc(100vh - 80px);">
      <div class="congrats-content">
        <!-- Congratulations Header - Centered -->
        <div class="congrats-header">
          <h1 id="congratsTitle" class="congrats-title">Congratulations!</h1>
          <p class="congrats-subtitle" id="congratsSubtitle">
            Excellent work! You scored <span id="congratsScore">0/0</span>
          </p>
        </div>

        <!-- Assignment Info - Centered -->
        <div class="congrats-assignment-info">
          <p class="congrats-assignment-label">For completing:</p>
          <h2 id="congratsAssignmentName" class="congrats-assignment-name">Written Practice</h2>
        </div>

        <!-- Competency Breakdown - Grid Layout -->
        <div class="congrats-competencies-grid" id="congratsCompetencies">
          <!-- Competencies will be populated here -->
        </div>

        <!-- Action Button -->
        <div class="congrats-actions">
          <button class="practice-quiz-next-btn" onclick="closeCongratsModal()">Got it!</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Assignment Loader - Fullscreen Blurred -->
  <div id="assignmentLoader" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); z-index: 10000; justify-content: center; align-items: center; flex-direction: column;">
    <div class="circular-progress-loader">
      <svg class="circular-progress-svg" viewBox="0 0 100 100">
        <defs>
          <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#f97316;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#eab308;stop-opacity:1" />
          </linearGradient>
        </defs>
        <circle class="circular-progress-bg" cx="50" cy="50" r="45"></circle>
        <circle class="circular-progress-fill" cx="50" cy="50" r="45" id="circularProgressFill"></circle>
      </svg>
      <div class="circular-progress-text" id="circularProgressText">0%</div>
    </div>
  </div>









</body>
</html>
