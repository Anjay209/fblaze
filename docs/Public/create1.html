<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FBLAZE Dashboard</title>
  <link rel="stylesheet" href="create1.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/feather-icons"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';</script>
<style>
      * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Inter', sans-serif;

  }

  html::-webkit-scrollbar, body::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Edge */
  }
  
  body {
    background-color: #f8f9fb;
    color: #111;
  }
  
  /* Layout */
  .main-layout {
    display: flex;
  }

 

#trainingModal .modal-content {
  width: 90% !important;
  max-width: 2000px !important;

}
  
  /* Sidebar */
  .sidebar {
    width: 70px;
    height: 100vh;
    background: white;
    border-right: 1px solid #ddd;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem 0;
    gap: 2rem;
    position: fixed;
    top: 60px;
    left: 0;
  }

  /* Notification styles moved to CSS file */

.notification-close {
    position: absolute;
    top: 8px;
    right: 8px;
    background: none;
    border: none;
    color: #999;
    cursor: pointer;
    font-size: 14px;
    padding: 2px 5px;
    border-radius: 50%;
}

.notification-close:hover {
    color: #666;
    background: #f0f0f0;
}

/* Notification styles moved to CSS file */


  
  .logo {
    font-weight: bold;
    color: #007aff;
    font-size: 1.2rem;
  }
  
  .button {
    background-color: transparent;
    border-color: 1px solid transparent;
  }
  .nav-icons {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }
  
  .nav-icons li {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.4rem;
    background-color: #f1f5ff;
    padding: 0.75rem;
    border-radius: 10px;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  
  .nav-icons li:hover {
    background-color: #d8e5ff;
  }

  .nav-label {
    position: absolute;
    left: 100%;
    top: 50%;
    transform: translateY(-50%);
    background-color: #111827;
    color: white;
    font-size: 0.7rem;
    padding: 0.3rem 0.5rem;
    border-radius: 6px;
    margin-left: 0.75rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease, transform 0.2s ease;
    z-index: 10;
  }

  .nav-icons li:hover .nav-label {
    opacity: 1;
    transform: translateY(-50%) translateX(0px);
  }
  
  /* Top Header */
  .top-header {
    position: sticky;
    top: 0;
    background: white;
    padding: 0.75rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #eee;
    z-index: 1000;
    height: 60px;
  }
  
  .nav-title {
    font-size: 1.2rem;
    font-weight: 600;
  }
  
  .new-badge {
    font-size: 0.9rem;
    color: #007aff;
    margin-left: 0.5rem;
  }
  
  .nav-right {
  position: relative;
  display: flex;
  align-items: center;
}

  
  .nav-right input {
    padding: 0.4rem 2.2rem 0.4rem 0.75rem;
    border: 1px solid #ccc;
    border-radius: 8px;
    font-size: 0.9rem;
    width: 220px;
  }
  
  .search-icon {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1rem;
    color: #666;
  }
  
  /* Content Area */
  .content {
    margin-left: 70px;
    padding: 2rem;
    width: 100%;
    width: calc(100% - 160px); /* Use available space */
    margin-left: 120px; /* Creates space from the sidebar */
  }
  
  /* Welcome Section */
  .welcome-section {
    margin-bottom: 1rem;
  }
  
  .course-title {
    background: linear-gradient(to right, #007cf0, #00dfd8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-size: 2rem;
    font-weight: 700;
    text-transform: lowercase;
  }
  
  .unit-title {
    font-size: 5rem;
    font-weight: 800;
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
  }
  
  .name {
    background: linear-gradient(to right, #007cf0, #00dfd8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  
  .meta-info {
    font-size: 0.9rem;
    color: #555;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  /* AI Summary Box */
  .ai-summary {
    background: #e6f7ff;
    padding: 1rem 2rem;
    border-radius: 8px;
    margin-bottom: 2rem;
    width: 80vw;
    border-left: 5px solid #00bfff; /* sky blue border */
  }
  
  .ai-summary h3 {
    font-weight: 700;
    margin-bottom: 0.5rem;
  }
  
  /* Cards */
  .cards {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    margin-bottom: 2rem;
  }
  
  .schoolhouse-card {
    background: #fff;
    border: 1px solid #e0e6ed;
    border-radius: 12px;
    padding: 1.5rem;
    width: 100%;
    max-width: 275px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .card-icon {
    font-size: 2rem;
    color: #3b82f6;
  }
  
  .card-content h3 {
    font-size: 1.1rem;
    font-weight: 700;
  }

  .card-content{
    gap: 0.75rem;
    display: flex;
  flex-direction: column;
  }
  
  .card-content p {
    font-size: 0.9rem;
    color: #4b5563;
  }
  
  .card-content a {
    font-size: 0.9rem;
    color: #2563eb;
    font-weight: 600;
    text-decoration: none;
  }
  
  .card-content a:hover {
    text-decoration: underline;
  }
  
  /* FAQ */
  .faq-wrapper {
    margin-top: 2rem;
  }
  
  .faq-category {
    font-size: 1.25rem;
    font-weight: 600;
    color: #007cf0;
    margin-bottom: 1rem;
  }

  .desc {
    line-height: 1.6rem;
  }
  
  .accordion {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .accordion-item {
    border-bottom: 1px solid #ddd;
  }
  
  .accordion-toggle {
    background: none;
    border: none;
    font-size: 1rem;
    font-weight: 600;
    text-align: left;
    width: 100%;
    padding: 1rem 0;
    cursor: pointer;
  
    display: flex;
    justify-content: space-between; /* ðŸ‘ˆ pushes icon to far right */
    align-items: center;
    gap: 0.75rem;
  }
  
  .accordion-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
    font-size: 0.9rem;
    color: #555;
  }
  
  .accordion-toggle.active + .accordion-content {
    max-height: 200px;
    padding-bottom: 1rem;
  }
  
  .feature-box-icon {
    width: 48px;
    height: 48px;
    margin-bottom: 12px;
    display: block;
    object-fit: contain;
  }
  
  .sidebar .nav-icons a {
    text-decoration: none !important;  /* ðŸ’¥ Force remove underline */
    color: inherit;                    /* ðŸŸ¦ Optional: match surrounding text color */
    display: flex;                     /* ðŸ”§ Keeps icon and label aligned */
    align-items: center;
    gap: 0.5rem;                       /* ðŸ‘ˆ Optional spacing between icon and label */
  }
  
  .chevron-icon {
    transition: transform 0.3s ease;
  }
  
  .chevron-icon.rotate {
    transform: rotate(180deg);
  }
  

  .goal-modal {
  position: fixed;
  z-index: 1002;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #fff;
  border-radius: 2rem;
  box-shadow: 0 10px 36px rgba(36,60,120,0.13), 0 2px 8px #357cf526;
  min-width: 350px;
  max-width: 95vw;
  padding: 2.6rem 2.1rem 2rem 2.1rem;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 1.6rem;
  animation: fadeIn 0.32s cubic-bezier(.21,.93,.49,1.05);
}
.goal-modal .modal-content {
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
}

.goal-modal h2 {
  font-size: 2rem;
  font-weight: 700;
  color: #212941;
  margin-bottom: 0.5rem;
  text-align: left;
}

.goal-choices {
  display: flex;
  gap: 0.75rem;
  justify-content: stretch;
  margin-bottom: 0.8rem;
}
.goal-card {
  flex: 1 1 0;
  background: #f8fafd;
  border: 2px solid #e3e8f2;
  border-radius: 14px;
  padding: 1.18rem 0.7rem 0.93rem 0.7rem;
  text-align: center;
  font-weight: 700;
  color: #25355a;
  font-size: 1.17rem;
  box-shadow: 0 1.5px 8px #3061cb10;
  cursor: pointer;
  transition: border 0.17s, box-shadow 0.16s, background 0.14s;
  min-width: 110px;
  outline: none;
  user-select: none;
}
.goal-card.selected,
.goal-card:active,
.goal-card:focus {
  border: 2.2px solid #357cf5;
  background: #eef4fe;
  color: #1d4dd1;
  box-shadow: 0 5px 20px #357cf513;
}
.goal-card span {
  font-size: 1.02rem;
  font-weight: 500;
  display: block;
  margin-top: 0.19em;
  color: #7b8ea8;
  letter-spacing: 0.01em;
}
.goal-modal label {
  margin-top: 0.3rem;
  margin-bottom: 0.18rem;
  font-weight: 600;
  color: #273760;
  font-size: 1.07rem;
  letter-spacing: -0.01em;
}
.goal-modal input[type="text"] {
  width: 100%;
  font-size: 1.09rem;
  border: 2px solid #e6eaf2;
  border-radius: 11px;
  padding: 0.86rem 1rem;
  background: #f7fafb;
  margin-bottom: 0.4rem;
  transition: border-color 0.14s, box-shadow 0.14s;
  font-family: inherit;
}
.goal-modal input[type="text"]:focus {
  border-color: #357cf5;
  box-shadow: 0 0 0 2px #357cf532;
  outline: none;
}

#goalSubmitBtn {
  background: #357cf5;
  color: #fff;
  font-weight: 700;
  font-size: 1.12rem;
  border: none;
  border-radius: 12px;
  padding: 0.98rem 0;
  margin-top: 0.6rem;
  opacity: 0.78;
  cursor: not-allowed;
  box-shadow: 0 1.5px 8px #357cf511;
  transition: background 0.16s, opacity 0.15s;
}
#goalSubmitBtn.enabled {
  opacity: 1;
  cursor: pointer;
  background: #357cf5;
}
#goalSubmitBtn.enabled:hover {
  background: #2057b9;
}
.modal-backdrop {
  position: fixed;
  z-index: 1000;
  top: 0; left: 0; width: 100vw; height: 100vh;
  background: rgba(40,50,80,0.12);
  backdrop-filter: blur(2px);
}
@media (max-width: 600px) {
  .goal-modal { min-width: 0; padding: 1.6rem 0.5rem;}
  .goal-choices { flex-direction: column; gap: 0.7rem; }
}
.goal-card.selected {
  outline: 0.5px solid #4f46e5;
  background: #E0F2FE ;
  /* add your own highlight styling if you want */
}


#searchDropdown {
  display: none;           /* Hidden by default */
  position: absolute;
  top: 42px;               /* Adjust based on your navbarSearch input height */
  right: 0;
  width: 340px;            /* Match or be slightly wider than your input */
  max-height: 320px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.08);
  z-index: 99;
  overflow-y: auto;
  padding: 0;
}
.dropdown-result {
  padding: 12px 18px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
  background: #fff;
  font-size: 16px;
  transition: background 0.12s;
}
.dropdown-result:last-child {
  border-bottom: none;
}
.dropdown-result:hover, .dropdown-result:focus {
  background: #f2f8fd;
  color: #0072ff;
}

.cq-modal {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0; top: 0; width: 100vw; height: 100vh;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  justify-content: center;
  align-items: center;
  transition: background 0.3s;
}
.cq-modal[style*="block"] {
  display: flex !important;
}
.cq-modal-content {
  background: linear-gradient(to bottom right, rgba(15, 23, 42, 0.95), rgba(2, 6, 23, 0.95));
  border: 2px solid rgba(239, 68, 68, 0.5);
  border-radius: 1.5rem;
  padding: 3rem;
  max-width: 540px;
  width: 90%;
  max-height: 85vh;
  overflow-y: auto;
  position: relative;
  backdrop-filter: blur(24px);
  -webkit-backdrop-filter: blur(24px);
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
}

.cq-close {
  position: absolute;
  top: 1.5rem;
  right: 1.5rem;
  font-size: 24px;
  color: #94a3b8;
  cursor: pointer;
  background: none;
  border: none;
  padding: 0.5rem;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s;
  z-index: 10;
}

.cq-close:hover {
  color: #fff;
}

.cq-modal-fields > div {
  margin-bottom: 16px;
  font-size: 16px;
  line-height: 1.5;
  color: #e2e8f0;
}

.cq-modal-fields > div > b {
  color: #fff;
  font-weight: 600;
  margin-right: 8px;
}

.cq-modal-fields ul {
  margin: 8px 0 0 20px;
  padding: 0;
}

.cq-modal-fields li {
  margin-bottom: 4px;
  color: #e2e8f0;
}

.cq-modal-title {
  font-size: 2.25rem;
  font-weight: 900;
  margin-bottom: 2rem;
  background: linear-gradient(to right, #ef4444, #f97316, #eab308);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-align: center;
  letter-spacing: 0.5px;
  position: relative;
  filter: drop-shadow(0 0 4px rgba(239, 68, 68, 0.4)) drop-shadow(0 0 8px rgba(249, 115, 22, 0.3));
}

.cq-modal-fields {
  margin-bottom: 1.25rem;
  margin-top: 0.5rem;
  color: #e2e8f0;
}

.cq-modal-fields b {
  color: #fff;
  font-weight: 600;
  margin-right: 4px;
}

.cq-modal-btn {
  background: linear-gradient(to right, #dc2626, #f97316);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 900;
  cursor: pointer;
  margin-right: 12px;
  transition: all 0.2s;
  transform: scale(1);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.cq-modal-btn:hover {
  background: linear-gradient(to right, #b91c1c, #ea580c);
  transform: scale(1.05);
}

.cq-modal-btn:last-child {
  margin-right: 0;
}


@media (max-width: 560px) {
  .cq-modal-content {
    max-width: 97vw;
    min-width: unset;
    padding: 1rem 0.7rem 1.4rem 0.7rem;
  }
  .cq-modal-title {
    font-size: 1.22rem;
  }
}
.comment-panel {
    background: white;
    border: 1px solid rgba(255, 255, 255, 0.18);
    overflow: hidden;
    backdrop-filter: blur(20px);
}

.comment-panel-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: none;
}

.comment-panel-header h3 {
    margin: 0;
    font-size: 1.125rem;
    font-weight: 600;
}

.mark-read-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    backdrop-filter: blur(20px);
    margin-right: 8px;
}

.mark-read-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
}

.close-panel-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 1.25rem;
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1;
    backdrop-filter: blur(20px);
}

.close-panel-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
}

/* Notification styles moved to CSS file */

/* All notification styles moved to CSS file - dark theme with orange glow */


/* Notification Badge - Red/Orange Theme */
.notification-badge {
  background: linear-gradient(135deg, #ef4444 0%, #f97316 100%);
  color: white;
  border-radius: 50%;
  min-width: 22px;
  height: 22px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: 900;
  position: absolute;
  top: -6px;
  right: -4px;
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
  border: 2px solid #000;
  z-index: 10;
}
/* Congrats Modal - should match your other modals */
#congratsModal {
  display: none;
  position: fixed;
  z-index: 1004; /* Higher than other modals */
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.6);
  backdrop-filter: blur(20px);
}

#congratsModal .cq-modal-content {
  background: white;
  margin: 10% auto;
  padding: 25px;
  width: 90%;
  max-width: 500px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  text-align: center;
  animation: modalFadeIn 0.3s ease-out;
}

#congratsModal .cq-modal-title {
  font-size: 1.8rem;
  color: #10b981;
  margin-bottom: 15px;
}

.cq-modal-title {
  font-size: 28px;
  font-weight: 600;
  color: #1f2937;
  margin: 0 0 24px 0;
  text-align: left;
}

#congratsModal .cq-modal-fields {
  font-size: 1.1rem;
  line-height: 1.6;
  margin: 20px 0;
}

.cq-modal-footer {
  margin-top: 32px;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

#congratsModal .cq-modal-btn {
  background: #10b981;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 1rem;
  cursor: pointer;
  transition: background 0.2s;
}

#congratsModal .cq-modal-btn:hover {
  background: #0d9f6e;
}

@keyframes modalFadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}


/* CertQuest Modal Styling */
.certq-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.4);
  z-index: 10000;
  font-family: 'Inter', sans-serif;
  animation: certqFadeIn 0.3s ease-out;
}

.certq-modal-content {
  position: relative;
  background: white;
  width: 90%;
  max-width: 420px;
  margin: 100px auto;
  border-radius: 12px;
  padding: 28px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.1);
  border: 1px solid #e5e7eb;
}

.certq-modal-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: #111827;
  margin-bottom: 1.25rem;
  text-align: center;
  line-height: 1.3;
}

.certq-modal-fields {
  color: #4b5563;
  font-size: 1rem;
  line-height: 1.5;
  padding: 0 0.5rem;
}

.certq-modal-footer {
  margin-top: 1.75rem;
  display: flex;
  justify-content: center;
  gap: 12px;
}

.certq-modal-btn {
  background: #2563eb;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.9rem;
}

.certq-modal-btn:hover {
  background: #1d4ed8;
  transform: translateY(-1px);
}

.certq-close {
  position: absolute;
  top: 16px;
  right: 20px;
  font-size: 1.75rem;
  color: #9ca3af;
  cursor: pointer;
  transition: color 0.2s ease;
  line-height: 1;
}

.certq-close:hover {
  color: #6b7280;
}

/* Animation */
@keyframes certqFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Responsive adjustments */
@media (max-width: 480px) {
  .certq-modal-content {
    width: 95%;
    padding: 20px;
  }
  
  .certq-modal-title {
    font-size: 1.3rem;
  }
  
  .certq-modal-btn {
    padding: 8px 16px;
  }
}

.cq-assignment-modal .complete-btn {
  background: #2563eb;
  color: white;
  border: none;
  padding: 12px;
  border-radius: 6px;
  font-weight: 500;
  cursor: pointer;
  width: 100%;
  transition: background 0.2s;
}

.cq-assignment-modal .complete-btn:hover {
  background: #1d4ed8;
}

canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1000;
}

/* Add these styles to your CSS file */
.complete-btn {
  background: #2563eb; /* Your brand blue */
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-weight: 600;
  font-family: 'Inter', sans-serif;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%; /* Full width of container */
  margin-top: 1rem;
}

.complete-btn:hover {
  background: #1d4ed8; /* Slightly darker blue */
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.complete-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.complete-btn:disabled {
  background: #e5e7eb;
  color: #9ca3af;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

/* Optional: Add checkmark icon */
.complete-btn::after {
  content: 'âœ“';
  font-size: 1.2rem;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.complete-btn:hover::after {
  opacity: 1;
}

.quiz-meta {
  display: flex;
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  color: #666;
  font-size: 0.9rem;
}

.quiz-question {
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #eee;
}
 
.quiz-question:last-child {
  border-bottom: none;
}

.quiz-question h4 {
  margin-bottom: 0.8rem;
  color: #333;
}

.quiz-option {
  display: block;
  margin: 0.5rem 0;
  padding: 0.5rem;
  border-radius: 4px;
  cursor: pointer;
}

.quiz-option:hover {
  background: #f5f5f5;
}

.quiz-option input {
  margin-right: 0.5rem;
}

#submitQuizBtn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.cq-speaking-modal {
  position: fixed;
  z-index: 3100;
  left: 0; top: 0; right: 0; bottom: 0;
  align-items: center;
  justify-content: center;
  background: rgba(36, 45, 74, 0.17);
}
.cq-speaking-modal-content {
  background: #fff;
  border-radius: 2rem;
  box-shadow: 0 10px 40px rgba(24,36,85,.14), 0 1.5px 3px rgba(44,62,80,.05);
  max-width: 420px;
  width: 95%;
  padding: 2.2rem 2.5rem 2rem 2.5rem;
  position: relative;
  animation: modalpop .23s cubic-bezier(.51,1.35,.5,1) 1;
}
.cq-speaking-title {
  margin-bottom: 1.25rem;
  font-size: 1.6rem;
  font-weight: 700;
  color: #1750eb;
  text-align: center;
}
.cq-speaking-section {
  margin-bottom: 1.25rem;
}
.cq-speaking-label {
  font-weight: 600;
  color: #2b3751;
  margin-bottom: 0.25rem;
  display: block;
  font-size: 1rem;
}
.cq-speaking-qtext {
  margin-bottom: 0.4rem;
  font-size: 1.03rem;
  color: #2d3646;
  background: #f5f7fd;
  padding: 0.5rem 0.85rem;
  border-radius: 0.8rem;
}
.cq-speaking-btn {
  background: #2563eb;
  color: #fff;
  font-weight: 600;
  border: none;
  border-radius: 1.1rem;
  padding: 0.65rem 1.25rem;
  margin-right: 0.5rem;
  margin-top: 0.5rem;
  font-size: 1rem;
  transition: background .15s;
  cursor: pointer;
  box-shadow: 0 1.5px 4px rgba(44,62,80,.07);
}
.cq-speaking-btn:hover, .cq-speaking-btn:focus {
  background: #1a42a6;
}
.cq-speaking-submit {
  margin-top: 1.2rem;
  width: 100%;
  font-size: 1.1rem;
}
.cq-speaking-close {
  position: absolute;
  top: 1.2rem;
  right: 1.2rem;
  font-size: 2rem;
  font-weight: 600;
  color: #d0d3e2;
  cursor: pointer;
  z-index: 3;
}
.cq-speaking-close:hover { color: #4f5ca3; }
.cq-speaking-video, .cq-speaking-audio {
  border-radius: 1rem;
  background: #eef1f8;
  border: 1px solid #e4e7f5;
  margin-bottom: 1rem;
  margin-top: 0.2rem;
  width: 100%;
  outline: none;
}

.cq-speaking-section {
  margin: 1.5rem 0;
  font-family: 'Inter', sans-serif;
  color: #1e293b; /* dark slate */
}

.cq-speaking-label {
  display: block;
  font-weight: 600;
  margin-bottom: 0.6rem;
  font-size: 1.1rem;
  color: #334155; /* softer dark */
}

.recording-controls {
  display: flex;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.recording-controls button {
  background-color: transparent;
  border: 1.5px solid #3b82f6; /* subtle blue border */
  color: #3b82f6;
  font-size: 1rem;
  padding: 0.5rem 1.2rem;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s ease, color 0.3s ease;
  box-shadow: none;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.recording-controls button:hover:not(:disabled) {
  background-color: #3b82f6;
  color: white;
  border-color: #3b82f6;
}

.recording-controls button:disabled {
  border-color: #a5b4fc;
  color: #a5b4fc;
  cursor: not-allowed;
}

#cq-speaking-submitBtn {
  background-color: transparent;
  border: 1.5px solid #10b981; /* subtle green border */
  color: #10b981;
  font-weight: 600;
  padding: 0.65rem 2rem;
  font-size: 1.1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s ease, color 0.3s ease;
  width: 100%;
  max-width: 320px;
  margin: 1rem auto 0 auto;
  display: block;
}

#cq-speaking-submitBtn:hover:not(:disabled) {
  background-color: #10b981;
  color: white;
  border-color: #10b981;
}

#cq-speaking-submitBtn:disabled {
  border-color: #a7f3d0;
  color: #a7f3d0;
  cursor: not-allowed;
}


.media-preview {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-top: 0.5rem;
}

.media-preview audio,
.media-preview video {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgb(0 0 0 / 0.15);
  max-width: 100%;
  outline: none;
}

#cq-speaking-submitBtn {
  background-color: #4a90e2; /* pastel blue */
  color: white;
  font-weight: 600;
  padding: 0.65rem 2.2rem;
  font-size: 1.15rem;
  border-radius: 10px;
  border: none;
  cursor: pointer;
  transition: background-color 0.25s ease;
  width: 100%;
  max-width: 360px;
  display: block;
  margin: 1.5rem auto 0 auto;
  box-shadow: none;
}

#cq-speaking-submitBtn:hover:not(:disabled) {
  background-color: #357abd; /* slightly deeper blue */
}

#cq-speaking-submitBtn:disabled {
  background-color: #a3c2f2; /* lighter pastel blue */
  cursor: not-allowed;
  color: #e0e6f7;
}

.drag-drop-zone {
  border: 2px dashed #2563eb;
  border-radius: 10px;
  background: #f3f6fd;
  padding: 2rem;
  text-align: center;
  font-size: 1.1rem;
  color: #2563eb;
  cursor: pointer;
  margin: 1rem 0;
  transition: all 0.2s ease;
  min-height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.drag-drop-zone:hover {
  background: #e0ebff;
  border-color: #1e40af;
  transform: translateY(-1px);
}

#cq-speaking-uploadSubmitBtn {
  width: 100%;
  margin-top: 1rem;
  padding: 12px 24px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

#cq-speaking-uploadSubmitBtn:hover:not(:disabled) {
  background: #1e40af;
  transform: translateY(-1px);
}

#cq-speaking-uploadSubmitBtn:disabled {
  background: #94a3b8;
  cursor: not-allowed;
  transform: none;
}

#mentorCommentModal {
  display: none; /* hidden by default */
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  width: 100vw; height: 100vh;
  background: rgba(30, 41, 59, 0.30); /* translucent dark overlay */
  z-index: 5000;
  align-items: center;
  justify-content: center;
}

#mentorCommentModal .modal-content {
  background: #fff;
  border-radius: 1.25rem;
  box-shadow: 0 4px 40px rgba(0,0,0,0.13), 0 1.5px 8px rgba(60,60,120,0.08);
  padding: 2.2rem 2.5rem;
  max-width: 390px;
  width: 100%;
  margin: 0 auto;
  text-align: left;
  position: relative;
  animation: popIn 0.19s cubic-bezier(.42,1.54,.64,1) 1;
}

#mentorCommentModal .close {
  position: absolute;
  top: 20px;
  right: 24px;
  font-size: 2rem;
  color: #444;
  background: none;
  border: none;
  cursor: pointer;
  transition: color 0.13s;
}
#mentorCommentModal .close:hover {
  color: #2563eb;
}

#mentorCommentAssignment {
  font-size: 1.15rem;
  font-weight: 700;
  margin-bottom: 1rem;
  color: #222;
}
#mentorCommentText {
  color: #444;
  font-size: 1.04rem;
  margin-bottom: 1.3rem;
}

#mentorCommentModal .btn {
  background: linear-gradient(90deg, #aee7f5, #e0c3fc);
  color: #1e293b;
  border: none;
  border-radius: 0.95rem;
  padding: 0.7rem 1.5rem;
  font-size: 1.05rem;
  font-weight: 600;
  cursor: pointer;
  width: 100%;
  transition: background 0.14s, transform 0.09s;
}
#mentorCommentModal .btn:hover {
  background: linear-gradient(90deg, #dbeafe, #f3e8ff);
  transform: translateY(-2px) scale(1.03);
}

@keyframes popIn {
  from { transform: scale(0.92); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

/* Add to your home.css */
.competency-result {
  margin: 1rem 0;
  padding: 0.5rem;
  background: #f8fafc;
  border-radius: 8px;
}

.progress-bar {
  height: 6px;
  background: #e2e8f0;
  border-radius: 3px;
  margin-top: 0.5rem;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: #4ade80;
  transition: width 0.3s ease;
}

.cq-modal-fields h4 {
  margin-bottom: 0.5rem;
  color: #334155;
}

.competency-result {
    margin: 1rem 0;
    padding: 1rem;
    background: #f8fafc;
    border-radius: 8px;
}

.question-result {
    margin: 0.5rem 0;
    padding: 0.5rem;
}

.question-result.correct {
    border-left: 4px solid #4ade80;
}

.question-result.incorrect {
    border-left: 4px solid #f87171;
}

.comment-panel {
  position: fixed;
  top: 60px;
  left: 70px; /* align with edge of sidebar */
  width: 400px;
  height: calc(100% - 60px);
  background: #fff;
  border-right: 1px solid #ddd;
  
  transform: translateX(-100%);
  transition: transform 0.3s ease;
  display: flex;
  flex-direction: column;
}

.comment-panel.active {
  transform: translateX(0);
}


.comment-header {
  display: flex;
  justify-content: space-between;
  padding: 1rem;
  font-weight: bold;
  border-bottom: 1px solid #eee;
}

.comment-content {
  padding: 1rem;
  flex: 1;
  overflow-y: auto;
}

.reply-container {
  padding: 1rem;
  border-top: 1px solid #eee;
}

.reply-box {
  width: 100%;
  height: 60px;
  padding: 0.75rem;
  border: 1px solid #ccc;
  border-radius: 6px;
  resize: none;
}

.comment {
  background: #f7f7f7;
  padding: 0.75rem;
  border-radius: 8px;
  margin-bottom: 1rem;
}

.close-btn {
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
}



.cq-written-modal{
          
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            z-index: 1000000000000000;
            animation: fadeIn 0.3s ease-out;
        }

        .cq-written-modal-content {
            position: relative;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(25px);
            border-radius: 24px;
            max-width: 1050px;
            width: 95%;
            margin: 2% auto;
            padding: 0;
            box-shadow: 
                0 32px 64px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            animation: slideInUp 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            max-height: 90vh;
            overflow-y: auto;
        }

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(40px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.cq-written-header {
  padding: 24px 32px 20px;
  border-bottom: 1px solid #e2e8f0;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.cq-written-title-section {
  flex: 1;
}

.cq-written-title {
  font-size: 24px;
  font-weight: 600;
  color: #1a202c;
  margin: 0 0 8px 0;
  line-height: 1.3;
}

.cq-written-meta {
  display: flex;
  gap: 20px;
  font-size: 14px;
  color: #64748b;
  font-weight: 500;
}

.cq-written-close {
  background: none;
  border: none;
  font-size: 28px;
  color: #94a3b8;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  transition: all 0.2s ease;
}

.cq-written-close:hover {
  background: #f1f5f9;
  color: #475569;
}

.cq-written-body {
  padding: 32px;
  flex: 1;
  overflow-y: auto;
}

.cq-written-competency {
  display: inline-block;
  background: #dbeafe;
  color: #1e40af;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 20px;
}

.cq-written-question {
  font-size: 20px;
  font-weight: 500;
  color: #1a202c;
  line-height: 1.4;
  margin-bottom: 32px;
}

.cq-written-options {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.cq-written-option {
  display: flex;
  align-items: flex-start;
  padding: 20px;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  background: white;
}

.cq-written-option:hover {
  border-color: #cbd5e1;
  background: #f8fafc;
}

.cq-written-option.selected {
  border-color: #3b82f6;
  background: #f0f9ff;
}

.cq-written-option input[type="radio"] {
  margin: 0 16px 0 0;
  width: 20px;
  height: 20px;
  accent-color: #3b82f6;
  cursor: pointer;
}

.cq-written-option-text {
  flex: 1;
  font-size: 16px;
  color: #374151;
  line-height: 1.5;
}



.cq-written-footer {
  padding: 24px 32px;
  border-top: 1px solid #e2e8f0;
  background: #fafbfc;
}

.cq-written-progress {
  margin-bottom: 16px;
}

.cq-written-progress-bar {
  width: 100%;
  height: 6px;
  background: #e2e8f0;
  border-radius: 3px;
  overflow: hidden;
}

.cq-written-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3b82f6, #1d4ed8);
  border-radius: 3px;
  transition: width 0.3s ease;
  width: 10%; /* Will be updated by JavaScript */
}

.cq-written-nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.cq-written-btn {
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 100px;
}

.cq-written-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.cq-written-btn-secondary {
  background: white;
  color: #64748b;
  border: 1px solid #e2e8f0;
}

.cq-written-btn-secondary:hover:not(:disabled) {
  background: #f8fafc;
  border-color: #cbd5e1;
}

.cq-written-btn-primary {
  background: #3b82f6;
  color: white;
}

.cq-written-btn-primary:hover:not(:disabled) {
  background: #2563eb;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

/* Mobile responsiveness */
@media (max-width: 640px) {
  .cq-written-modal-content {
    width: 95%;
    max-height: 95vh;
  }
  
  .cq-written-header {
    padding: 20px 24px 16px;
  }
  
  .cq-written-body {
    padding: 24px;
  }
  
  .cq-written-footer {
    padding: 20px 24px;
  }
  
  .cq-written-title {
    font-size: 20px;
  }
  
  .cq-written-question {
    font-size: 18px;
    margin-bottom: 30px;
  }
  
  .cq-written-option {
    padding: 16px;
  }
}

/* Replace your existing .cq-written-modal styles with: */
.cq-written-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(20px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding: 20px;
}

.cq-written-modal-content {
    background: white;
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    width: 100%;
    max-width: 1050px;
    max-height: 90vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* Enhanced header styling */
.cq-written-header {
    padding: 24px 24px 0 24px;
    border-bottom: none;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.cq-written-title {
    font-size: 24px;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 8px 0;
}

.cq-written-meta {
    display: flex;
    gap: 20px;
    font-size: 14px;
    color: #64748b;
    font-weight: 500;
}

.cq-written-close {
    background: none;
    border: none;
    font-size: 24px;
    color: #94a3b8;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
}

.cq-written-close:hover {
    background: #f1f5f9;
    color: #64748b;
}

/* Body styling */
.cq-written-body {
    padding: 24px;
    flex: 1;
    overflow-y: auto;
}

.cq-written-competency {
    background: #dbeafe;
    color: #1e40af;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    display: inline-block;
    margin-bottom: 20px;
}

.cq-written-question {
    font-size: 18px;
    font-weight: 500;
    color: #1e293b;
    line-height: 1.5;
    margin: 0 0 24px 0;
    margin-bottom: 30px;
}

/* Enhanced options styling */
.cq-written-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.cq-written-option {
    display: flex;
    align-items: flex-start;
    padding: 16px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: white;
}

.cq-written-option:hover {
    border-color: #cbd5e1;
    background: #f8fafc;
}

.cq-written-option.selected {
    border-color: #3b82f6;
    background: #eff6ff;
}

.cq-written-option input[type="radio"] {
    margin: 2px 12px 0 0;
    width: 18px;
    height: 18px;
    accent-color: #3b82f6;
    flex-shrink: 0;
}

.cq-written-option-text {
    flex: 1;
    font-size: 16px;
    color: #374151;
    line-height: 1.5;
}

/* Footer styling */
.cq-written-footer {
    padding: 24px;
    border-top: 1px solid #e2e8f0;
    background: #fafafa;
}

.cq-written-progress {
    margin-bottom: 16px;
}

.cq-written-progress-bar {
    width: 100%;
    height: 6px;
    background: #e2e8f0;
    border-radius: 3px;
    overflow: hidden;
}

.cq-written-progress-fill {
    height: 100%;
    background: #3b82f6;
    transition: width 0.3s ease;
    border-radius: 3px;
}

.cq-written-nav {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.cq-written-btn {
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
    min-width: 80px;
}

.cq-written-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.cq-written-btn-secondary {
    background: #f1f5f9;
    color: #64748b;
}

.cq-written-btn-secondary:hover:not(:disabled) {
    background: #e2e8f0;
    color: #475569;
}

.cq-written-btn-primary {
    background: #3b82f6;
    color: white;
}

.cq-written-btn-primary:hover:not(:disabled) {
    background: #2563eb;
}


.record-my-answer-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 15px 30px;
    border-radius: 25px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
    width: 100%;
    margin: 20px 0;
}
.sub-nav-wrapper{
  z-index: -10;
}

.record-my-answer-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 30px rgba(102, 126, 234, 0.4);
}


  
  
  
  .checkbox-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
margin-top:-15px;
  }
  
  
  .checkbox-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 1rem;
  }

  
 
  .start-btn {
    margin-top: 1.5rem;
    width: 100%;
    padding: 0.6rem 1.2rem;
    background-color: #0066ff;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
  }
  
  .start-btn:hover {
    background-color: #004ecb;
  }
  
  .close-btn {
    float: right;
    font-size: 1.4rem;
    font-weight: bold;
    cursor: pointer;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-20px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  
  .select-all-btn {
    border: 1.5px solid #ddd;
    background-color: #f0f4ff;
    color: #0066ff;
    padding: 0.4rem 1rem;
    font-size: 0.9rem;
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    width: 26%;
  }
  
  /* Close button */

  /* Section spacing */
  .modal-section {
    margin-top: 1.5rem;
  }
  
  /* Textarea */
  textarea {
    width: 100%;
    padding: 1rem;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 8px;
    resize: vertical;
    font-family: 'Inter', sans-serif;
    background: #f8faff;
  }
  
  /* Buttons */
  button {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 0.75rem 1.25rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 600;
    margin-top: 1rem;
    transition: background-color 0.2s ease;
  }
  button:hover {
    background-color: #0056b3;
  }
  
  /* Recording options */
  .recording-options {
    display: flex;
    gap: 0.75rem;
    margin-top: 0.75rem;
  }
  .recording-options button {
    background-color: #17a2b8;
  }
  .recording-options button:hover {
    background-color: #117a8b;
  }
  
  /* Checkbox label */
  label input[type="checkbox"] {
    margin-right: 0.5rem;
    accent-color: #007bff;
  }
  
  /* Hide element */
  .hidden {
    display: none;
  }

  /* Question List */
#questionList {
    list-style-type: disc;
    padding-left: 1.25rem;
    margin-top: 0.5rem;
  }
  #questionList li {
    margin-bottom: 0.5rem;
    font-size: 1rem;
  }
  
  /* Section header */
  #questionArea h3 {
    margin-top: 1.5rem;
    font-size: 1.25rem;
    color: #222;
  }
  
  /* Recording options */
  .recording-options {
    display: flex;
    gap: 0.75rem;
    margin-top: 0.75rem;
  }
  .recording-options button {
    background-color: #00b0c8;
    color: white;
    font-weight: 600;
    border: none;
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    border-radius: 10px;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color 0.2s ease;
  }
  .recording-options button:hover {
    background-color: #008fa3;
  }
  
  /* Checkbox label */
  #questionArea label {
    display: flex;
    align-items: center;
    margin-top: 1.2rem;
    gap: 0.5rem;
    font-size: 1rem;
    font-weight: 500;
  }

  .question-card-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin-top: 1rem;
  }
  
  .question-card {
    background-color: #f4f8ff;
    border-radius: 12px;
    padding: 1rem 1.25rem;
    box-shadow: 0 2px 6px rgba(0,0,0,0.04);
    font-size: 1rem;
    color: #333;
    font-weight: 500;
    transition: transform 0.2s ease;
  }
  
  .question-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.07);
  }

  .media-preview {
    margin-top: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .stop-recording-btn {
    background-color: #ff4b5c;
    color: white;
    padding: 0.5rem 1rem;
    font-weight: bold;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  
  .stop-recording-btn:hover {
    background-color: #e93d4d;
  }
  
  
  

  .training-meta .completed-badge {
    background: #fff7d1;
    color: #b98000;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
  }
  

  
  .competency-grid input[type="checkbox"] {
    appearance: none;
    width: 1.1rem;
    height: 1.1rem;
    border: 2px solid #999;
    border-radius: 0.25rem;
    background: white;
    position: relative;
    transition: all 0.2s ease;
  }
  
  .competency-grid input[type="checkbox"]:checked {
    background-color: #3b82f6;
    border-color: #3b82f6;
  }
  
  .competency-grid input[type="checkbox"]:checked::after {
    content: 'âœ”';
    color: white;
    font-size: 0.8rem;
    position: absolute;
    top: -2px;
    left: 3px;
  }
  
  .competency-grid label:hover {
    background-color: #e2e8f0;
  }
  
  #searchDropdown {
  display: none;           /* Hidden by default */
  position: absolute;
  top: 42px;               /* Adjust based on your navbarSearch input height */
  right: 0;
  width: 340px;            /* Match or be slightly wider than your input */
  max-height: 320px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.08);
  z-index: 99;
  overflow-y: auto;
  padding: 0;
}
.dropdown-result {
  padding: 12px 18px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
  background: #fff;
  font-size: 16px;
  transition: background 0.12s;
}
.dropdown-result:last-child {
  border-bottom: none;
}
.dropdown-result:hover, .dropdown-result:focus {
  background: #f2f8fd;
  color: #0072ff;
}

#userCheckboxes {
  display: flex;
  flex-direction: column;
  gap: 0.15rem; /* closer but still breathable */
  padding: 0.25rem 0;
  max-height: 200px;
  overflow-y: auto;
}

/* Individual Checkbox Label */
#userCheckboxes label {
  display: flex;
  align-items: center;
  gap: 0.3rem; /* slightly tighter */
  font-size: 0.88rem;
  padding: 0.1rem 0.25rem;
  line-height: 1.1;
  border-radius: 6px;
  transition: background 0.15s ease;
  cursor: pointer;
}

#userCheckboxes label:hover {
  background: rgba(240, 240, 240, 0.6);
}

.user-checkbox {
  accent-color: #007aff;
  transform: scale(1.05);
  margin: 0;
}

/* Status Badge */
.status-badge {
    position: absolute;
    top: 0;
    right: 0;
    background: #10b981; /* Green for completed */
    color: white;
    padding: 0.25rem 0.75rem;
    border-radius: 0 12px 0 12px;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
}

.status-badge.incomplete {
    background: #f59e0b; /* Amber for pending */
}

/* Meta Info Row */
.training-meta {
    display: flex;
    align-items: center;       /* Vertical alignment */
    justify-content: space-between; /* Pushes elements to edges */
    width: 100%;              /* Full width of card */
    margin-top: 1rem;
    gap: 0.5rem;              /* Space between elements */
    border-top: 1px solid #f3f4f6; /* Add subtle divider */
}

.assignment-type {
    font-weight: 600;
    color: #3b82f6; /* Blue "SKILL BUILDER" text */
}

.mentee-name {
    margin-right: auto; /* Pushes to far right */
    font-weight: 600;
    margin-bottom: 10px;
    color: #3b82f6; /* Blue "SKILL BUILDER" text */
}

/* Dropdown Container */
.dropdown-sort {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    position: relative;
}

/* Dropdown Label */
.dropdown-sort label {
    font-size: 0.875rem;
    color: #4b5563; /* neutral-600 */
    font-weight: 500;
    white-space: nowrap;
}

/* Select Element Styling */
.dropdown-sort select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0.5rem 2rem 0.5rem 0.75rem;
    font-size: 0.875rem;
    border: 1px solid #e5e7eb; /* gray-200 */
    border-radius: 0px;
    background-color: white;
    color: #111827; /* gray-900 */
    cursor: pointer;
    min-width: 150px;
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    appearance: auto;
    -webkit-appearance: menulist;
    -moz-appearance: menulist;

}

/* This controls the dropdown styling */
select {
  padding: 12px 40px 12px 20px;
  font-size: 16px;
  font-family: inherit;
  border: 1px solid rgba(79, 172, 254, 0.3);
  border-radius: 1px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  color: #4facfe;
  cursor: pointer;
  min-width: 10px;
  width: 20vw;
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%234facfe" stroke-width="2"><polyline points="6,9 12,15 18,9"></polyline></svg>');
  background-repeat: no-repeat;
  background-position: right 16px center;
  background-size: 16px;
  transition: all 0.3s ease;
  box-shadow: 0 4px 20px rgba(79, 172, 254, 0.1);
  margin-right: 200px;
  display: inline-block;
}

select:hover {
  border-color: #4facfe;
  box-shadow: 0 6px 25px rgba(79, 172, 254, 0.2);
  transform: translateY(-1px);
}

select:focus {
  outline: none;
  border-color: #4facfe;
  box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
}

.delete-training-btn {
  background: rgba(30, 41, 59, 0.5);
  color: #cbd5e1;
  padding: 12px 20px;
  border: 2px solid rgba(239, 68, 68, 0.5);
  border-radius: 0.75rem;
  cursor: pointer;
  font-weight: 600;
  font-size: 16px;
  transition: all 0.3s ease;
  display: inline-block;
  white-space: nowrap;
  box-sizing: border-box;
}

.delete-training-btn:hover {
  background: rgba(239, 68, 68, 0.2);
  border-color: rgba(239, 68, 68, 0.8);
  color: #fff;
  transform: translateY(-2px);
}

#pdfModal .delete-training-btn {
  background: rgba(30, 41, 59, 0.5);
  color: #cbd5e1;
  border: 2px solid rgba(239, 68, 68, 0.5);
}

#pdfModal .delete-training-btn:hover {
  background: rgba(239, 68, 68, 0.2);
  border-color: rgba(239, 68, 68, 0.8);
  color: #fff;
}



/* Hover State */
.dropdown-sort select:hover {
    border-color: #9ca3af; /* gray-400 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

/* Focus State */
.dropdown-sort select:focus {
    outline: none;
    border-color: #3b82f6; /* blue-500 */
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
}

/* Active State */
.dropdown-sort select:active {
    border-color: #2563eb; /* blue-600 */
}

/* Dropdown Options */
.dropdown-sort option {
    padding: 0.5rem;
    font-size: 0.875rem;
    background: white;
    color: #111827;
}

/* Disabled State */
.dropdown-sort select:disabled {
    background-color: #f3f4f6; /* gray-50 */
    color: #9ca3af; /* gray-400 */
    cursor: not-allowed;
}

/* Base button style - more specific selectors */
.speaking-time-btn,
.speaking-focus-btn,
.case-time-btn,
.case-focus-btn,
.case-difficulty-btn,
.difficulty-btn,
.time-btn,
.focus-btn {
  background-color: rgba(15, 23, 42, 0.3) !important;
  border: 1.5px solid rgba(185, 28, 28, 0.3) !important;
  color: #cbd5e1 !important;
  padding: 10px 18px !important;
  border-radius: 8px !important;
  font-weight: 600 !important;
  cursor: pointer !important;
  transition: all 0.3s ease !important;
  user-select: none !important;
  margin: 4px !important;
}

/* Hover effect - only when NOT selected */
.speaking-time-btn:not(.selected):hover,
.speaking-focus-btn:not(.selected):hover,
.case-time-btn:not(.selected):hover,
.case-focus-btn:not(.selected):hover,
.case-difficulty-btn:not(.selected):hover,
.difficulty-btn:not(.selected):hover,
.time-btn:not(.selected):hover,
.focus-btn:not(.selected):hover {
  background-color: rgba(127, 29, 29, 0.2) !important;
  border-color: rgba(239, 68, 68, 0.5) !important;
  color: #fff !important;
}

/* Selected state - highest priority */
.speaking-time-btn.selected,
.speaking-focus-btn.selected,
.case-time-btn.selected,
.case-focus-btn.selected,
.case-difficulty-btn.selected,
.difficulty-btn.selected,
.time-btn.selected,
.focus-btn.selected {
  background-color: rgba(127, 29, 29, 0.4) !important;
  border-color: rgba(239, 68, 68, 0.7) !important;
  color: #f87171 !important;
  box-shadow: 0 0 8px rgba(239, 68, 68, 0.4) !important;
}

/* Selected buttons should not change on hover */
.speaking-time-btn.selected:hover,
.speaking-focus-btn.selected:hover,
.case-time-btn.selected:hover,
.case-focus-btn.selected:hover,
.case-difficulty-btn.selected:hover,
.difficulty-btn.selected:hover,
.time-btn.selected:hover,
.focus-btn.selected:hover {
  background-color: #a3b4ff !important;
  border-color: #778cff !important;
  color: #1f3db8 !important;
}

/* Focus outline for accessibility */
.speaking-time-btn:focus,
.speaking-focus-btn:focus,
.case-time-btn:focus,
.case-focus-btn:focus,
.case-difficulty-btn:focus,
.difficulty-btn:focus,
.time-btn:focus,
.focus-btn:focus {
  outline: 2px solid #778cff !important;
  outline-offset: 2px !important;
}

.case-modal {
  z-index: 9000000;
}

.file-box-wrapper {
  display: flex;
  justify-content: center;
  margin-top: 10px;
  margin-bottom: 5px;
}

.file-box {
  background: #f5f5f5;
  padding: 8px 12px;
  border-radius: 8px;
  max-width: 85%;
  width: 85%;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9rem;
  word-break: break-word;
  overflow-wrap: anywhere;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}

.file-box a {
  color: #007bff;
  text-decoration: none;
}

.file-box a:hover {
  text-decoration: underline;
}

.card-header {
  margin-bottom: 1rem;
}

.card-content {
  flex-grow: 1;
  margin-bottom: 1.5rem;
}

.card-footer {
  margin-top: auto;
}

.mentee-name {
  font-weight: 600;
  font-size: 0.85rem;
  color: #6366f1;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 0.75rem;
}

.training-card h4 {
  font-size: 1.25rem; /* Increased from 1.2rem */
  font-weight: 700;
  margin-bottom: 1rem; /* Increased from 0.75rem */
  line-height: 1.3;
  color: #111827;
}

.training-card p {
  font-size: 0.9rem;
  line-height: 1.6;
  color: #6b7280;
  margin-bottom: 1rem;
}

.modal-content h2 {

            color: rgba(75, 85, 99, 0.9);
            margin: 0 0 30px 0;
            font-size: 32px;
            font-weight: 300;
            text-align: center;
            letter-spacing: -0.5px;
}

#trainingModal .modal-content h2 {
    background: none !important;
    -webkit-text-fill-color: initial !important;
    color: #374151 !important; /* Solid dark gray */
    font-size: 3.5rem !important;
    font-weight: 700 !important;
}

#pdfModal .modal-content h2 {
    background: none !important;
    -webkit-text-fill-color: initial !important;
    color: #fff !important; /* White text for dark theme */
    font-size: 2.25rem !important;
    font-weight: 900 !important;
    margin-bottom: 2.5rem !important;
    text-align: center !important;
}

.modal-content .close {
    /* Remove conflicting properties and streamline */
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.1);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: blur(20px);
    float: right;
    font-size: 20px;
    font-weight: 400;
    color: #6b7280;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    position: relative;
    margin: -10px -10px 0 0; /* Better positioning */
    z-index: 10;
    
    /* Ensure X is perfectly centered */
    line-height: 1;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

.modal-content .close::before {
    content: "Ã—";
    display: block;
    font-size: 24px;
    font-weight: 300;
    line-height: 1;
    transform: translateY(-1px); /* Fine-tune vertical alignment */
}

.modal-content .close:hover {
    background: rgba(255, 255, 255, 1);
    border-color: rgba(0, 0, 0, 0.15);
    color: #374151;
    transform: scale(1.05);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

.modal-content .close:active {
    transform: scale(0.95);
    transition-duration: 0.1s;
}

/* Focus state for accessibility */
.modal-content .close:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
}


.modal-content {
    background: rgba(255, 255, 255, 0.98) !important;
    backdrop-filter: blur(20px) !important;
    border: 1px solid rgba(59, 130, 246, 0.1) !important;
    border-radius: 16px !important;
    box-shadow: 0 8px 32px rgba(59, 130, 246, 0.08) !important;
    padding: 2rem !important;
}

/* Clean Headers */
.modal-content h2 {
    font-size: 1.5rem !important;
    font-weight: 600 !important;
    color: #1e293b !important;
    margin-bottom: 1.5rem !important;
    letter-spacing: -0.01em !important;
}

.modal-content h3 {
    font-size: 1.125rem !important;
    font-weight: 500 !important;
    color: #334155 !important;
    margin: 1.5rem 0 1rem 0 !important;
}

/* Blue Time Buttons - Compact & Modern */
button[onclick*="selectTime"], .time-btn {
    background: rgba(59, 130, 246, 0.05) !important;
    color: #3b82f6 !important;
    border: 1px solid rgba(59, 130, 246, 0.2) !important;
    padding: 0.75rem 1.25rem !important;
    border-radius: 10px !important;
    font-weight: 500 !important;
    font-size: 0.9rem !important;
    margin: 0.25rem !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    box-shadow: none !important;
}

button[onclick*="selectTime"]:hover, .time-btn:hover {
    background: rgba(127, 29, 29, 0.2) !important;
    border-color: rgba(239, 68, 68, 0.5) !important;
    transform: none !important;
}

button[onclick*="selectTime"].selected, .time-btn.selected {
    background: rgba(127, 29, 29, 0.4) !important;
    color: #f87171 !important;
    border-color: rgba(239, 68, 68, 0.7) !important;
}

/* Modern Blue Checkboxes */
input[type="checkbox"] {
    appearance: none !important;
    -webkit-appearance: none !important;
    width: 20px !important;
    height: 20px !important;
    border: 2px solid #e2e8f0 !important;
    border-radius: 6px !important;
    background: white !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    position: relative !important;
    margin-right: 0.75rem !important;
    box-shadow: none !important;
}

input[type="checkbox"]:hover {
    border-color: #3b82f6 !important;
}

input[type="checkbox"]:checked {
    background: #3b82f6 !important;
    border-color: #3b82f6 !important;
}

input[type="checkbox"]:checked::after {
    content: 'âœ“' !important;
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    color: white !important;
    font-size: 12px !important;
    font-weight: 600 !important;
}

/* Compact Labels */
label {
    display: flex !important;
    align-items: center !important;
    font-weight: 400 !important;
    color: #475569 !important;
    font-size: 0.95rem !important;
    margin-bottom: 0.75rem !important;
    cursor: pointer !important;
    padding: 0.25rem 0 !important;
}

label:hover {
    color: #334155 !important;
}

/* Blue Textarea */
textarea {
    background: rgba(59, 130, 246, 0.02) !important;
    border: 1px solid rgba(59, 130, 246, 0.2) !important;
    border-radius: 10px !important;
    padding: 1rem !important;
    font-size: 0.9rem !important;
    transition: all 0.2s ease !important;
    box-shadow: none !important;
    width: 100% !important;
    min-height: 100px !important;
    box-sizing: border-box !important;
    color: #1e293b !important;
    line-height: 1.5 !important;
}

textarea:focus {
    background: rgba(59, 130, 246, 0.05) !important;
    border-color: #3b82f6 !important;
    outline: none !important;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1) !important;
}

textarea::placeholder {
    color: #94a3b8 !important;
}

/* Blue Select All Button */
button[onclick*="selectAll"], button[onclick*="Select"] {
    background: rgba(59, 130, 246, 0.08) !important;
    color: #3b82f6 !important;
    border: 1px solid rgba(59, 130, 246, 0.2) !important;
    padding: 0.5rem 1rem !important;
    border-radius: 8px !important;
    font-weight: 500 !important;
    font-size: 0.85rem !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    box-shadow: none !important;
    margin: 0.5rem 0 !important;
}

button[onclick*="selectAll"]:hover, button[onclick*="Select"]:hover {
    background: rgba(59, 130, 246, 0.12) !important;
    border-color: #3b82f6 !important;
}

/* Difficulty Buttons */
button[onclick*="difficulty"], .difficulty-btn {
    background: rgba(59, 130, 246, 0.05) !important;
    color: #3b82f6 !important;
    border: 1px solid rgba(59, 130, 246, 0.2) !important;
    padding: 0.75rem 1.25rem !important;
    border-radius: 10px !important;
    font-weight: 500 !important;
    font-size: 0.9rem !important;
    margin: 0.25rem !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    box-shadow: none !important;
}

button[onclick*="difficulty"]:hover, .difficulty-btn:hover {
    background: rgba(127, 29, 29, 0.2) !important;
    border-color: rgba(239, 68, 68, 0.5) !important;
}

button[onclick*="difficulty"].selected, .difficulty-btn.selected {
    background: rgba(127, 29, 29, 0.4) !important;
    color: #f87171 !important;
    border-color: rgba(239, 68, 68, 0.7) !important;
}

/* Clean Close Button */
.modal-content .close {
    position: absolute !important;
    top: 16px !important;
    right: 16px !important;
    background: rgba(148, 163, 184, 0.1) !important;
    border: none !important;
    width: 32px !important;
    height: 32px !important;
    border-radius: 8px !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    color: #64748b !important;
    font-size: 18px !important;
}

.modal-content .close:hover {
    background: rgba(148, 163, 184, 0.2) !important;
    color: #475569 !important;
}

/* Compact Spacing */
.modal-content > * {
    margin-bottom: 1.25rem !important;
}

.modal-content > *:last-child {
    margin-bottom: 0 !important;
}

/* Remove all animations and glows */
* {
    animation: none !important;
}

.modal-content:hover {
    animation: none !important;
}

#caseModal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}

#caseModal.show {
    display: flex !important;
    justify-content: center;
    align-items: center;
}


.recording-controls {
  display: flex;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.recording-controls button {
  background-color: transparent;
  border: 1.5px solid #3b82f6; /* subtle blue border */
  color: #3b82f6;
  font-size: 1rem;
  padding: 0.5rem 1.2rem;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.3s ease, color 0.3s ease;
  box-shadow: none;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.recording-controls button:hover:not(:disabled) {
  background-color: #3b82f6;
  color: white;
  border-color: #3b82f6;
}

.recording-controls button:disabled {
  border-color: #a5b4fc;
  color: #a5b4fc;
  cursor: not-allowed;
}

#cq-speaking-submitBtn {
  background-color: transparent;
  border: 1.5px solid #10b981; /* subtle green border */
  color: #10b981;
  font-weight: 600;
  padding: 0.65rem 2rem;
  font-size: 1.1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s ease, color 0.3s ease;
  width: 100%;
  max-width: 320px;
  margin: 1rem auto 0 auto;
  display: block;
}

#cq-speaking-submitBtn:hover:not(:disabled) {
  background-color: #10b981;
  color: white;
  border-color: #10b981;
}

#cq-speaking-submitBtn:disabled {
  border-color: #a7f3d0;
  color: #a7f3d0;
  cursor: not-allowed;
}


.media-preview {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-top: 0.5rem;
}

.media-preview audio,
.media-preview video {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgb(0 0 0 / 0.15);
  max-width: 100%;
  outline: none;
}

.file-info {
    margin-top: 15px;
    text-align: center;
}

.file-info small {
    color: #666;
    font-style: italic;
    background: #f8f9fa;
    padding: 8px 12px;
    border-radius: 15px;
    display: inline-block;
}

/* Upload Prompt Modal Styles */
.upload-prompt-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1001;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.upload-prompt-modal.active {
    opacity: 1;
}

#pdfModal {
  width: 100vw !important;
  height: 100vh !important;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(8px);
  z-index: 10000;
  justify-content: center;
  align-items: center;
}

#pdfModal .modal-content {
  background: linear-gradient(to bottom right, rgba(15, 23, 42, 0.95), rgba(2, 6, 23, 0.95));
  border: 2px solid rgba(239, 68, 68, 0.5);
  border-radius: 1.5rem;
  padding: 3rem;
  max-height: 90vh;
  overflow-y: auto;
  margin: auto;
  backdrop-filter: blur(24px);
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  width: 95vw !important;
  max-width: 1200px !important;
  min-width: 300px;
  box-sizing: border-box !important;
}

/* ... rest of upload modal CSS from the artifact */

#cq-speaking-submitBtn {
  background-color: #4a90e2; /* pastel blue */
  color: white;
  font-weight: 600;
  padding: 0.65rem 2.2rem;
  font-size: 1.15rem;
  border-radius: 10px;
  border: none;
  cursor: pointer;
  transition: background-color 0.25s ease;
  width: 100%;
  max-width: 360px;
  display: block;
  margin: 1.5rem auto 0 auto;
  box-shadow: none;
}

#cq-speaking-submitBtn:hover:not(:disabled) {
  background-color: #357abd; /* slightly deeper blue */
}

#cq-speaking-submitBtn:disabled {
  background-color: #a3c2f2; /* lighter pastel blue */
  cursor: not-allowed;
  color: #e0e6f7;
}

  .section-header-background {
    width: 90vw;
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(20px);
    padding: 3rem 2rem;
    margin-bottom: 0;
    position: relative;
    z-index: 1;
    text-align: center;
  }

  .section-header-background.glassmorphic {
    width: calc(100vw - 120px);
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(30px);
    -webkit-backdrop-filter: blur(30px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 24px;
    padding: 3rem 2rem;
    height: 50vh;
    margin: 2rem;
    margin-left: 90px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
    border-bottom: none;
  }


  #trainingModal {
    background: rgba(0, 0, 0, 0.5) !important; /* Darker overlay */
    backdrop-filter: blur(20px) !important;
}

#trainingModal .modal-content {
    background: rgba(255, 255, 255, 0.15) !important; /* Lighter glass */
    backdrop-filter: blur(45px) !important;
    -webkit-backdrop-filter: blur(25px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important; /* Brighter border */
    border-radius: 24px !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08) !important; /* Lighter shadow */
}

#pdfModal {
    background: rgba(0, 0, 0, 0.8) !important;
    backdrop-filter: blur(8px) !important;
    -webkit-backdrop-filter: blur(8px) !important;
    z-index: 1000;
}
.glass-modal {
    width: 95vw !important;
    max-width: 1200px !important;
    min-width: 300px;
    background: linear-gradient(to bottom right, rgba(15, 23, 42, 0.95), rgba(2, 6, 23, 0.95)) !important;
    backdrop-filter: blur(24px) !important;
    -webkit-backdrop-filter: blur(24px) !important;
    border: 2px solid rgba(239, 68, 68, 0.5) !important;
    border-radius: 1.5rem !important;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5) !important;
}

/* Dark theme styles for Train Your Model modal */
#pdfModal .modal-content .close {
    color: #94a3b8 !important;
    background: none !important;
    border: none !important;
}

#pdfModal .modal-content .close:hover {
    color: #fff !important;
}

#pdfModal .training-section {
    margin-bottom: 2.5rem;
    width: 100% !important;
}

#pdfModal .training-section h3 {
    width: 100% !important;
}

#pdfModal .training-section h3 {
    color: #e2e8f0 !important;
    font-weight: 900 !important;
    font-size: 1.125rem !important;
    margin-bottom: 1rem !important;
}

#pdfModal #dropZone {
    border: 2px dashed rgba(71, 85, 105, 0.6) !important;
    background: rgba(30, 41, 59, 0.3) !important;
    border-radius: 0.75rem !important;
    padding: 2rem !important;
    text-align: center !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal #dropZone:hover {
    border-color: rgba(239, 68, 68, 0.5) !important;
    background: rgba(30, 41, 59, 0.5) !important;
}

#pdfModal .drop-zone-text {
    color: #cbd5e1 !important;
    font-weight: 600 !important;
    margin-bottom: 0.5rem !important;
}

#pdfModal .drop-zone-subtext {
    color: #94a3b8 !important;
    font-size: 0.875rem !important;
}

#pdfModal button[onclick="addQuestionInput()"] {
    background: rgba(30, 41, 59, 0.5) !important;
    color: #cbd5e1 !important;
    border: 2px solid rgba(71, 85, 105, 0.5) !important;
    border-radius: 0.75rem !important;
    padding: 0.75rem 1.5rem !important;
    font-weight: 600 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    margin-top: 1rem !important;
}

#pdfModal button[onclick="addQuestionInput()"]:hover {
    background: rgba(239, 68, 68, 0.2) !important;
    border-color: rgba(239, 68, 68, 0.5) !important;
    color: #fff !important;
}

#pdfModal button[onclick="usePDFForTraining()"] {
    background: linear-gradient(to right, #dc2626, #f97316) !important;
    color: #fff !important;
    border: none !important;
    border-radius: 0.75rem !important;
    padding: 0.75rem 1.5rem !important;
    font-weight: 700 !important;
    font-size: 1rem !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    width: 100% !important;
    margin-top: 2rem !important;
}

#pdfModal button[onclick="usePDFForTraining()"]:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(220, 38, 38, 0.4);
}

#pdfModal input[type="text"],
#pdfModal textarea,
#pdfModal select {
    background: rgba(30, 41, 59, 0.5) !important;
    border: 2px solid rgba(71, 85, 105, 0.5) !important;
    border-radius: 0.75rem !important;
    padding: 0.75rem 1rem !important;
    color: #fff !important;
    font-weight: 600 !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal input[type="text"]:focus,
#pdfModal textarea:focus,
#pdfModal select:focus {
    outline: none !important;
    border-color: rgba(239, 68, 68, 0.8) !important;
}

#pdfModal input[type="text"]::placeholder,
#pdfModal textarea::placeholder {
    color: #94a3b8 !important;
}

#pdfModal label {
    color: #e2e8f0 !important;
    font-weight: 600 !important;
    margin-bottom: 0.5rem !important;
    display: block !important;
}

#pdfModal select option {
    background: #1e293b !important;
    color: #fff !important;
}

#pdfModal #competitionSelect:hover {
    border-color: rgba(239, 68, 68, 0.5) !important;
}

#pdfModal #competitionSelect:focus {
    outline: none !important;
    border-color: rgba(239, 68, 68, 0.8) !important;
}

/* Competition select and delete button container */
.competition-select-container {
    display: flex !important;
    align-items: stretch !important;
    gap: 0 !important;
    width: 100% !important;
    margin-bottom: 20px !important;
}

/* Competition select and delete button - seamless connection */
.competition-select-container {
    display: flex !important;
    gap: 0 !important;
    align-items: stretch !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal #competitionSelect {
    font-size: 16px !important;
    font-family: inherit !important;
    font-weight: 500 !important;
    color: #ffffff !important;
    background-color: #1e293b !important;
    padding: 0 12px !important;
    line-height: 48px !important;
}

#pdfModal #competitionSelect,
#pdfModal #competitionSelect * {
    color: #ffffff !important;
}

#pdfModal #competitionSelect option {
    color: #ffffff !important;
    background: #1e293b !important;
}

/* Force text visibility */
#pdfModal #competitionSelect {
    -webkit-text-fill-color: #ffffff !important;
    text-fill-color: #ffffff !important;
}

#pdfModal .delete-training-btn {
    height: 48px !important;
    min-height: 48px !important;
    max-height: 48px !important;
    border-radius: 0.75rem !important;  /* Changed from "0 0.75rem 0.75rem 0" */
    border-left: none !important;
    border-top: 2px solid rgba(71, 85, 105, 0.5) !important;
    border-bottom: 2px solid rgba(71, 85, 105, 0.5) !important;
    border-right: 2px solid rgba(239, 68, 68, 0.5) !important;
    margin: 0 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    line-height: 1 !important;
    vertical-align: top !important;
    box-sizing: border-box !important;
}

/* Styles for dynamically created question inputs */
#pdfModal .question-input-group {
    background: rgba(30, 41, 59, 0.3) !important;
    border: 2px solid rgba(71, 85, 105, 0.3) !important;
    border-radius: 0.75rem !important;
    padding: 1.5rem !important;
    margin-bottom: 1.5rem !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal .question-header h4 {
    color: #fff !important;
    font-weight: 700 !important;
    font-size: 1.25rem !important;
    margin-bottom: 1rem !important;
}

#pdfModal .form-group {
    margin-bottom: 1rem !important;
    width: 100% !important;
}

#pdfModal .form-group input[type="text"],
#pdfModal .form-group textarea,
#pdfModal .form-group select {
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal .form-group label {
    color: #e2e8f0 !important;
    font-weight: 600 !important;
    font-size: 0.875rem !important;
    margin-bottom: 0.5rem !important;
    display: block !important;
}

#pdfModal .options-grid {
    display: grid !important;
    grid-template-columns: repeat(2, 1fr) !important;
    gap: 1rem !important;
    margin-bottom: 1rem !important;
    width: 100% !important;
}

#pdfModal .options-grid .form-group {
    width: 100% !important;
    margin-bottom: 0 !important;
}

#pdfModal .options-grid .form-group input {
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal .correct-answer-container {
    margin-top: 1rem !important;
    width: 100% !important;
}

#pdfModal .correct-answer-container select {
    width: 100% !important;
    box-sizing: border-box !important;
}

#pdfModal .correct-answer-container label {
    color: #e2e8f0 !important;
    font-weight: 600 !important;
    font-size: 0.875rem !important;
    margin-bottom: 0.5rem !important;
    display: block !important;
}

#pdfModal .remove-btn {
    background: rgba(239, 68, 68, 0.2) !important;
    border: 2px solid rgba(239, 68, 68, 0.5) !important;
    border-radius: 0.5rem !important;
    color: #f87171 !important;
    padding: 0.5rem !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
}

#pdfModal .remove-btn:hover {
    background: rgba(239, 68, 68, 0.4) !important;
    border-color: rgba(239, 68, 68, 0.8) !important;
    color: #fff !important;
}

#pdfModal .remove-btn svg {
    width: 16px !important;
    height: 16px !important;
}

#pdfModal #manualQuestionsContainer {
    width: 100% !important;
    box-sizing: border-box !important;
}

.competency-option {
    appearance: auto;
    width: 16px;
    height: 16px;
    margin-right: 8px;
    display: inline-block;
}


/* ===== FIXED CHECKBOX STYLES ===== */
input[type="checkbox"].competency-option {
    all: revert !important;
    -webkit-appearance: checkbox !important;
    -moz-appearance: checkbox !important;
    appearance: checkbox !important;
    width: 18px !important;
    height: 18px !important;
    margin: 0 8px 0 0 !important;
    padding: 0 !important;
    background: white !important;
    cursor: pointer !important;
    display: inline-block !important;
    position: relative !important;
    vertical-align: middle !important;
}

input[type="checkbox"].competency-option:checked {
    background-color: #007bff !important;
    border-color: #007bff !important;
}

input[type="checkbox"].competency-option:checked::before {
    content: "âœ“" !important;
    color: white !important;
    position: absolute !important;
    left: 3px !important;
    top: -1px !important;
    font-size: 14px !important;
    font-weight: bold !important;
}

.checkbox-group label {
    display: flex !important;
    align-items: center !important;
    margin: 8px 0 !important;
    padding: 8px 12px !important;
    cursor: pointer !important;
    border-radius: 4px !important;
    transition: background-color 0.2s ease !important;
}



/* Fix for the simulate checkbox */
#simulate {
    all: revert !important;
    -webkit-appearance: checkbox !important;
    -moz-appearance: checkbox !important;
    appearance: checkbox !important;
    width: 18px !important;
    height: 18px !important;
    margin: 0 8px 0 0 !important;
    padding: 0 !important;

    background: white !important;
    cursor: pointer !important;
    display: inline-block !important;
    position: relative !important;
    vertical-align: middle !important;
}

#simulate:checked {
    background-color: #007bff !important;
    border-color: #007bff !important;
}

#simulate:checked::before {
    content: "âœ“" !important;
    color: white !important;
    position: absolute !important;
    left: 3px !important;
    top: -1px !important;
    font-size: 14px !important;
    font-weight: bold !important;
}

.checkbox-row {
    display: flex !important;
    align-items: center !important;
    margin: 8px 0 !important;
    padding: 8px 12px !important;
    cursor: pointer !important;
    border-radius: 4px !important;
}

/* Update the speaking modal content width */
#speakingModal .modal-content {
    width: 925px;
    max-width: 925px;
    /* Keep your existing styles, just update width */
}

/* Add styles for the generate button */
button[onclick="generateQuestions()"] {
    padding: 0.75rem 1.5rem;
    background: linear-gradient(to right, #dc2626, #f97316) !important;
    color: #fff !important;
    border: none !important;
    border-radius: 0.75rem;
    font-size: 1rem;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    cursor: pointer;
    margin-top: 1rem;
    width: 100%;
    transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
}

button[onclick="generateQuestions()"]:hover {
    transform: scale(1.02);
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
    background: linear-gradient(to right, #ea580c, #fb923c) !important;
}

.generate-btn {
    padding: 12px 24px;
    background: #e3f2fd;
    color: #1565c0;
    border: 2px solid #90caf9;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    margin-top: 15px;
    width: 100%;
    transition: all 0.2s;
}

.generate-btn:hover {
   background: #bbdefb;
    border-color: #64b5f6;
}
/* Case Modal Styling */
#caseModal {
    display: none;
    position: fixed;
    z-index: 9999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;

    background-color: rgba(0, 0, 0, 0.6); /* Darker background */
    backdrop-filter: blur(20px); /* Add blur effect */
}

#caseModal .modal-content {
    background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.95)) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border: 2px solid rgba(251, 146, 60, 0.5) !important; /* Orange border */
    border-radius: 24px !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 40px rgba(251, 146, 60, 0.2) !important;
    width: 95vw !important;
    max-width: 800px !important;
    min-width: 300px;
    max-height: 90vh !important;
    margin: 5% auto !important;
    padding: 0 !important;
    color: #fff !important;
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
}

#caseModal .modal-content > * {
    padding: 1rem;
}

#caseModal .modal-content > h2 {
    padding: 1rem;
    margin: 0;
    border-bottom: 1px solid rgba(251, 146, 60, 0.2);
}

#caseModal .modal-content > .close {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem;
    z-index: 10;
    padding: 0;
    width: 40px;
    height: 40px;
}

/* Scrollable content area */
#caseModal #casePromptSection,
#caseModal #caseResultSection {
    overflow-y: auto;
    overflow-x: hidden;
    flex: 1;
    padding: 1rem;
    max-height: calc(90vh - 100px);
}

/* Improve spacing in prompt section */
#caseModal #casePromptSection > * {
    margin-bottom: 1rem;
}

#caseModal #casePromptSection > *:last-child {
    margin-bottom: 0;
}

/* Improve spacing in result section */
#caseModal #caseResultSection > * {
    margin-bottom: 1rem;
}

#caseModal #caseResultSection > *:last-child {
    margin-bottom: 0;
}

/* Custom scrollbar */
#caseModal #casePromptSection::-webkit-scrollbar,
#caseModal #caseResultSection::-webkit-scrollbar {
    width: 8px;
}

#caseModal #casePromptSection::-webkit-scrollbar-track,
#caseModal #caseResultSection::-webkit-scrollbar-track {
    background: rgba(15, 23, 42, 0.5);
    border-radius: 4px;
}

#caseModal #casePromptSection::-webkit-scrollbar-thumb,
#caseModal #caseResultSection::-webkit-scrollbar-thumb {
    background: rgba(251, 146, 60, 0.5);
    border-radius: 4px;
}

#caseModal #casePromptSection::-webkit-scrollbar-thumb:hover,
#caseModal #caseResultSection::-webkit-scrollbar-thumb:hover {
    background: rgba(251, 146, 60, 0.7);
}

/* Competency Grid - Stacked Vertically */
#caseModal .competency-grid {
    display: flex;
    flex-direction: column; /* Stack vertically */
    flex-wrap: nowrap; /* Prevent wrapping */

    align-items: stretch; /* Make items fill width */
    margin: 0.75rem 0;
    width: 100%;
}

#caseModal .competency-grid label {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    margin: 0;
    padding: 8px 12px;
    border-radius: 8px;
    background: transparent;
    border: none;
    color: #e2e8f0 !important;
    transition: all 0.3s ease;
    cursor: pointer;
    font-size: 15px;
    box-sizing: border-box;
}

#caseModal .competency-grid input[type="checkbox"]:checked + label,
#caseModal .competency-grid label:has(input[type="checkbox"]:checked) {
    background: rgba(59, 130, 246, 0.3);
    border-color: rgba(59, 130, 246, 0.6);
    color: #fff !important;
}

#caseModal .competency-grid input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #3b82f6;
}

/* Case Modal Text Colors */
#caseModal h2 {
    color: #fff !important;
    font-weight: 900;
    background: linear-gradient(to right, #fb923c, #fbbf24);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
}

#caseModal p, #caseModal label, #caseModal strong {
    color: #e2e8f0 !important;
}

#caseModal .close {
    color: #fb923c !important;
    background: rgba(30, 41, 59, 0.5) !important;
    border: 2px solid rgba(71, 85, 105, 0.5) !important;
}

#caseModal .close:hover {
    background: rgba(251, 146, 60, 0.2) !important;
    border-color: rgba(251, 146, 60, 0.5) !important;
    color: #ea580c !important;
}

/* Case Modal Select/Dropdown */
#caseModal select {
    background: rgba(30, 41, 59, 0.8) !important;
    border: 1px solid rgba(71, 85, 105, 0.5) !important;
    color: #e2e8f0 !important;
    border-radius: 8px !important;
    padding: 10px 16px !important;
}

#caseModal select:hover, #caseModal select:focus {
    border-color: rgba(251, 146, 60, 0.6) !important;
    color: #fff !important;
}

/* Case Modal Difficulty Buttons */
#caseModal .difficulty-options {
    display: flex;
    gap: 10px;
    margin: 0.75rem 0;
}

#caseModal .difficulty-btn {
    flex: 1;
    padding: 10px 16px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid rgba(71, 85, 105, 0.5);
    background: rgba(30, 41, 59, 0.6);
    color: #fff;
}

#caseModal .difficulty-btn:hover {
    background: rgba(59, 130, 246, 0.3);
    border-color: rgba(59, 130, 246, 0.6);
}

#caseModal .difficulty-btn.selected {
    background: rgba(59, 130, 246, 0.5);
    border-color: rgba(59, 130, 246, 0.8);
    color: #fff;
    box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
}

/* Case Modal Generate Button */
#caseModal .generate-btn {
    background: linear-gradient(to right, #dc2626, #f97316, #fbbf24) !important;
    color: #fff !important;
    border: none !important;
    padding: 12px 24px !important;
    border-radius: 12px !important;
    font-weight: 900 !important;
    font-size: 15px !important;
    text-transform: uppercase !important;
    letter-spacing: 0.05em !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3) !important;
    width: 100% !important;
    margin-top: 0.75rem !important;
}

#caseModal .generate-btn:hover {
    background: linear-gradient(to right, #ea580c, #fb923c, #fde047) !important;
    box-shadow: 0 8px 20px rgba(220, 38, 38, 0.4) !important;
    transform: translateY(-2px) !important;
}

#caseModal .generate-btn:active {
    transform: translateY(0) !important;
}

 
  

</style>
</head>
<body>
  <div class="min-h-screen text-white overflow-hidden">
    <!-- Galaxy Background -->
    <div class="galaxy-background">
      <div class="galaxy-gradient"></div>
      <div class="stars-container" id="starsContainer"></div>
      <div class="nebula nebula-1"></div>
      <div class="nebula nebula-2"></div>
      <div class="nebula nebula-3"></div>
    </div>

    <!-- Header -->
    <div class="blaze-header">
      <div class="blaze-header-content">
        <div class="header-left">
          <button class="hamburger-menu" id="hamburgerMenu" onclick="toggleMobileNav()" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <h1 class="blaze-logo">FBLAZE</h1>
        </div>
        <h1 class="blaze-logo desktop-logo">FBLAZE</h1>
        <!-- Nav Links -->
        <nav class="blaze-nav" id="mainNav">
          <button class="mobile-nav-close" onclick="toggleMobileNav()" aria-label="Close menu">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
          <a href="home3.html" class="nav-link">Home</a>
          <a href="javascript:void(0)" onclick="toggleNotificationPanel()" class="nav-link">
            Notifications
            <span id="notificationBadge" class="notification-badge" style="display: none;">0</span>
          </a>
          <a href="practice.html" class="nav-link">Practice</a>
          <a href="Forum/forum.html" class="nav-link">Forum</a>
          <a href="Calendar/calendar1.html" class="nav-link">Calendar</a>
          <a href="mentor1.html" class="nav-link" id="mentorNavLink" style="display: none;">Mentor</a>
        </nav>
      </div>
      
      <!-- Sub-Navigation Tabs -->
      <div class="create-sub-nav">
        <div class="create-sub-nav-content">
          <a href="Competitions/competition1.html" class="create-sub-nav-link">Your Journey</a>
          <a href="create1.html" class="create-sub-nav-link active">Practice Hub</a>
          <a href="statistics1.html" class="create-sub-nav-link">Your Statistics</a>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="create-container">
      <!-- Hero Title -->
      <div class="create-hero">
        <h1 class="create-hero-title">
          <span class="create-hero-gradient">Create and Learn!</span>
        </h1>
      </div>

      <!-- Search Bar -->
      <div class="create-search-section">
        <div class="create-search-container">
          <input 
            type="text" 
            id="createSearch"
            placeholder="Search practice materials, topics and more..." 
            class="create-search-input"
          />
        </div>
        <div class="create-search-actions">
          <button class="train-model-btn" id="openModalBtn" onclick="openTrainingModal()">Train Your Model â†’</button>
        </div>
        
        <!-- Tabs -->
        <div class="create-tabs">
          <button class="create-tab" onclick="window.location.href='practice.html'">Resources</button>
          <button class="create-tab active">Create</button>
        </div>
      </div>

      <!-- Create Your Practice Card -->
      <div class="create-practice-card">
        <h3 class="create-practice-title">Create Your Practice</h3>
        <p class="create-practice-desc">We'll generate an exam based on what you want to practice</p>
        
        <div class="create-practice-buttons">
          <button class="create-type-btn" onclick="openWrittenModal()">Written</button>
          <button class="create-type-btn" onclick="openSpeakingModal()">Speaking</button>
          <button class="create-type-btn" onclick="openCaseModal()">Case</button>
        </div>
      </div>

      <!-- Performance Breakdown Section -->
      <div class="performance-breakdown-section">
        <h2 class="performance-breakdown-title">Performance Breakdown</h2>
        
        <div class="performance-cards-container" id="performanceCardsContainer">
          <!-- Performance cards will be dynamically loaded here by Firebase -->
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile Navigation Toggle - Must be defined early -->
  <script>
    // Mobile Navigation Toggle
    window.toggleMobileNav = function() {
      console.log('toggleMobileNav called');
      const nav = document.getElementById('mainNav');
      const hamburger = document.getElementById('hamburgerMenu');
      
      console.log('Nav element:', nav);
      console.log('Hamburger element:', hamburger);
      
      if (nav && hamburger) {
        nav.classList.toggle('active');
        hamburger.classList.toggle('active');
        document.body.style.overflow = nav.classList.contains('active') ? 'hidden' : '';
        console.log('Nav active class:', nav.classList.contains('active'));
      } else {
        console.error('Nav or hamburger not found!');
      }
    };
  </script>

  <!-- Notification Panel -->
  <div id="notificationPanel" class="notification-panel hidden">
    <div class="notification-panel-header">
      <h3 class="notification-panel-title">NOTIFICATIONS</h3>
      <button onclick="toggleNotificationPanel()" class="close-notifications">âœ•</button>
    </div>
    <div id="notificationList" class="notification-list"></div>
  </div>
  <!-- Written Practice Modal -->
<div id="writtenModal" class="written-practice-modal" style="display: none;">
  <div class="written-modal-backdrop" onclick="closeWrittenModal()"></div>
  <div class="written-modal-content">
    <!-- Close Button -->
    <button class="written-modal-close" onclick="closeWrittenModal()">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>

    <!-- Title -->
    <h2 class="written-modal-title">Written Practice Setup</h2>

    <!-- Time Selection -->
    <div class="written-modal-section">
      <label class="written-modal-label">Time:</label>
      <div class="written-time-options">
        <button class="time-btn" onclick="selectTime(this)" data-time="15">15 min</button>
        <button class="time-btn" onclick="selectTime(this)" data-time="30">30 min</button>
        <button class="time-btn" onclick="selectTime(this)" data-time="50">50 min</button>
      </div>
    </div>

    <!-- Competition Selection -->
    <div class="written-modal-section">
      <label class="written-modal-label" for="competitionSelectWritten">Competition:</label>
      <select id="competitionSelectWritten" class="written-competition-select">
        <option value="">Select competition...</option>
      </select>
    </div>

    <!-- Competencies Tested -->
    <div class="written-modal-section">
      <label class="written-modal-label">Competencies Tested</label>
      <div class="written-checkbox-group">
        <!-- Competency checkboxes will be inserted here -->
      </div>
      <button type="button" class="written-select-all-btn" onclick="selectAllCompetencies()">Select All</button>
    </div>

    <!-- Difficulty Selection -->
    <div class="written-modal-section">
      <label class="written-modal-label">Difficulty:</label>
      <div class="difficulty-options">
        <button class="difficulty-btn" onclick="selectDifficulty(this)">Easy</button>
        <button class="difficulty-btn" onclick="selectDifficulty(this)">Medium</button>
        <button class="difficulty-btn" onclick="selectDifficulty(this)">Hard</button>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="written-modal-actions">
      <button class="written-modal-cancel-btn" onclick="closeWrittenModal()">Cancel</button>
      <button class="written-modal-start-btn start-btn" onclick="generateQuizQuestions()">Customized Test</button>
      <button class="written-modal-smart-btn personalized-btn" onclick="generatePersonalizedTest()">SMART Test</button>
    </div>
  </div>
</div>

<div id="speakingModal" class="speaking-practice-modal" style="display: none;">
  <div class="speaking-modal-backdrop" onclick="closeModal('speakingModal')"></div>
  <div class="speaking-modal-content">
    <!-- Close Button -->
    <button class="speaking-modal-close" onclick="closeModal('speakingModal')">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>

    <!-- Title -->
    <h2 class="speaking-modal-title">Speaking Practice</h2>
      <!-- Add this somewhere in your speaking modal -->
      <div>
        <label for="competitionSelectSpeaking">Select Competition:</label>
        <select id="competitionSelectSpeaking">
            <option value="">Choose a competition...</option>
        </select>
    </div>
  
      <div class="modal-section">
        <label for="speechInput"><strong>Paste Your Speech</strong></label>
        <textarea id="speechInput" placeholder="Paste your speech here..." rows="6"></textarea>
         <button onclick="generateQuestions()">Generate Questions</button>
      </div>
  
     
  
      <div class="modal-section hidden" id="questionArea">
        <h3>Generated Questions</h3>
        <div id="questionList" class="question-card-list"></div>
  
        <label><strong>Record your responses:</strong></label>
       <div class="cq-speaking-section">
    <button id="recordMyAnswer" class="record-my-answer-btn" onclick="openCameraModal()">
        ðŸŽ¥ Record My Answer
    </button>
</div>
  
      </div>
    </div>
  </div>
  
  <!-- CASE MODAL -->
  <div id="caseModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeModal('caseModal')"></span>
      <h2>Case Practice</h2>

      <!-- Add this somewhere in your case modal -->
<div style="margin-bottom: 1rem;">
        <label for="competitionSelectCase" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #e2e8f0;">Select Competition:</label>
        <select id="competitionSelectCase" style="
            padding: 8px 12px;
            font-size: 14px;
            font-family: inherit;
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 8px;
            background-color: rgba(30, 41, 59, 0.8);
            color: #e2e8f0;
            cursor: pointer;
            min-width: 200px;
            width: 100%;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 4 5%22><path fill=%22%23e2e8f0%22 d=%22M2 0L0 2h4zm0 5L0 3h4z%22/></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 32px;
        ">
            <option value="" style="background: rgba(30, 41, 59, 0.95); color: #e2e8f0;">Choose a competition...</option>
        </select>
    </div>
  
      <div id="casePromptSection">
        <p style="margin-bottom: 0.75rem;"><strong style="color: #e2e8f0;">Customize your Case Study with Competencies:</strong></p>
        <div class="competency-grid">
          <label><input type="checkbox" class="competency-option" /> Teamwork</label>
          <label><input type="checkbox" class="competency-option" /> Leadership</label>
          <label><input type="checkbox" class="competency-option" /> Innovation</label>
          <label><input type="checkbox" class="competency-option" /> Communication</label>
          <label><input type="checkbox" class="competency-option" /> Ethics</label>
        </div>
  
        <p style="margin-top: 1rem; margin-bottom: 0.75rem;"><strong style="color: #e2e8f0;">Select difficulty:</strong></p>
        <div class="difficulty-options">
          <button class="difficulty-btn" onclick="selectDifficulty(this, 'Easy')">EASY</button>
          <button class="difficulty-btn" onclick="selectDifficulty(this, 'Medium')">MEDIUM</button>
          <button class="difficulty-btn" onclick="selectDifficulty(this, 'Hard')">HARD</button>
        </div>
  
        <button class="generate-btn" onclick="generateCase()" style="margin-top: 1rem;">Generate Case</button>
      </div>
  
      <div id="caseResultSection" style="display: none;">
         <div style="background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.8)); padding: 1rem; border-radius: 12px; border: 1px solid rgba(251, 146, 60, 0.3); margin-bottom: 1rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
        <h3 style="color: #fff; margin: 0 0 0.75rem 0; font-weight: 900; font-size: 1.1rem; background: linear-gradient(to right, #fb923c, #fbbf24); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">ðŸ§  Your Case Prompt</h3>
        <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 0.75rem;">
          <p style="color: #e2e8f0; margin: 0; padding: 0.4rem 0; border-bottom: 1px solid rgba(71, 85, 105, 0.3);"><strong style="color: #fb923c; font-size: 0.9rem;">Competition:</strong> <span id="caseCompetition" style="color: #fff; font-weight: 600; margin-left: 0.5rem;"></span></p>
          <p style="color: #e2e8f0; margin: 0; padding: 0.4rem 0; border-bottom: 1px solid rgba(71, 85, 105, 0.3);"><strong style="color: #fb923c; font-size: 0.9rem;">Difficulty:</strong> <span id="caseDifficulty" style="color: #fff; font-weight: 600; text-transform: uppercase; margin-left: 0.5rem;"></span></p>
          <p style="color: #e2e8f0; margin: 0; padding: 0.4rem 0;"><strong style="color: #fb923c; font-size: 0.9rem;">Focus Competencies:</strong> <span id="caseCompetencies" style="color: #fff; font-weight: 500; margin-left: 0.5rem;"></span></p>
        </div>
        <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 2px solid rgba(251, 146, 60, 0.3);">
          <p style="margin: 0; color: #cbd5e1; line-height: 1.6; white-space: pre-wrap; font-size: 13px;" id="caseText">
            <!-- Dynamic case content will appear here -->
        </p>
        </div>
    </div>

  
        <div id="caseRecording" style="margin-top: 1rem; padding: 1rem; background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.6), rgba(15, 23, 42, 0.6)); border-radius: 12px; border: 1px solid rgba(251, 146, 60, 0.3);">
          <label style="color: #e2e8f0; display: block; margin-bottom: 0.75rem; font-size: 0.95rem; font-weight: 700;"><strong>ðŸŽ™ï¸ Record your response:</strong></label>
          <div style="display: flex; gap: 0.75rem;">
     <button onclick="openCasePracticeModal()" style="flex: 1; padding: 12px 20px; background: linear-gradient(to right, #dc2626, #f97316, #fbbf24); color: white; border: none; border-radius: 10px; font-size: 14px; font-weight: 900; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3); transition: all 0.3s ease;">
    ðŸŽ¥ RECORD YOUR ANSWER
</button>
            <button id="stopBtnCase" onclick="stopRecording('case')" style="display: none; padding: 12px 20px; background: rgba(30, 41, 59, 0.6); color: #fff; border: 1px solid rgba(71, 85, 105, 0.5); border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer;">â¹ï¸ Stop</button>
          </div>
  
          <div class="media-preview">
            <audio id="audioPlaybackCase" controls style="display: none; margin-top: 1rem;"></audio>
            <video id="videoPreviewCase" style="display: none; margin-top: 1rem; max-width: 100%; border-radius: 10px;" autoplay playsinline muted></video>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  
  <div id="quizModal" style="display: none;" class="practice-quiz-fullscreen">
    <!-- Galaxy Background -->
    <div class="practice-quiz-galaxy-bg">
      <div class="practice-quiz-galaxy-gradient"></div>
      <div class="practice-quiz-stars-container" id="quizStarsContainer"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-1"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-2"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-3"></div>
    </div>

    <!-- Top Bar -->
    <div class="practice-quiz-topbar">
      <div class="practice-quiz-topbar-content">
        <div>
          <h1 id="quizTitle" class="practice-quiz-topbar-title">Easy Written Practice</h1>
          <p class="practice-quiz-topbar-subtitle">
            <span id="quizProgress">Question 1 of 14</span>
          </p>
        </div>
        
        <div class="practice-quiz-topbar-right">
          <div class="practice-quiz-timer-section">
            <p class="practice-quiz-timer-label">Time Remaining</p>
            <p id="quizTimer" class="practice-quiz-timer-value">14:53</p>
          </div>
          
          <button class="practice-quiz-close-btn" onclick="closeQuizModal()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="practice-quiz-main">
      <!-- Competency Badge -->
      <div class="practice-quiz-competency-badge">
        <span id="questionCompetency" class="practice-quiz-competency-text">Business Communication</span>
      </div>

      <!-- Question -->
      <div class="practice-quiz-question-section">
        <h2 id="questionText" class="practice-quiz-question">Loading question...</h2>
        <p class="practice-quiz-question-hint">Select the best answer from the options below</p>
      </div>

      <!-- Answer Options -->
      <div id="optionsContainer" class="practice-quiz-options">
        <!-- Options will be populated dynamically -->
      </div>

      <!-- Progress Section -->
      <div class="practice-quiz-progress-section">
        <div class="practice-quiz-progress-header">
          <p class="practice-quiz-progress-label">Overall Progress</p>
          <p class="practice-quiz-progress-value"><span id="progressPercent">0</span>/100</p>
        </div>
        <div class="practice-quiz-progress-bar">
          <div class="practice-quiz-progress-fill" id="progressFill"></div>
        </div>
      </div>

      <!-- Navigation Buttons -->
      <div class="practice-quiz-actions">
        <button id="prevBtn" class="practice-quiz-prev-btn" onclick="previousQuestion()" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
          Previous Question
        </button>
        <button id="nextBtn" class="practice-quiz-next-btn" onclick="nextQuestion()">Next Question</button>
        <button id="submitBtn" class="practice-quiz-submit-btn" onclick="submitQuiz()" style="display: none;">Submit Quiz</button>
      </div>
    </div>
  </div>



  <!-- Training Modal -->
<div id="pdfModal" style="display: none;">
        <div class="modal-content glass-modal">
            <span class="close"></span>
           <h2 style="
            color: #fff;
            margin: 0 0 2.5rem 0;
            font-size: 2.25rem;
            font-weight: 900;
            text-align: center;
        ">Train Your Model</h2>
             <div class="competition-select-container" style="margin-bottom: 20px; display: flex; flex-direction: column; gap: 0.5rem; width: 100%; box-sizing: border-box;">
        <label for="competitionSelect" style="color: #e2e8f0; font-weight: 600; font-size: 0.875rem; margin-bottom: 0.5rem; display: block; z-index: 1; position: relative;">Select competition:</label>
        <div style="display: flex; gap: 0; align-items: stretch; width: 100%;">
        <select id="competitionSelect" required style="
           padding: 12px 40px 12px 20px;
  font-size: 16px;
  font-family: inherit;
  border: 2px solid rgba(71, 85, 105, 0.5);
  border-right: none;
  border-radius: 0.75rem 0 0 0.75rem;
  background: rgba(30, 41, 59, 0.5);
  backdrop-filter: blur(10px);
  color: #ffffff !important;
  -webkit-text-fill-color: #ffffff !important;
  font-weight: 700;
  cursor: pointer;
  flex: 1;
  appearance: none;
  z-index: 100 !important;
  position: relative !important;
  background-repeat: no-repeat;
   background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 4 5%22><path fill=%22%23cbd5e1%22 d=%22M2 0L0 2h4zm0 5L0 3h4z%22/></svg>');
  background-position: right 0.75rem center;
  background-size: 12px;
  padding-right: 2.5rem;
  transition: all 0.3s ease;
  box-sizing: border-box;
  height: 48px;
  min-height: 48px;
  max-height: 48px;
  margin: 0;
  outline: none;
  z-index: 1;
  position: relative;
        ">
            <option value="">Select competition...</option>
        </select>
        <button onclick="clearTrainingContext()" class="delete-training-btn" style="flex-shrink: 0; height: 48px; min-height: 48px; max-height: 48px; padding: 12px 20px; white-space: nowrap; border-radius: 0 0.75rem 0.75rem 0; border-left: none; border-top: 2px solid rgba(71, 85, 105, 0.5); border-bottom: 2px solid rgba(71, 85, 105, 0.5); border-right: 2px solid rgba(239, 68, 68, 0.5); margin: 0; outline: none; box-sizing: border-box;">
    Delete Training Data
</button>
        </div>
    </div>

    <div class="training-section">
      <h3>Upload your Materials (Optional)</h3>
      <div id="dropZone">
          <div class="drop-zone-content">
              <div class="drop-zone-icon" style="display: none;"></div>
              <div class="drop-zone-text">Drag & Drop PDF Here or Click to Upload</div>
              <div class="drop-zone-subtext">Supports PDF files up to 10MB</div>
          </div>
      </div>
      <div id="fileName" style="display:none;"></div>
      <!-- ADD THIS LINE -->
      <input type="file" id="multiFileInput" accept=".pdf" style="display: none;">
  </div>

            <!-- <div style="margin-bottom: 15px;">
   <label for="competitionSelect" style="display: block; margin-bottom: 5px; font-weight: normal;"></label>
        <select id="competitionSelect" required style="
           padding: 12px 40px 12px 20px;
  font-size: 16px;
  font-family: inherit;
  border: 1px solid rgba(79, 172, 254, 0.3);
  border-radius: 50px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  color: #4facfe;
  cursor: pointer;
  min-width: 250px;

  appearance: none;
  background-repeat: no-repeat;
   background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 4 5%22><path fill=%22%231976d2%22 d=%22M2 0L0 2h4zm0 5L0 3h4z%22/></svg>');
  background-position: right 16px center;
  background-size: 16px;
  transition: all 0.3s ease;
  box-shadow: 0 4px 20px rgba(79, 172, 254, 0.1);
  margin-left: 25vw;
  display: inline-block;
        ">
            <option value="">Select competition...</option>
        </select>
    </div> -->
            
            <div class="training-section">
                <h3>Add Your Own Questions</h3>
                <div id="manualQuestionsContainer">
                    <!-- Questions will be added here -->
                </div>
                <button onclick="addQuestionInput()" style="background: rgba(30, 41, 59, 0.5); color: #cbd5e1; border: 2px solid rgba(71, 85, 105, 0.5); border-radius: 0.75rem; padding: 0.75rem 1.5rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; margin-top: 1rem;">
                    <span>+</span>
                    Add Question
                </button>
            </div>
            
            <button onclick="usePDFForTraining()" style="background: linear-gradient(to right, #dc2626, #f97316); color: #fff; border: none; border-radius: 0.75rem; padding: 0.75rem 1.5rem; font-weight: 700; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; width: 100%; margin-top: 2rem;">
                Start Training Your Model
            </button>
        </div>
    </div>

    <button id="cq-speaking-downloadBtn" style=" display: none;
  background: linear-gradient(90deg, #aee7f5, #e0c3fc);
  color: #222;
  border: none;
  border-radius: 1.25rem;
  padding: 0.7rem 1.8rem;
  font-size: 1.06rem;
  font-weight: 600;
  box-shadow: 0 2px 8px rgba(60,60,120,0.09);
  cursor: pointer;
  margin: 1rem 0 0 0;
  transition: background 0.18s, transform 0.12s, box-shadow 0.15s;
  outline: none;
">Download Your Response</button>


<div id="cq-written-loading" class="cq-written-loading" style="display: none;">
    <div class="gradient-balls">
        <div class="ball ball-1"></div>
        <div class="ball ball-2"></div>
        <div class="ball ball-3"></div>
        <div class="ball ball-4"></div>
    </div>
    <div class="cq-loading-container">
        <div class="cq-loading-spinner"></div>
        <div class="cq-loading-text">Generating Your Practice Test</div>
        <div class="cq-loading-subtext">AI is creating personalized questions based on your competencies...</div>
        <div class="cq-loading-progress">
            <div class="cq-loading-progress-bar" id="cq-loading-progress-bar"></div>
        </div>
    </div>
</div>



  
  
  <script src="https://cdn.jsdelivr.net/npm/meilisearch@latest/dist/bundles/meilisearch.umd.min.js"></script>

  
  <script>
    const firebaseConfig = {
    apiKey: "AIzaSyDGYp9sBwOWBdu9W46Q6XFp9zfLCrEsaO4",
    authDomain: "certquest-94959.firebaseapp.com",
    projectId: "certquest-94959",
    storageBucket: "certquest-94959.appspot.com",
    messagingSenderId: "323956529033",
    appId: "1:323956529033:web:e9c9c6a3c7668b8a72f358",
    measurementId: "G-F5JHTGGN6K"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  const auth = firebase.auth();

  

firebase.auth().onAuthStateChanged(async user => {
  if (!user) return;
  
  console.log('User authenticated, loading quiz data...');
  
  // Check mentor status and show/hide mentor link
  db.collection('users').doc(user.uid).get().then((doc) => {
    const mentorNavLink = document.getElementById('mentorNavLink');
    if (mentorNavLink) {
      const isMentor = doc.exists && doc.data().isMentor === true;
      mentorNavLink.style.display = isMentor ? 'block' : 'none';
    }
  }).catch((error) => {
    console.error('Error checking mentor status:', error);
  });
  
  // Load existing quiz results
  await reloadQuizCardsFromFirebase();
  
  // Load competition name
  await loadCompetitionName();
});

 let selectedFile = null;
  let selectedDifficulty = 'easy'; // Default difficulty
  let cameraStream = null;
let recordingTimer = null;
let recordingSeconds = 0;
let cameraEnabled = true;
let micEnabled = true;
let selectedUploadFile = null;
let isRecording = true;
let currentQuiz = null;
let hasResultsBeenShown = false;
let currentGeneratedQuestions = [];
// ADD THIS LINE AT THE TOP OF YOUR SCRIPT
let recordedChunks = [];
  let mediaRecorder = [];
    let mediaStream = [];


// Add these right after your Firebase init
window.addEventListener('dragover', function(e) {
  e.preventDefault();
  e.stopPropagation();
}, false);

window.addEventListener('drop', function(e) {
  e.preventDefault();
  e.stopPropagation();
}, false);

// Loading screen functions
function showLoading() {
    const loading = document.getElementById('cq-written-loading');
    if (loading) {
        loading.style.display = 'flex';
    }
}

function hideLoading() {
    const loading = document.getElementById('cq-written-loading');
    if (loading) {
        loading.style.display = 'none';
    }
}

function startLoadingAnimation() {
    const progressBar = document.getElementById('cq-loading-progress-bar');
    if (!progressBar) return;
    
    loadingProgress = 0;
    progressBar.style.width = '0%';
    
    if (loadingProgressInterval) {
        clearInterval(loadingProgressInterval);
    }
    
    loadingProgressInterval = setInterval(() => {
        loadingProgress += Math.random() * 10;
        if (loadingProgress > 90) loadingProgress = 90;
        progressBar.style.width = loadingProgress + '%';
    }, 300);
}

function completeLoadingAnimation() {
    const progressBar = document.getElementById('cq-loading-progress-bar');
    if (!progressBar) return;
    
    progressBar.style.width = '100%';
    
    if (loadingProgressInterval) {
        clearInterval(loadingProgressInterval);
        loadingProgressInterval = null;
    }
    
    setTimeout(() => {
        progressBar.style.width = '0%';
        loadingProgress = 0;
    }, 500);
}

// Add this to your main JavaScript file
function applySpeakingModalStyles() {
    const style = document.createElement('style');
    style.textContent = `
        /* Blur effect for speaking modal */
        #speakingModal {
            backdrop-filter: blur(20px) !important;
            background: rgba(0, 0, 0, 0.5) !important;
        }
        
        /* Modal width */
        #speakingModal .modal-content {
            width: 925px !important;
            max-width: 925px !important;
        }
        
        /* Generate button styling */
        button[onclick="generateQuestions()"] {
            padding: 12px 24px !important;
            background: #e3f2fd !important;
            color: #1565c0 !important;
            border: 2px solid #90caf9 !important;
            border-radius: 8px !important;
            font-size: 16px !important;
            font-weight: 500 !important;
            cursor: pointer !important;
            margin-top: 15px !important;
            width: 100% !important;
            transition: all 0.2s !important;
        }
        
        button[onclick="generateQuestions()"]:hover {
            background: #bbdefb !important;
            border-color: #64b5f6 !important;
        }
    `;
    document.head.appendChild(style);
    console.log('Speaking modal styles applied: blur + width + button styling');
}

// Call this when your app loads
applySpeakingModalStyles();


function fixCompetitionLoading() {
    window.loadCompetitions = async function() {
        console.log('ðŸ” loadCompetitions called');
        
        const select = document.getElementById('competitionSelectSpeaking');
        console.log('Select element:', select);
        
        if (!select) {
            console.error('âŒ Select element not found!');
            return;
        }
        
        try {
            const user = firebase.auth().currentUser;
            console.log('Current user:', user ? user.uid : 'No user');
            
            if (!user) {
                console.log('âš ï¸ No user logged in');
                return;
            }
            
            // Log current options
            console.log('Current options count:', select.options.length);
            
            // Clear existing options (keep the first one)
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            // Add the competition manually
            const option = document.createElement('option');
            option.value = 'aaa';
            option.textContent = 'aaa';
            select.appendChild(option);
            
            console.log('âœ… Option added. New count:', select.options.length);
            console.log('Select innerHTML:', select.innerHTML);
            
        } catch (error) {
            console.error('âŒ Error loading competitions:', error);
        }
    };
    
    console.log('âœ… Competition loading function registered');
}

async function initializeCaseModalCompetitions() {
    console.log('ðŸš€ Initializing case modal competitions...');
    
    const select = document.getElementById('competitionSelectCase');
    console.log('Case competition select element:', select);
    
    if (!select) {
        console.error('âŒ Case competition select element not found!');
        return;
    }
    
    // Use the same approach as the working speaking modal
    await populateCompetitionsDropdown();
    
    // Add event listener for competency population when competition changes
    select.addEventListener('change', async function(e) {
        const selectedCompetition = e.target.value;
        console.log('Case competition changed to:', selectedCompetition);
        if (selectedCompetition) {
            await populateCompetencyOptionsForCase(selectedCompetition);
        }
    });
}

// Add this function to populate competencies for case modal
async function populateCompetencyOptionsForCase(competitionName) {
    console.log('Populating competencies for case modal, competition:', competitionName);
    
    const competencies = await getCompetenciesFromLatestSubmission(competitionName);
    const competencyGrid = document.querySelector('#caseModal .competency-grid');
    
    if (!competencyGrid) {
        console.error('Case modal competency grid not found');
        return;
    }
    
    // Clear existing competencies
    competencyGrid.innerHTML = '';
    
    // Use extracted competencies or fallback to defaults
    const competenciesToUse = competencies.length > 0 ? competencies : [
        'Teamwork',
        'Leadership', 
        'Innovation',
        'Communication',
        'Ethics',
        'Problem Solving',
        'Critical Thinking',
        'Time Management'
    ];
    
    console.log('Using competencies for case modal:', competenciesToUse);
    
    // Add competency checkboxes
    competenciesToUse.forEach(comp => {
        const label = document.createElement('label');
        label.innerHTML = `
            <input type="checkbox" class="competency-option" value="${comp}">
            ${comp}
        `;
        competencyGrid.appendChild(label);
    });
}


function initializeSpeakingModal() {
    console.log('ðŸš€ Initializing speaking modal...');
    
    // Check if applySpeakingModalStyles exists
    if (typeof applySpeakingModalStyles === 'function') {
        applySpeakingModalStyles();
    }
    
    fixCompetitionLoading();
    
    const speakingModal = document.getElementById('speakingModal');
    console.log('Speaking modal element:', speakingModal);
    
    if (speakingModal) {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.attributeName === 'class') {
                    const isVisible = !mutation.target.classList.contains('hidden');
                    console.log('Modal visibility changed:', isVisible);
                    
                    if (isVisible && typeof window.loadCompetitions === 'function') {
                        console.log('ðŸ“¢ Calling loadCompetitions...');
                        window.loadCompetitions();
                    }
                }
            });
        });
        observer.observe(speakingModal, { attributes: true });
        console.log('âœ… Observer attached');
    } else {
        console.error('âŒ Speaking modal not found!');
    }
    
    console.log('âœ… Speaking modal initialization complete');
}

// Wait for DOM and Firebase
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpeakingModal);
} else {
    initializeSpeakingModal();
}

// Also try when Firebase auth is ready
firebase.auth().onAuthStateChanged((user) => {
    console.log('ðŸ” Auth state changed:', user ? user.uid : 'No user');
    if (user && typeof window.loadCompetitions === 'function') {
        // Small delay to ensure DOM is ready
        setTimeout(() => {
            console.log('ðŸ”„ Attempting to load competitions after auth...');
            window.loadCompetitions();
        }, 500);
    }
});

// Get modal elements
const modal = document.getElementById('pdfModal');
const openBtn = document.getElementById('openModalBtn');
const closeBtn = modal.querySelector('.close');
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const fileNameDisplay = document.getElementById('fileName');

const updatedModalHTML = `
<div id="pdfModal" class="modal">
  <div class="modal-content" style=" width: 95vw !important;
  max-width: 1200px !important;
  min-width: 300px; ">
    <span class="close" onclick="closeTrainingModal()">&times;</span>
    <h2 style="
            color: rgba(75, 85, 99, 0.9);
            margin: 0 0 30px 0;
            font-size: 32px;
            font-weight: 300;
            text-align: center;
            letter-spacing: -0.5px;
        ">Train Your Model</h2>
    
    <!-- PDF Upload Section -->
    <div class="training-section">
      <h3>ðŸ“„ Upload Study Material (Optional)</h3>
      <div id="dropZone" style="border: 2px dashed #ccc; padding: 2rem; text-align: center; margin-bottom: 1rem; cursor: pointer; border-radius: 8px;">
        Drag & Drop PDF Here or Click to Upload
      </div>
      <input type="file" id="fileInput" accept="application/pdf" hidden />
      <p id="fileName" style="margin-top: 0.5rem; color: #666;"></p>
    </div>

    <!-- Manual Questions Section -->
    <div class="training-section" style="margin-top: 2rem;">
      <h3>âœï¸ Add Your Own Questions</h3>
      <div id="manualQuestionsContainer">
        <!-- Questions will be added here dynamically -->
      </div>
      <button type="button" onclick="addQuestionInput()" style="background: #3b82f6; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; margin-top: 1rem;">
        âž• Add Question
      </button>
    </div>

    <button onclick="usePDFForTraining()" class="start-btn" style="margin-top: 2rem; width: 100%;">
      Save Training Data
    </button>
  </div>
</div>`;

// Initialize manual questions array
let manualQuestions = [];
// Initialize question counter
let questionCounter = 0;
let useMenteeTrainingData = true;
let uploadedPDFs = [];

function selectTrainingSource(source) {
  const menteeBtn = document.querySelector('.toggle-btn:nth-child(1)');
  const uploadBtn = document.querySelector('.toggle-btn:nth-child(2)');
  const uploadContainer = document.getElementById('pdfUploadContainer');
  
  if (source === 'mentee') {
    useMenteeTrainingData = true;
    menteeBtn.classList.add('active');
    uploadBtn.classList.remove('active');
    uploadContainer.style.display = 'none';
  } else {
    useMenteeTrainingData = false;
    menteeBtn.classList.remove('active');
    uploadBtn.classList.add('active');
    uploadContainer.style.display = 'block';
  }
}



function setupMultiFileDragAndDrop() {
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('multiFileInput');
    
    if (!dropZone || !fileInput) {
        console.error('âŒ Drop zone or file input not found');
        return;
    }
    
    console.log('âœ… Drag & Drop setup complete');
    
    // Click to upload
    dropZone.addEventListener('click', (e) => {
        e.stopPropagation();
        fileInput.click();
    });
    
    // Listen on DOCUMENT level
    document.addEventListener('dragenter', (e) => {
        if (dropZone.offsetParent !== null) { // Only if modal is visible
            e.preventDefault();
            e.stopPropagation();
            dropZone.style.backgroundColor = '#f0f9ff';
            dropZone.style.borderColor = '#3b82f6';
        }
    });
    
    document.addEventListener('dragover', (e) => {
        if (dropZone.offsetParent !== null) {
            e.preventDefault();
            e.stopPropagation();
            dropZone.style.backgroundColor = '#f0f9ff';
            dropZone.style.borderColor = '#3b82f6';
        }
    });
    
    document.addEventListener('dragleave', (e) => {
        dropZone.style.backgroundColor = '';
        dropZone.style.borderColor = '';
    });
    
    document.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.style.backgroundColor = '';
        dropZone.style.borderColor = '';
        
        if (dropZone.offsetParent !== null) { // Only if modal is visible
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                console.log('ðŸ“„ File dropped:', files[0].name);
                handleFile(files[0]);
            }
        }
    });
    
    // Handle file input change
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            console.log('ðŸ“„ File selected:', e.target.files[0].name);
            handleFile(e.target.files[0]);
        }
    });
}

function handleMultipleFiles(files) {
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    
    // Check if file is PDF and we haven't reached the limit
    const isPDF = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');
    
    if (!isPDF) {
      alert('Please upload only PDF files.');
      continue;
    }
    
    if (uploadedPDFs.length >= 5) {
      alert('Maximum of 5 PDFs allowed.');
      break;
    }
    
    // Check if file is already uploaded
    if (uploadedPDFs.some(pdf => pdf.name === file.name)) {
      alert(`File "${file.name}" is already uploaded.`);
      continue;
    }
    
    // Add to uploaded files array
    uploadedPDFs.push({
      file: file,
      name: file.name,
      processed: false
    });
    
    // Process the PDF
    processPDFForMultiUpload(file);
  }
  
  // Update the UI
  updateUploadedFilesList();
}


function processPDFForMultiUpload(file) {
  const reader = new FileReader();
  
  reader.onload = async function(e) {
    try {
      const typedArray = new Uint8Array(e.target.result);
      const pdf = await pdfjsLib.getDocument(typedArray).promise;
      let fullText = '';
      
      // Extract text from each page (limit to first 10 pages for performance)
      const pageLimit = Math.min(pdf.numPages, 10);
      for (let i = 1; i <= pageLimit; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        fullText += textContent.items.map(item => item.str).join(' ');
      }
      
      // Update the file in the array with the extracted text
      const fileIndex = uploadedPDFs.findIndex(pdf => pdf.name === file.name);
      if (fileIndex !== -1) {
        uploadedPDFs[fileIndex].content = fullText.substring(0, 10000); // Limit text length
        uploadedPDFs[fileIndex].processed = true;
        
        // Update the UI to show processed status
        updateUploadedFilesList();
      }
      
    } catch (error) {
      console.error('PDF processing error:', error);
      // Mark as error
      const fileIndex = uploadedPDFs.findIndex(pdf => pdf.name === file.name);
      if (fileIndex !== -1) {
        uploadedPDFs[fileIndex].error = true;
        updateUploadedFilesList();
      }
    }
  };
  
  reader.readAsArrayBuffer(file);
}

// Replace static loading with real-time listener
function loadCompetenciesRealTime() {
    const db = firebase.firestore();
    
    // Listen to competencies collection in real-time
    db.collection('competencies').onSnapshot((snapshot) => {
        const competencyContainer = document.querySelector('.competency-options'); // or wherever your checkboxes are
        
        if (!competencyContainer) return;
        
        competencyContainer.innerHTML = ''; // Clear existing
        
        snapshot.docs.forEach(doc => {
            const competency = doc.data();
            const label = document.createElement('label');
            label.innerHTML = `
                <input type="checkbox" class="competency-option" value="${competency.name}"> 
                ${competency.name}
            `;
            competencyContainer.appendChild(label);
        });
        
        console.log('Competencies updated:', snapshot.docs.length);
    }, error => {
        console.error('Error listening to competencies:', error);
    });
}

// Call this instead of your current loading function
loadCompetenciesRealTime();

function updateUploadedFilesList() {
  const container = document.getElementById('uploadedFilesList');
  if (!container) return;
  
  container.innerHTML = '';
  
  uploadedPDFs.forEach((pdf, index) => {
    const fileDiv = document.createElement('div');
    fileDiv.className = 'uploaded-file-item';
    
    let statusText = 'Processing...';
    let statusColor = '#666';
    
    if (pdf.processed) {
      statusText = 'Ready';
      statusColor = '#10b981';
    } else if (pdf.error) {
      statusText = 'Error';
      statusColor = '#ef4444';
    }
    
    fileDiv.innerHTML = `
      <div>
        <strong>${pdf.name}</strong>
        <span style="color: ${statusColor}; font-size: 0.8rem; margin-left: 0.5rem;">${statusText}</span>
      </div>
      <button class="remove-file-btn" onclick="removeUploadedFile(${index})">Remove</button>
    `;
    
    container.appendChild(fileDiv);
  });
}

function removeUploadedFile(index) {
  uploadedPDFs.splice(index, 1);
  updateUploadedFilesList();
}

// Modify your usePDFForTraining function to handle both scenarios
async function usePDFForTraining() {
  try {
    const userId = getCurrentUserId();
    const userQuestions = collectManualQuestions();
    const competitionSelect = document.getElementById('competitionSelect');
    const selectedCompetition = competitionSelect && competitionSelect.value ? competitionSelect.value : 'general';
    
    let trainingContent = '';
    
    if (useMenteeTrainingData) {
      // Use mentee training data (existing logic)
      let pdfContent = localStorage.getItem('currentTrainingText');
      
      if (!pdfContent) {
        try {
          const doc = await db.collection('userTraining').doc(userId).get();
          if (doc.exists) {
            pdfContent = doc.data().gptTrainingContext?.content || null;
          }
        } catch (error) {
          console.log('Could not retrieve existing PDF content:', error);
        }
      }
      
      trainingContent = (pdfContent || '').substring(0, 90000);
    } else {
      // Use uploaded PDFs content
      trainingContent = uploadedPDFs
        .filter(pdf => pdf.processed && pdf.content)
        .map(pdf => pdf.content)
        .join('\n\n')
        .substring(0, 90000); // Limit total content length
    }
    
    // Check if there's any content to save
    const hasContent = (trainingContent && trainingContent.trim().length > 0) || userQuestions.length > 0;

    if (!hasContent) {
      alert('Please upload a PDF or add at least one custom question before submitting');
      return;
    }

    const trainingEntry = {
      content: trainingContent,
      userQuestions: userQuestions,
      timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      competition: selectedCompetition,
      type: 'training_data',
      entryId: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      createdAt: new Date().toISOString(),
      useMenteeTrainingData: useMenteeTrainingData // Store the selection in Firebase
    };

    // Save to Firebase
    const docRef = await db.collection('userTraining').doc(userId).collection('entries').add(trainingEntry);
    
    console.log('New training entry added with ID:', docRef.id);
    console.log('Used mentee training data:', useMenteeTrainingData);

    localStorage.removeItem('currentTrainingText');

    const fileName = document.getElementById('fileName');
    if (fileName) {
      const competitionText = selectedCompetition === 'general' ? '' : ` for ${selectedCompetition}`;
      const sourceType = useMenteeTrainingData ? 'Mentee Training Data' : 'Uploaded Documents';
      fileName.textContent = `âœ… ${sourceType} saved${competitionText}! (${userQuestions.length} questions, ${trainingContent.length} chars)`;
      fileName.style.color = '#10b981';
    }

    // Reset uploaded files if any
    uploadedPDFs = [];
    updateUploadedFilesList();

    setTimeout(() => {
      closeTrainingModal();
    }, 1500);
  } catch (error) {
    console.error('Error saving training data:', error);
    alert('Error saving training data. Please try again.');
  }
}

// Initialize the multi-file drag and drop when modal opens

function getCurrentUserId() {
    if (!firebase.apps.length) {
        console.error('Firebase not initialized!');
        return 'anonymous';
    }
    return firebase.auth().currentUser?.uid || 'anonymous';
}

function addQuestionInput() {
  questionCounter++;
  const container = document.getElementById('manualQuestionsContainer');
  
  const questionDiv = document.createElement('div');
  questionDiv.className = 'question-input-group';
  questionDiv.id = `question-${questionCounter}`;
  
  questionDiv.innerHTML = `
    <div class="question-header">
      <div class="question-number" style="display: none;">${questionCounter} <button type="button" onclick="removeQuestion(${questionCounter})" class="remove-btn" style="margin-left: 200px;">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button></div>
      <h4>Question ${questionCounter}</h4>
      
    </div>
    
    <div class="form-group">
      <label for="questionText-${questionCounter}">Question Text:</label>
      <textarea id="questionText-${questionCounter}" placeholder="Enter your question here..."></textarea>
    </div> <br>
    
    <div class="form-group">
      <label for="competency-${questionCounter}">Competency:</label>
      <select id="competency-${questionCounter}">
        <option value="">Select competency...</option>
        <option value="Business Communication">Business Communication</option>
        <option value="Marketing">Marketing</option>
        <option value="Accounting">Accounting</option>
        <option value="Economics">Economics</option>
        <option value="Parliamentary Procedure">Parliamentary Procedure</option>
        <option value="Leadership">Leadership</option>
        <option value="Management">Management</option>
        <option value="Finance">Finance</option>
        <option value="Entrepreneurship">Entrepreneurship</option>
        <option value="Business Ethics">Business Ethics</option>
      </select>
    </div> <br>
    
    <div class="options-grid">
      <div class="form-group">
        <label for="optionA-${questionCounter}">Option A:</label>
        <input type="text" id="optionA-${questionCounter}" placeholder="Option A">
      </div>
      <div class="form-group">
        <label for="optionB-${questionCounter}">Option B:</label>
        <input type="text" id="optionB-${questionCounter}" placeholder="Option B">
      </div>
      <div class="form-group" style="margin-top: 20xpx;">
        <label for="optionC-${questionCounter}">Option C:</label>
        <input type="text" id="optionC-${questionCounter}" placeholder="Option C">
      </div>
      <div class="form-group">
        <label for="optionD-${questionCounter}">Option D:</label>
        <input type="text" id="optionD-${questionCounter}" placeholder="Option D">
      </div>
    </div>
    
    <div class="correct-answer-container">
      <label for="correctAnswer-${questionCounter}">Correct Answer:</label>
      <select id="correctAnswer-${questionCounter}">
        <option value="">Select correct answer...</option>
        <option value="A">Option A</option>
        <option value="B">Option B</option>
        <option value="C">Option C</option>
        <option value="D">Option D</option>
      </select>
    </div>
  `;
  
  container.appendChild(questionDiv);
}


function renumberQuestions() {
  const questions = document.querySelectorAll('.question-input-group');
  questions.forEach((question, index) => {
    const questionNumber = index + 1;
    question.id = `question-${questionNumber}`;
    question.querySelector('.question-number').textContent = questionNumber;
    question.querySelector('h4').textContent = `Question ${questionNumber}`;
    // Update remove button onclick
    const removeBtn = question.querySelector('.remove-btn');
    removeBtn.setAttribute('onclick', `removeQuestion(${questionNumber})`);
  });
  questionCounter = questions.length;
}

// Function to remove a question
function removeQuestion(questionId) {
  const questionToRemove = document.getElementById(`question-${questionId}`);
  if (questionToRemove) {
    questionToRemove.remove();
    // Optional: Re-number remaining questions
    renumberQuestions();
  }
}

async function deleteSelectedTrainingData() {
    const selectedCompetition = document.getElementById('deleteCompetitionSelect')?.value;
    await clearTrainingContext(selectedCompetition || null);
}

// Populate delete dropdown when needed
async function populateDeleteDropdown() {
    const select = document.getElementById('deleteCompetitionSelect');
    if (select) {
        const userDoc = await firebase.firestore().collection('users').doc(firebase.auth().currentUser.uid).get();
        const competitions = userDoc.data()?.competitions || ['general'];
        
        // FIX: Convert to array if it's a string
        const competitionsArray = Array.isArray(competitions) ? competitions : [competitions];
        
        select.innerHTML = '<option value="">All competitions</option>';
        competitionsArray.forEach(comp => {  // Use competitionsArray here
            const option = document.createElement('option');
            option.value = comp;
            option.textContent = comp;
            select.appendChild(option);
        });
    }
}
// Updated openTrainingModal function
// Fixed openTrainingModal function
async function openTrainingModal() {
    const modal = document.getElementById('pdfModal');
    modal.style.display = 'flex';
    populateCompetitionsDropdown();

    // Reset inputs
    const fileInput = document.getElementById('fileInput');
    const fileNameDisplay = document.getElementById('fileName');
    if (fileInput) fileInput.value = '';
    if (fileNameDisplay) fileNameDisplay.textContent = '';

    // Clear manual questions
    const container = document.getElementById('manualQuestionsContainer');
    if (container) container.innerHTML = '';
    manualQuestions = [];
    questionCounter = 0;

    // Populate competition dropdown
    const competitionSelect = document.getElementById('competitionSelect');
    if (competitionSelect) {
        const user = firebase.auth().currentUser;
        if (user) {
            const userDoc = await firebase.firestore().collection('users').doc(user.uid).get();
            const compData = userDoc.data()?.competitions;
            
            const competitions = Array.isArray(compData) ? compData : 
                               (typeof compData === 'string' ? [compData] : ['general']);
            
            competitionSelect.innerHTML = '<option value="">Select competition...</option>';
            (Array.isArray(competitions) ? competitions : [competitions]).forEach(comp => {
                const option = document.createElement('option');
                option.value = comp;
                option.textContent = comp;
                competitionSelect.appendChild(option);
            });
        }
    }
    
    addQuestionInput();
    
    // Setup drag & drop with correct IDs
    setTimeout(() => {
        setupMultiFileDragAndDrop();
        console.log('âœ… Drag & drop initialized');
    }, 300);
}

// Fixed getUserCompetitions function
async function getUserCompetitions() {
    try {
        const user = firebase.auth().currentUser;
        if (!user) return [];
        
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (!userDoc.exists) return [];
        
        const userData = userDoc.data();
        
        // Check all possible field names for competitions
        if (userData.competitions && Array.isArray(userData.competitions)) {
            return userData.competitions;
        } else if (userData.competition) {
            // If it's a single competition, return as array
            return [userData.competition];
        } else if (userData.currentCompetition) {
            return [userData.currentCompetition];
        }
        
        return [];
    } catch (error) {
        console.error('Error getting user competitions:', error);
        return [];
    }
}

// Function to collect manual questions
function collectManualQuestions() {
  const questions = [];
  const container = document.getElementById('manualQuestionsContainer');
  
  if (!container) return questions;
  
  const questionDivs = container.querySelectorAll('.question-input-group');
  
  questionDivs.forEach(div => {
    const id = div.id.split('-')[1];
    
    const questionText = document.getElementById(`questionText-${id}`)?.value.trim();
    const competency = document.getElementById(`competency-${id}`)?.value;
    const optionA = document.getElementById(`optionA-${id}`)?.value.trim();
    const optionB = document.getElementById(`optionB-${id}`)?.value.trim();
    const optionC = document.getElementById(`optionC-${id}`)?.value.trim();
    const optionD = document.getElementById(`optionD-${id}`)?.value.trim();
    const correctAnswerLetter = document.getElementById(`correctAnswer-${id}`)?.value;
    
    // Validate question completeness
    if (questionText && competency && optionA && optionB && optionC && optionD && correctAnswerLetter) {
      const options = [optionA, optionB, optionC, optionD];
      const correctAnswerIndex = ['A', 'B', 'C', 'D'].indexOf(correctAnswerLetter);
      const correctAnswer = options[correctAnswerIndex];
      
      questions.push({
        text: questionText,
        competency: competency,
        options: options,
        correctAnswer: correctAnswer,
        source: 'manual'
      });
    }
  });
  
  return questions;
}


// Modal open/close functions


function closeTrainingModal() {
  modal.style.display = 'none';
}

// Event listeners for modal
openBtn.addEventListener('click', openTrainingModal);
closeBtn.addEventListener('click', closeTrainingModal);

document.addEventListener('DOMContentLoaded', () => {
  setupDragAndDrop();
});


// Simple drag and drop setup
function setupDragAndDrop() {
  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('multiFileInput');
  
  if (!dropZone) {
    console.error('âŒ Drop zone not found');
    return;
  }
  
  if (!fileInput) {
    console.error('âŒ File input not found');
    return;
  }
  
  console.log('âœ… Drag & Drop setup initialized');
  
  // Click to upload
  dropZone.addEventListener('click', (e) => {
    e.stopPropagation();
    fileInput.click();
  });
  
  // Prevent default drag behaviors
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropZone.addEventListener(eventName, (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, false);
  });
  
  // Highlight on drag
  dropZone.addEventListener('dragenter', (e) => {
    dropZone.style.backgroundColor = '#f0f9ff';
    dropZone.style.borderColor = '#3b82f6';
  });
  
  dropZone.addEventListener('dragover', (e) => {
    dropZone.style.backgroundColor = '#f0f9ff';
    dropZone.style.borderColor = '#3b82f6';
  });
  
  // Unhighlight on leave
  dropZone.addEventListener('dragleave', (e) => {
    dropZone.style.backgroundColor = '';
    dropZone.style.borderColor = '';
  });
  
  // Handle drop
  dropZone.addEventListener('drop', (e) => {
    dropZone.style.backgroundColor = '';
    dropZone.style.borderColor = '';
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      handleFile(files[0]);
    }
  });
  
  // Handle file input change (when user clicks to select)
  fileInput.addEventListener('change', (e) => {
    if (e.target.files.length > 0) {
      handleFile(e.target.files[0]);
    }
  });
}

async function handleFile(file) {
  console.log('ðŸ“„ File:', file.name);
  
  if (file.type !== 'application/pdf') {
    alert('âŒ PDF only');
    return;
  }
  
  if (file.size > 10 * 1024 * 1024) {
    alert('âŒ Max 10MB');
    return;
  }
  
  const user = firebase.auth().currentUser;
  if (!user) {
    alert('âŒ Log in first');
    return;
  }
  
  try {
    // Change the drop zone text to filename FIRST
    const dropZoneText = document.querySelector('.drop-zone-text');
    if (dropZoneText) {
      dropZoneText.textContent = file.name;
      console.log('âœ… Text changed to:', file.name);
    }
    
    // Then upload
    const filePath = `training/${user.uid}/${file.name}`;
    const result = await db.collection('training').doc(user.uid).collection('files').add({
      name: file.name,
      path: filePath,
      uploadedAt: new Date(),
      size: file.size
    });
    
    console.log('âœ… File uploaded successfully!', result.id);
    
  } catch (error) {
    console.error('âŒ Upload Error:', error.code, error.message);
    alert('Upload failed: ' + error.message);
    // Revert text on error
    const dropZoneText = document.querySelector('.drop-zone-text');
    if (dropZoneText) {
      dropZoneText.textContent = 'Drag & Drop PDF Here or Click to Upload';
    }
  }
}

// Call setup function after modal elements are ready
setTimeout(setupDragAndDrop, 100);


  
  window.fetchBaselineNotesForCompetition = async function(competitionName) {
    try {
      console.log("ðŸ“š Fetching baseline notes for:", competitionName);
      if (!competitionName || competitionName === "general") {
        console.log("â­ï¸ No competition specified, skipping baseline notes");
        return "";
      }
      const docRef = firebase.firestore().collection("competitions").doc(competitionName);
      const docSnapshot = await docRef.get();
      if (docSnapshot.exists) {
        const baseline = docSnapshot.data().baseline;
        if (baseline && baseline.text) {
          console.log("âœ… Baseline notes found, length:", baseline.text.length);
          return baseline.text;
        }
      }
      console.log("âŒ No baseline notes found for", competitionName);
      return "";
    } catch (error) {
      console.error("ðŸ’¥ Error fetching baseline:", error);
      return "";
    }
  };

window.generateQuestionsFromCompetencies = async function(competencies, questionCount, difficulty, assignment) {
        console.log("ðŸš€ =========================== QUESTION GENERATION START ===========================");
        console.log("ðŸ” Initial parameters:", { 
            competencies, 
            questionCount, 
            difficulty, 
            assignmentExists: !!assignment,
            assignmentKeys: assignment ? Object.keys(assignment) : []
        });

        // Use your existing API key
        const apiKey = window.openaiApiKey || "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";

        const compText = competencies.join(', ');
        let trainingContext = "";
        let allTrainingContent = [];
        let hasTrainingData = false;

        // ================================ PDF PROCESSING SECTION ================================
        console.log("ðŸ“„ =========================== PDF PROCESSING START ===========================");

        console.log("ðŸ“„ =========================== PDF PROCESSING START ===========================");

const currentUser = firebase.auth().currentUser;
if (currentUser) {
    try {
        // Get baseline notes for competition
        const selectedCompetition = document.getElementById("competitionSelectWritten")?.value || document.getElementById("caseCompetitionSelect")?.value;
        
        if (selectedCompetition && selectedCompetition !== 'general') {
            const competitionRef = await db.collection('competitions').doc(selectedCompetition).get();
            if (competitionRef.exists) {
                const baseline = competitionRef.data()?.baseline?.text;
                if (baseline) {
                    allTrainingContent.push(baseline);
                    hasTrainingData = true;
                    console.log(`âœ… Added baseline from competitions/${selectedCompetition}`);
                }
            }
        }
        
        // Get GPT training context from userTraining
        const userTrainingRef = await db.collection('userTraining').doc(currentUser.uid).get();
        if (userTrainingRef.exists) {
            const gptContext = userTrainingRef.data()?.gptTrainingContext?.content;
            if (gptContext) {
                allTrainingContent.push(gptContext);
                hasTrainingData = true;
                console.log(`âœ… Added gptTrainingContext from userTraining`);
            }
        }
        
    } catch (err) {
        console.error('Error reading training content:', err.message);
    }
} else {
    console.log("âŒ No authenticated user");
}
        
        if (!assignment) {
            console.log("âŒ NO ASSIGNMENT OBJECT PROVIDED");
        } else if (!assignment.trainingPDFs) {
            console.log("âŒ NO trainingPDFs PROPERTY IN ASSIGNMENT");
            console.log("ðŸ“‹ Available assignment properties:", Object.keys(assignment));
        } else if (!Array.isArray(assignment.trainingPDFs)) {
            console.log("âŒ trainingPDFs IS NOT AN ARRAY:", typeof assignment.trainingPDFs);
            console.log("ðŸ“‹ trainingPDFs value:", assignment.trainingPDFs);
        } else if (assignment.trainingPDFs.length === 0) {
            console.log("âŒ trainingPDFs ARRAY IS EMPTY");
        } else {
            console.log("âœ… trainingPDFs FOUND - Count:", assignment.trainingPDFs.length);
            console.log("ðŸ“„ Full trainingPDFs structure:", JSON.stringify(assignment.trainingPDFs, null, 2));
            
            assignment.trainingPDFs.forEach((pdf, index) => {
                console.log(`\nðŸ“„ PROCESSING PDF ${index + 1}/${assignment.trainingPDFs.length}:`);
                console.log(`   Name: ${pdf.name || 'UNNAMED'}`);
                console.log(`   Type: ${pdf.type || 'NO TYPE'}`);
                console.log(`   Processed: ${pdf.processed}`);
                console.log(`   Has content: ${!!pdf.content}`);
                console.log(`   Content type: ${typeof pdf.content}`);
                console.log(`   Content length: ${pdf.content?.length || 0}`);
                
                if (!pdf.content) {
                    console.log("   âŒ SKIP: No content property");
                } else if (typeof pdf.content !== 'string') {
                    console.log("   âŒ SKIP: Content is not a string");
                } else if (pdf.content.trim().length === 0) {
                    console.log("   âŒ SKIP: Content is empty after trim");
                } else {
                    const contentSnippet = pdf.content.trim().substring(0, 1500); // Increased from 1000
                    allTrainingContent.push(contentSnippet);
                    hasTrainingData = true;
                    console.log("   âœ… ADDED PDF to training content");
                    console.log(`   First 200 chars: "${contentSnippet.substring(0, 200)}..."`);
                }
            });
        }

        // ================================ USER TRAINING DATA SECTION ================================
        
        console.log("\nðŸ“š =========================== BASELINE NOTES START ===========================");
        let baselineNotes = "";
        const selectedCompetition = document.getElementById("competitionSelectWritten")?.value || document.getElementById("caseCompetitionSelect")?.value;
        if (selectedCompetition && selectedCompetition !== "general") {
            baselineNotes = await window.fetchBaselineNotesForCompetition(selectedCompetition);
            if (baselineNotes) {
                allTrainingContent.push(baselineNotes);
                hasTrainingData = true;
                console.log("âœ… Baseline notes ADDED to training content");
                console.log(`   Baseline length: ${baselineNotes.length}`);
            }
        } else {
            console.log("â­ï¸ No competition selected, skipping baseline");
        }

console.log("\nðŸ‘¤ =========================== USER TRAINING DATA START ===========================");
        
if (assignment?.usedMenteeTrainingData === true) {
    console.log("âœ… User training data REQUESTED");
    try {
        const currentUser = firebase.auth().currentUser;
        if (!currentUser) {
            console.log("âŒ No current user authenticated");
        } else {
            console.log("âœ… Current user found:", currentUser.uid);
            const userTrainingRef = firebase.firestore().collection('userTraining').doc(currentUser.uid);
            const userTrainingDoc = await userTrainingRef.get();
            
            if (!userTrainingDoc.exists) {
                console.log("âŒ No user training document exists");
            } else {
                console.log("âœ… User training document exists");
                const entriesRef = userTrainingRef.collection('entries').orderBy('timestamp', 'desc').limit(3);
                const entriesSnapshot = await entriesRef.get();
                
                console.log(`ðŸ“Š Found ${entriesSnapshot.size} user training entries`);
                
                entriesSnapshot.forEach(doc => {
                    const data = doc.data();
                    console.log(`   Entry ID: ${doc.id}`);
                    console.log(`   Has content: ${!!data.content}`);
                    console.log(`   Content length: ${data.content?.trim().length || 0}`);
                    
                    if (data.content && data.content.trim().length > 0) {
                        // Add text content
                        allTrainingContent.push(data.content.trim().substring(0, 2000));
                        hasTrainingData = true;
                        console.log("   âœ… ADDED user training content");
                    }
                    
                    // Also add extracted PDF content if available
                    if (data.pdfContent && data.pdfContent.trim().length > 0) {
                        allTrainingContent.push(data.pdfContent.trim().substring(0, 2000));
                        hasTrainingData = true;
                        console.log("   âœ… ADDED extracted PDF content from entry");
                    }
                });
            }
        }
    } catch (error) {
        console.error("ðŸ’¥ Error fetching user training data:", error);
    }
} else {
    console.log("â­ï¸ User training data NOT requested");
    console.log(`   usedMenteeTrainingData value: ${assignment?.usedMenteeTrainingData}`);
}

        // ================================ TRAINING CONTEXT CREATION ================================
        console.log("\nðŸ”§ =========================== TRAINING CONTEXT CREATION ===========================");
        console.log(`Total training content pieces: ${allTrainingContent.length}`);
        console.log(`Has training data: ${hasTrainingData}`);

        if (hasTrainingData && allTrainingContent.length > 0) {
            const combinedContent = allTrainingContent.join(' ').substring(0, 2500); // Increased limit
            trainingContext = combinedContent;
            
            console.log("âœ… TRAINING CONTEXT CREATED");
            console.log(`   Combined content length: ${combinedContent.length}`);
            console.log(`   First 300 chars of context: "${trainingContext.substring(0, 300)}..."`);
        } else {
            console.log("âŒ NO TRAINING CONTEXT CREATED - No valid training data");
        }

        // ================================ PROMPT CREATION ================================
        console.log("\nðŸ“ =========================== PROMPT CREATION ===========================");
        
        let prompt;
        if (hasTrainingData && trainingContext) {
            prompt = `You are creating FBLA business questions that MUST be directly based on this student's uploaded content:

"${trainingContext}"

Create ${questionCount} multiple choice questions that:
1. Use concepts, topics, and themes from the student's content above
2. Connect those concepts to these business competencies: ${compText}
3. Are at ${difficulty} difficulty level
4. Have exactly 4 answer choices each
5. Make the connection between the student's content and business concepts clear

CRITICAL: The questions MUST relate to the actual content the student uploaded. If the content is about prisons, create questions about workplace management, employee conditions, organizational structure, etc. that connect to that theme.

Return JSON only in this exact format:
[
  {
    "text": "Question text that references concepts from the student content?",
    "competency": "One of the provided competency names",
    "correctAnswer": "The correct option text",
    "options": ["Option A", "Option B", "Option C", "Option D"]
  }
]`;
        } else {
            prompt = `Generate ${questionCount} FBLA multiple choice questions.
- Difficulty: ${difficulty}
- Competencies: ${compText}
- Each must have exactly 4 options, 1 correct answer
- Make questions realistic for business competitions

Return JSON only in this format:
[
  {
    "text": "Question text?",
    "competency": "Competency Name",
    "correctAnswer": "Correct option text",
    "options": ["Option A", "Option B", "Option C", "Option D"]
  }
]`;
        }

        console.log("ðŸ“ FINAL PROMPT DETAILS:");
        console.log(`   Prompt length: ${prompt.length}`);
        console.log(`   Has training context: ${!!trainingContext}`);
        console.log(`   Training context length: ${trainingContext.length}`);
        
        console.log("ðŸ“ ACTUAL PROMPT BEING SENT:");
        console.log("=" .repeat(80));
        console.log(prompt);
        console.log("=" .repeat(80));

        // ================================ API CALL ================================
        console.log("\nðŸŒ =========================== API CALL START ===========================");
        
        try {
            console.log("ðŸ“¤ Sending request to OpenAI...");
            
            const requestBody = {
                model: "gpt-4o-mini",
                messages: [
                    { 
                        role: "system", 
                        content: `You are an expert FBLA written-competition exam designer.

Your role is to generate ORIGINAL, competition-accurate FBLA-style multiple-choice questions that match the structure, rigor, tone, and professional standards of official FBLA written tests.

You must follow ALL rules below.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE FBLA PHILOSOPHY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FBLA written tests assess professional correctness, precision, and applied business literacy.

They do NOT assess creativity, opinion, or open-ended reasoning.

Each question must test exactly ONE concept.

Questions must be concise, objective, and professionally worded.

Avoid unnecessary narrative unless the question type explicitly requires a scenario.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
APPROVED FBLA QUESTION ARCHETYPES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Every question MUST clearly belong to ONE of the following archetypes:

1. Definition / Term Identification  
   - Identifying the correct term based on a definition  
   - Selecting the correct meaning of a professional word or concept  

2. Classification / Category Recognition  
   - Determining where an item belongs within a professional category system  
   - Examples include document types, account categories, system types, business forms, or classifications  

3. Procedural / Workflow Knowledge  
   - Understanding the stages of a professional workflow specific to the competition area  
   - Identifying where information originates within that workflow  
   - Determining which document, tool, or action is appropriate at a given stage  
   - Recognizing correct sequencing of professional tasks within the domain  

4. Tool-to-Function Matching  
   - Matching software features, commands, utilities, or tools to their correct purpose  
   - Selecting the correct function used to accomplish a professional task  

5. Quantitative / Calculation Application  
   - Performing single-step or limited multi-step calculations  
   - Selecting the correct numeric result based on provided data  
   - Avoid unnecessary complexity or advanced math  

6. Language Precision & Usage  
   - Correct use of professional vocabulary  
   - Distinguishing homophones, word meanings, spelling, grammar, and standard usage  

7. Error Detection / Exception Identification  
   - Identifying what is incorrect, misspelled, or does NOT belong  
   - Using negation ("NOT") carefully and intentionally  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUESTION STRUCTURE RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Each question must assess ONE idea only.  
â€¢ Do not combine multiple concepts in one question.  
â€¢ Avoid ambiguous wording.  
â€¢ Use professional, neutral language.

Acceptable stem styles include:
- "Which of the followingâ€¦"
- "What term best describesâ€¦"
- "The document used toâ€¦"
- "Which action should be takenâ€¦"
- "Which of the following is NOTâ€¦"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ANSWER CHOICE DESIGN (CRITICAL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Each question MUST include exactly FOUR answer choices.

Answer choices must:
â€¢ Be the same grammatical form  
â€¢ Be similar in length  
â€¢ Belong to the same conceptual family  

Wrong answer choices (distractors) must be plausible and realistic.

Allowed distractor strategies include:
â€¢ Closely related terms within the same category  
â€¢ Common student misconceptions  
â€¢ Incorrect step within a workflow  
â€¢ Reversed or misapplied professional rules  
â€¢ Visually or linguistically similar words  
â€¢ Typical calculation or classification errors  

Never include joke answers or obviously incorrect options.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIFFICULTY CALIBRATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Easy:
â€¢ Direct recall or recognition  
â€¢ Minimal traps  

Medium:
â€¢ Requires discrimination between similar concepts  
â€¢ Includes common misconceptions  

Hard:
â€¢ Includes negation ("NOT")  
â€¢ Requires precise rule awareness  
â€¢ Uses subtle wording differences  
â€¢ Penalizes shallow memorization  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONTENT INTEGRITY RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All questions must be ORIGINAL.  
â€¢ Do NOT copy real FBLA questions.  
â€¢ Do NOT closely paraphrase known questions.  
â€¢ Use authentic structure only, not replicated wording.

Questions must feel realistic for competitive FBLA written events at the regional, state, or national level.

When study materials are provided, extract concepts, facts, names, dates, laws, and details from them. Present this information as established business knowledge. NEVER mention "the study guide", "the document", "the material", or use phrases like "according to", "as stated in", or "mentioned in".

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OUTPUT REQUIREMENTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Generate ONLY the requested number of questions.  
â€¢ Each question must have exactly four answer options.  
â€¢ Only ONE option may be correct.  
â€¢ Output valid JSON only.  
â€¢ Do not include explanations, commentary, or headings.  

You are writing as a professional exam author â€” not as a tutor or teacher.`
                    },
                    { role: "user", content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt }
                ],
                temperature: 0.8,
                max_tokens: 2500
            };
            
            console.log("ðŸ“¤ Request body summary:", {
                model: requestBody.model,
                systemMessage: requestBody.messages[0].content,
                promptLength: requestBody.messages[1].content.length,
                temperature: requestBody.temperature
            });
            
            const res = await firebase.functions().httpsCallable("generateQuestionsWithAI")({
                messages: requestBody.messages
            });

            console.log("ðŸ“¥ Cloud Function response received");

            if (!res.data || !res.data.success) {
                const errorMsg = res.data?.error || "Unknown error";
                console.error("ðŸ’¥ API Error:", errorMsg);
                throw new Error("API Error: " + errorMsg);
            }
            
            const responseData = res.data;
            console.log("ðŸ“¥ API response summary:", {
                success: responseData.success, contentLength: responseData.content?.length || 0
            });
            
            let content = responseData.content.trim();
            console.log("ðŸ“¥ Raw content length:", content.length);
            console.log("ðŸ“¥ Raw content preview:", content.substring(0, 500) + "...");
            
            // Clean up the response
            content = content.replace(/```json|```/g, "");
            console.log("ðŸ“¥ Content after cleanup preview:", content.substring(0, 500) + "...");
            
            const questions = JSON.parse(content);
            console.log("âœ… Successfully parsed JSON - Questions count:", questions.length);
            
            // ================================ SAVE QUESTIONS TO GLOBAL VARIABLES ================================
            console.log("\nðŸ’¾ =========================== SAVING QUESTIONS ===========================");
            
            if (questions && Array.isArray(questions) && questions.length > 0) {
                // Transform questions to match your expected format
                window.writtenQuestions = questions.map((q, index) => {
                    console.log(`   Processing question ${index + 1}:`, {
                        hasText: !!q.text,
                        hasOptions: !!q.options,
                        optionsLength: q.options?.length || 0,
                        hasCorrectAnswer: !!q.correctAnswer
                    });
                    
                    return {
                        question: q.text || q.question,
                        options: q.options || [],
                        correctAnswer: q.correctAnswer,
                        competency: q.competency
                    };
                });
                
                // Initialize answers object
                window.writtenAnswers = {};
                
                console.log("âœ… QUESTIONS SAVED TO GLOBAL VARIABLES");
                console.log(`   window.writtenQuestions length: ${window.writtenQuestions.length}`);
                console.log(`   window.writtenAnswers initialized: ${typeof window.writtenAnswers}`);
                console.log("ðŸ“Š Sample saved question:", window.writtenQuestions[0]);
                
                console.log("ðŸŽ‰ =========================== SUCCESS ===========================");
                console.log(`âœ… Generated ${questions.length} questions`);
                console.log(`âœ… Used training data: ${hasTrainingData}`);
                console.log(`âœ… Training content pieces: ${allTrainingContent.length}`);
                console.log(`âœ… PDF processing: ${assignment?.trainingPDFs?.length || 0} PDFs`);
                console.log(`âœ… User training: ${assignment?.usedMenteeTrainingData === true ? 'Requested' : 'Not requested'}`);
                
                return questions;
            } else {
                throw new Error("No valid questions in response");
            }

        } catch (err) {
            console.error("ðŸ’¥ =========================== ERROR OCCURRED ===========================");
            console.error("ðŸ’¥ Error type:", err.constructor.name);
            console.error("ðŸ’¥ Error message:", err.message);
            console.error("ðŸ’¥ Full error:", err);
            
            console.log("ðŸ”„ =========================== FALLBACK PROCESSING ===========================");
            
            let fallbackQuestions = [];
            
            // Try to get fallback questions
            if (typeof getFallbackQuestions === 'function') {
                console.log("ðŸ”„ Trying getFallbackQuestions...");
                fallbackQuestions = getFallbackQuestions(questionCount, competencies);
            } else if (typeof createBasicQuestions === 'function') {
                console.log("ðŸ”„ Trying createBasicQuestions...");
                fallbackQuestions = createBasicQuestions(questionCount, competencies);
            } else {
                console.log("ðŸ”„ Creating emergency fallback questions...");
                fallbackQuestions = Array.from({length: questionCount}, (_, i) => ({
                    question: `Sample FBLA question ${i + 1} for ${competencies[0]}?`,
                    options: ["Option A", "Option B", "Option C", "Option D"],
                    correctAnswer: "Option A",
                    competency: competencies[0]
                }));
            }
            
            if (fallbackQuestions && fallbackQuestions.length > 0) {
                window.writtenQuestions = fallbackQuestions;
                window.writtenAnswers = {};
                console.log("âœ… Fallback questions saved:", window.writtenQuestions.length);
                return fallbackQuestions;
            } else {
                console.error("ðŸ’¥ Even fallback failed!");
                return [];
            }
        }
    };
    




// Animated blobs background
const canvas = document.getElementById('blobCanvas');
if (canvas) {
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
  }

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Blob parameters
  const blobs = [
      { x: 0.2, y: 0.3, size: 0.3, speedX: 0.0002, speedY: 0.0001, color: [168, 237, 234] }, // #a8edea
      { x: 0.7, y: 0.6, size: 0.4, speedX: -0.0001, speedY: 0.0002, color: [254, 214, 227] }, // #fed6e3
      { x: 0.4, y: 0.7, size: 0.25, speedX: 0.00015, speedY: -0.00015, color: [200, 220, 255] } // light blue
  ];

  function animateBlobs() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Create gradient background
      const gradient = ctx.createRadialGradient(
          canvas.width / 2, canvas.height / 2, 0,
          canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
      );
      gradient.addColorStop(0, 'rgba(168, 237, 234, 0.3)');
      gradient.addColorStop(1, 'rgba(254, 214, 227, 0.3)');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Animate blobs
      blobs.forEach(blob => {
          // Update position
          blob.x += blob.speedX;
          blob.y += blob.speedY;
          
          // Bounce off edges
          if (blob.x < 0 || blob.x > 1) blob.speedX *= -1;
          if (blob.y < 0 || blob.y > 1) blob.speedY *= -1;
          
          // Draw blob
          const x = blob.x * canvas.width;
          const y = blob.y * canvas.height;
          const radius = blob.size * Math.min(canvas.width, canvas.height);
          
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
          gradient.addColorStop(0, `rgba(${blob.color[0]}, ${blob.color[1]}, ${blob.color[2]}, 0.6)`);
          gradient.addColorStop(1, `rgba(${blob.color[0]}, ${blob.color[1]}, ${blob.color[2]}, 0)`);
          
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();
      });
      
    requestAnimationFrame(animateBlobs);
  }

  animateBlobs();
}

async function processPDF(file) {
  const reader = new FileReader();
  
  reader.onload = async function(e) {
    try {
      const typedArray = new Uint8Array(e.target.result);
      const pdf = await pdfjsLib.getDocument(typedArray).promise;
      let fullText = '';
      
      // Extract text from each page
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        fullText += textContent.items.map(item => item.str).join(' ');
      }
      
      // Store the extracted text
      const userId = getCurrentUserId();
firebase.firestore().collection('userTraining').doc(userId).set({
    gptTrainingContext: {
        content: fullText.substring(0, 500000),
        lastUpdated: Date.now()
    }
}, { merge: true });
      fileNameDisplay.textContent = `âœ… Processed: ${file.name}`;
      
      // Use the text for training
      prepareTrainingData(fullText);
      
    } catch (error) {
      console.error('PDF processing error:', error);
      fileNameDisplay.textContent = 'âŒ Error processing PDF';
      fileNameDisplay.style.color = '#ef4444';
    }
  };
  
  reader.readAsArrayBuffer(file);
}


function prepareTrainingData(text) {
    const userId = getCurrentUserId();
    const trainingData = {
        content: text.substring(0, 5000),
        lastUpdated: Date.now()
    };
    
    firebase.firestore().collection('userTraining').doc(userId).set({
        gptTrainingContext: trainingData
    }, { merge: true });
    
    console.log('Training data prepared');
}

// Replace your current usePDFForTraining function with this fixed version

async function usePDFForTraining() {
    try {
        const userId = getCurrentUserId();
        const userQuestions = collectManualQuestions();
        const competitionSelect = document.getElementById('competitionSelect');
        const selectedCompetition = competitionSelect && competitionSelect.value ? competitionSelect.value : 'general';
        
        // Get PDF content from localStorage or Firebase
        let pdfContent = localStorage.getItem('currentTrainingText');
        
        // If no localStorage content, check if there's existing PDF content in Firebase
        if (!pdfContent) {
            try {
                const doc = await db.collection('userTraining').doc(userId).get();
                if (doc.exists) {
                    pdfContent = doc.data().gptTrainingContext?.content || null;
                }
            } catch (error) {
                console.log('Could not retrieve existing PDF content:', error);
            }
        }

        // Check if there's any content to save
        const hasContent = (pdfContent && pdfContent.trim().length > 0) || userQuestions.length > 0;

        if (!hasContent) {
            alert('Please upload a PDF or add at least one custom question before submitting');
            return;
        }

        const limitedContent = (pdfContent || '').substring(0, 90000);

        const trainingEntry = {
            content: limitedContent,
            userQuestions: userQuestions,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            competition: selectedCompetition,
            type: 'training_data',
            entryId: Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Unique ID
            createdAt: new Date().toISOString()
        };

        // Use .add() to ALWAYS create a new document (never overwrites)
        // This creates a new document with auto-generated ID in the subcollection under the user
        const docRef = await db.collection('userTraining').doc(userId).collection('entries').add(trainingEntry);
        
        console.log('New training entry added with ID:', docRef.id);
        console.log('Training entry data:', trainingEntry);

        localStorage.removeItem('currentTrainingText');

        const fileName = document.getElementById('fileName');
        if (fileName) {
            const competitionText = selectedCompetition === 'general' ? '' : ` for ${selectedCompetition}`;
            fileName.textContent = `âœ… Training data saved${competitionText}! (${userQuestions.length} questions, ${limitedContent.length} chars)`;
            fileName.style.color = '#10b981';
        }

        setTimeout(() => {
            closeTrainingModal();
        }, 1500);
    } catch (error) {
        console.error('Error saving training data:', error);
        alert('Error saving training data. Please try again.');
    }
}

function uploadPDFToFirebase(file) {
  const user = firebase.auth().currentUser;
  if (!user) {
    console.error('User not authenticated');
    return;
  }

  const storageRef = firebase.storage().ref();
  const fileRef = storageRef.child(`training/${user.uid}/${file.name}`);
  
  const uploadTask = fileRef.put(file);
  
  uploadTask.on('state_changed',
    (snapshot) => {
      // Progress monitoring
      const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
      console.log('Upload is ' + progress + '% done');
    },
    (error) => {
      console.error('Upload failed:', error);
      fileNameDisplay.textContent = 'âŒ Upload failed. Please try again.';
      fileNameDisplay.style.color = '#ef4444';
    },
    () => {
      // Upload completed successfully
      uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
        console.log('File available at', downloadURL);
        fileNameDisplay.textContent += ' (Upload complete)';
        
        // Here you would typically save the PDF reference to Firestore
        savePDFReferenceToFirestore(file.name, downloadURL);
      });
    }
  );
}


// Function to generate flashcards from incorrect answers
async function generateCompetencyFlashcards(quizResults) {
  // 1. Filter incorrect answers grouped by competency
  const incorrectByCompetency = {};
  
  quizResults.questionResults.forEach(question => {
    if (!question.isCorrect) {
      const competency = question.competency || 'General';
      if (!incorrectByCompetency[competency]) {
        incorrectByCompetency[competency] = [];
      }
      incorrectByCompetency[competency].push(question);
    }
  });

  // 2. Generate flashcards for each competency
  const flashcards = [];
  
  for (const [competency, questions] of Object.entries(incorrectByCompetency)) {
    try {
      const competencyFlashcards = await generateFlashcardsWithAI(competency, questions);
      flashcards.push(...competencyFlashcards);
    } catch (error) {
      console.error(`Error generating flashcards for ${competency}:`, error);
      // Fallback to simple flashcards
      questions.forEach(question => {
        flashcards.push({
          competency,
          question: question.text,
          answer: question.correctAnswer,
          explanation: `The correct answer is ${question.correctAnswer} because...`,
          options: question.options
        });
      });
    }
  }

  // 3. Display the generated flashcards
  displayFlashcards(flashcards);
  return flashcards;
}

// AI-powered flashcard generation
async function generateFlashcardsWithAI(competency, questions) {
  const prompt = `Generate 3-5 high quality flashcards for ${competency} competency based on these incorrect answers:
  
  ${questions.map(q => `
    - Question: ${q.text}
      Your answer: ${q.userAnswer}
      Correct answer: ${q.correctAnswer}
  `).join('\n')}

  Format each flashcard as JSON with:
  {
    "competency": "${competency}",
    "question": "clear question focusing on the concept missed",
    "answer": "concise correct answer",
    "explanation": "1-2 sentence explanation of why this is correct",
    "options": ["multiple", "choice", "options", "if applicable"]
  }

  Make questions different from the originals but test the same concept.`;

  const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({
    messages: [{ role: "user", content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt }]
  });

  const data = response.data; const content = data.content;
  
  // Extract JSON from response
  const jsonStart = content.indexOf('[');
  const jsonEnd = content.lastIndexOf(']') + 1;
  return JSON.parse(content.slice(jsonStart, jsonEnd));
}

// Display flashcards in UI
function displayFlashcards(flashcards) {
  const container = document.getElementById('flashcardsContainer');
  container.innerHTML = '';
  
  // Group by competency
  const byCompetency = flashcards.reduce((acc, card) => {
    if (!acc[card.competency]) acc[card.competency] = [];
    acc[card.competency].push(card);
    return acc;
  }, {});

  // Create UI elements
  for (const [competency, cards] of Object.entries(byCompetency)) {
    const competencyHeader = document.createElement('h3');
    competencyHeader.textContent = competency;
    competencyHeader.className = 'competency-header';
    container.appendChild(competencyHeader);

    const cardGrid = document.createElement('div');
    cardGrid.className = 'flashcard-grid';
    
    cards.forEach((card, i) => {
      const flashcard = document.createElement('div');
      flashcard.className = 'flashcard';
      flashcard.innerHTML = `
        <div class="flashcard-front">
          <span class="competency-pill">${card.competency}</span>
          <p>${card.question}</p>
          ${card.options ? `<div class="flashcard-options">${
            card.options.map(opt => `<div>${opt}</div>`).join('')
          }</div>` : ''}
        </div>
        <div class="flashcard-back">
          <h4>Answer</h4>
          <p>${card.answer}</p>
          <div class="flashcard-explanation">
            <h5>Explanation</h5>
            <p>${card.explanation}</p>
          </div>
        </div>
      `;
      flashcard.addEventListener('click', () => {
        flashcard.classList.toggle('flipped');
      });
      cardGrid.appendChild(flashcard);
    });
    
    container.appendChild(cardGrid);
  }
}

function savePDFReferenceToFirestore(filename, url) {
  const user = firebase.auth().currentUser;
  if (!user) return;

  db.collection('trainingDocuments').add({
    userId: user.uid,
    filename: filename,
    url: url,
    uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
    processed: false
  }).then(() => {
    console.log('Document reference saved to Firestore');
  }).catch(error => {
    console.error('Error saving document reference:', error);
  });
}






function createIndividualQuizCard(quiz, cardNumber) {
  const card = document.createElement('div');
  card.className = 'quiz-performance-card';
  card.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border: 1px solid #e5e7eb;
    margin-bottom: 1rem;
  `;

  // Calculate overall performance
  const totalQuestions = quiz.questions ? quiz.questions.length : 0;
  const correctAnswers = quiz.questions ? quiz.questions.filter(q => q.correct).length : 0;
  const overallPercentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;

  // Create header with title and date
  const header = document.createElement('div');
  header.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
  `;



  header.appendChild(title);
  header.appendChild(dateSpan);

  // Create main content container
  const mainContent = document.createElement('div');
  mainContent.style.cssText = `
    display: flex;
    gap: 2rem;
    align-items: flex-start;
  `;

  // Create circular progress and stats section
  const leftSection = document.createElement('div');
  leftSection.style.cssText = `
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
  `;

  // Create circular progress
  const circularProgress = document.createElement('div');
  circularProgress.style.cssText = `
    position: relative;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: conic-gradient(#3b82f6 0deg ${overallPercentage * 3.6}deg, #e5e7eb ${overallPercentage * 3.6}deg 360deg);
    display: flex;
    align-items: center;
    justify-content: center;
  `;

  const innerCircle = document.createElement('div');
  innerCircle.style.cssText = `
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: 600;
    color: #3b82f6;
  `;
  innerCircle.textContent = `${overallPercentage}%`;

  circularProgress.appendChild(innerCircle);

  // Create stats below circle
  const stats = document.createElement('div');
  stats.style.cssText = `
    text-align: center;
  `;

  const correctDiv = document.createElement('div');
  correctDiv.innerHTML = `<strong>Correct</strong> ${correctAnswers}`;
  correctDiv.style.cssText = `
    margin-bottom: 0.25rem;
    color: #1f2937;
  `;

  const incorrectDiv = document.createElement('div');
  incorrectDiv.innerHTML = `<strong>Incorrect</strong> ${totalQuestions - correctAnswers}`;
  incorrectDiv.style.cssText = `
    margin-bottom: 0.25rem;
    color: #1f2937;
  `;

  const skippedDiv = document.createElement('div');
  skippedDiv.innerHTML = `<strong>Skipped</strong> 0`;
  skippedDiv.style.cssText = `
    color: #1f2937;
  `;

  stats.appendChild(correctDiv);
  stats.appendChild(incorrectDiv);
  stats.appendChild(skippedDiv);

  leftSection.appendChild(circularProgress);
  leftSection.appendChild(stats);

  // Group questions by competency
  const competencyGroups = {};
  if (quiz.questions) {
    quiz.questions.forEach(question => {
      const competency = question.competency || 'Other';
      if (!competencyGroups[competency]) {
        competencyGroups[competency] = [];
      }
      competencyGroups[competency].push(question);
    });
  }

  // Create competency sections (right side)
  const competencyContainer = document.createElement('div');
  competencyContainer.style.cssText = `
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  `;

  Object.entries(competencyGroups).forEach(([competency, questions]) => {
    const competencyItem = document.createElement('div');
    competencyItem.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 0;
      border-bottom: 1px solid #e5e7eb;
    `;

    const competencyCorrect = questions.filter(q => q.correct).length;
    const competencyTotal = questions.length;

    const competencyName = document.createElement('span');
    competencyName.textContent = competency;
    competencyName.style.cssText = `
      font-weight: 500;
      color: #1f2937;
    `;

    const competencyStats = document.createElement('span');
    competencyStats.textContent = `${competencyCorrect} / ${competencyTotal}`;
    competencyStats.style.cssText = `
      color: #6b7280;
      font-weight: 500;
    `;

    competencyItem.appendChild(competencyName);
    competencyItem.appendChild(competencyStats);
    competencyContainer.appendChild(competencyItem);
  });

  mainContent.appendChild(leftSection);
  mainContent.appendChild(competencyContainer);

  // Assemble the card
  card.appendChild(header);
  card.appendChild(mainContent);

  return card;
}

function createIndividualQuizCard(quiz, cardNumber) {
  const card = document.createElement('div');
  card.className = 'quiz-performance-card';
  // Apply dark theme styling
  card.style.cssText = `
    background: rgba(30, 41, 59, 0.8);
    border-radius: 12px;
    border: 1px solid rgba(71, 85, 105, 0.5);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.05);
    padding: 24px;
    margin-bottom: 16px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  `;

  // Calculate overall performance
  const totalQuestions = quiz.questions ? quiz.questions.length : 0;
  const correctAnswers = quiz.questions ? quiz.questions.filter(q => q.correct).length : 0;
  const overallPercentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;

  // Determine colors based on performance percentage (matching second image)
  let progressColor, textColor;
  if (overallPercentage <= 20) {
    progressColor = '#DC2626'; // Red for low scores (0-20%)
    textColor = '#f87171';
  } else if (overallPercentage <= 40) {
    progressColor = '#EA580C'; // Orange for medium-low scores (21-40%)
    textColor = '#fb923c';
  } else if (overallPercentage <= 60) {
    progressColor = '#FBBF24'; // Yellow for medium scores (41-60%)
    textColor = '#facc15';
  } else if (overallPercentage <= 80) {
    progressColor = '#eab308'; // Yellow for good scores (61-80%)
    textColor = '#fde047';
  } else {
    progressColor = '#10b981'; // Green for excellent scores (81-100%)
    textColor = '#34d399';
  }
  const cardColor = { progress: progressColor, text: textColor };

  // Create main content container - flex layout matching image
  const mainContent = document.createElement('div');
  mainContent.style.cssText = `
    display: flex;
    gap: 1.5rem;
    align-items: center;
    justify-content: space-between;
  `;

  // Left section: Circular progress and stats
  const leftSection = document.createElement('div');
  leftSection.style.cssText = `
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-shrink: 0;
  `;

  // Create circular progress with SVG
  const circularProgress = document.createElement('div');
  circularProgress.style.cssText = `
    position: relative;
    width: 96px;
    height: 96px;
    display: flex;
    align-items: center;
    justify-content: center;
  `;
  
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', '0 0 100 100');
  svg.setAttribute('class', 'performance-svg');
  svg.style.cssText = 'position: absolute; inset: 0; width: 100%; height: 100%;';
  
  const circleBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circleBg.setAttribute('cx', '50');
  circleBg.setAttribute('cy', '50');
  circleBg.setAttribute('r', '45');
  circleBg.setAttribute('fill', 'none');
  circleBg.setAttribute('stroke', 'rgba(255, 255, 255, 0.2)');
  circleBg.setAttribute('stroke-width', '8');
  
  const circleProgress = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  const circumference = 45 * 2 * Math.PI;
  const offset = circumference - (overallPercentage / 100) * circumference;
  circleProgress.setAttribute('cx', '50');
  circleProgress.setAttribute('cy', '50');
  circleProgress.setAttribute('r', '45');
  circleProgress.setAttribute('fill', 'none');
  circleProgress.setAttribute('stroke', cardColor.progress);
  circleProgress.setAttribute('stroke-width', '8');
  circleProgress.setAttribute('stroke-dasharray', `${circumference} ${circumference}`);
  circleProgress.setAttribute('stroke-dashoffset', offset);
  circleProgress.setAttribute('stroke-linecap', 'round');
  circleProgress.style.transform = 'rotate(-90deg)';
  circleProgress.style.transformOrigin = '50% 50%';
  
  svg.appendChild(circleBg);
  svg.appendChild(circleProgress);
  
  const innerCircle = document.createElement('div');
  innerCircle.style.cssText = `
    position: relative;
    z-index: 1;
    font-size: 1.875rem;
    font-weight: 900;
    color: #fff;
  `;
  innerCircle.textContent = `${overallPercentage}%`;
  
  circularProgress.appendChild(svg);
  circularProgress.appendChild(innerCircle);

  // Stats section (Correct, Incorrect, Skipped)
  const stats = document.createElement('div');
  stats.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  `;

  const correctDiv = document.createElement('p');
  correctDiv.innerHTML = `<strong style="color: #cbd5e1; font-weight: 700;">Correct</strong> <span style="color: #fff;">${correctAnswers}</span>`;
  correctDiv.style.cssText = 'margin: 0;';

  const incorrectDiv = document.createElement('p');
  incorrectDiv.innerHTML = `<strong style="color: #cbd5e1; font-weight: 700;">Incorrect</strong> <span style="color: #fff;">${totalQuestions - correctAnswers}</span>`;
  incorrectDiv.style.cssText = 'margin: 0;';

  const skippedDiv = document.createElement('p');
  skippedDiv.innerHTML = `<strong style="color: #cbd5e1; font-weight: 700;">Skipped</strong> <span style="color: #fff;">0</span>`;
  skippedDiv.style.cssText = 'margin: 0;';

  stats.appendChild(correctDiv);
  stats.appendChild(incorrectDiv);
  stats.appendChild(skippedDiv);

  leftSection.appendChild(circularProgress);
  leftSection.appendChild(stats);

  // Right section: Performance details
  const rightSection = document.createElement('div');
  rightSection.style.cssText = `
    text-align: right;
    flex: 1;
  `;

  const performanceLabel = document.createElement('p');
  performanceLabel.textContent = 'Performance breakdown';
  performanceLabel.style.cssText = `
    color: #94a3b8;
    font-size: 0.875rem;
    margin: 0 0 0.75rem 0;
  `;

  const dateSpan = document.createElement('p');
  if (quiz.completedAt && quiz.completedAt.toDate) {
    dateSpan.textContent = quiz.completedAt.toDate().toLocaleString();
  } else if (quiz.createdAt && quiz.createdAt.toDate) {
    dateSpan.textContent = quiz.createdAt.toDate().toLocaleString();
  } else {
    dateSpan.textContent = new Date().toLocaleString();
  }
  dateSpan.style.cssText = `
    color: #94a3b8;
    font-size: 0.75rem;
    margin: 0 0 0.75rem 0;
  `;

  // Get competency name (first competency from questions or from quiz data)
  let competencyName = 'General';
  if (quiz.competency) {
    competencyName = quiz.competency;
  } else if (quiz.questions && quiz.questions.length > 0 && quiz.questions[0].competency) {
    competencyName = quiz.questions[0].competency;
  }

  const competencyTitle = document.createElement('p');
  competencyTitle.textContent = competencyName;
  competencyTitle.style.cssText = `
    color: #fff;
    font-weight: 700;
    margin: 0 0 0.5rem 0;
    font-size: 1rem;
  `;

  const scoreSpan = document.createElement('p');
  scoreSpan.textContent = `${correctAnswers} / ${totalQuestions}`;
  scoreSpan.style.cssText = `
    color: #cbd5e1;
    font-weight: 700;
    margin: 0;
  `;

  rightSection.appendChild(performanceLabel);
  rightSection.appendChild(dateSpan);
  rightSection.appendChild(competencyTitle);
  rightSection.appendChild(scoreSpan);

  mainContent.appendChild(leftSection);
  mainContent.appendChild(rightSection);

  // Assemble the card
  card.appendChild(mainContent);

  return card;
}

function createIndividualQuizCard(quiz, cardNumber) {
  const card = document.createElement('div');
  card.className = 'quiz-performance-card';
  card.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border: 1px solid #e5e7eb;
    margin-bottom: 1rem;
  `;

  // Calculate overall performance
  const totalQuestions = quiz.questions ? quiz.questions.length : 0;
  const correctAnswers = quiz.questions ? quiz.questions.filter(q => q.correct).length : 0;
  const overallPercentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;

  // Create title
  const title = document.createElement('h3');
  title.textContent = `${quiz.title || `Quiz ${cardNumber}`}`;
  title.style.cssText = `
    margin: 0 0 1rem 0;
    font-size: 1.25rem;
    font-weight: 600;
    color: #1f2937;
  `;

  // Create progress bar (moved under title)
  const progressContainer = document.createElement('div');
  progressContainer.style.cssText = `
    margin-bottom: 1.5rem;
  `;

  const progressLabel = document.createElement('div');
  progressLabel.textContent = `Overall Performance: ${overallPercentage}%`;
  progressLabel.style.cssText = `
    margin-bottom: 0.5rem;
    font-weight: 500;
    color: #374151;
  `;

  const progressBar = document.createElement('div');
  progressBar.style.cssText = `
    width: 100%;
    height: 8px;
    background-color: #e5e7eb;
    border-radius: 4px;
    overflow: hidden;
  `;

  const progressFill = document.createElement('div');
  progressFill.style.cssText = `
    width: ${overallPercentage}%;
    height: 100%;
    background-color: ${overallPercentage >= 70 ? '#10b981' : overallPercentage >= 50 ? '#f59e0b' : '#ef4444'};
    transition: width 0.3s ease;
  `;

  progressBar.appendChild(progressFill);
  progressContainer.appendChild(progressLabel);
  progressContainer.appendChild(progressBar);

  // Group questions by competency
  const competencyGroups = {};
  if (quiz.questions) {
    quiz.questions.forEach(question => {
      const competency = question.competency || 'Other';
      if (!competencyGroups[competency]) {
        competencyGroups[competency] = [];
      }
      competencyGroups[competency].push(question);
    });
  }

  // Create competency sections
  const competencyContainer = document.createElement('div');
  competencyContainer.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  `;

  Object.entries(competencyGroups).forEach(([competency, questions]) => {
    const competencyCard = document.createElement('div');
    competencyCard.style.cssText = `
      background-color: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: 1rem;
    `;

    const competencyCorrect = questions.filter(q => q.correct).length;
    const competencyTotal = questions.length;
    const competencyPercentage = Math.round((competencyCorrect / competencyTotal) * 100);

    const competencyHeader = document.createElement('h4');
    competencyHeader.textContent = competency;
    competencyHeader.style.cssText = `
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
      font-weight: 600;
      color: #1f2937;
    `;

    const competencyStats = document.createElement('div');
    competencyStats.textContent = `${competencyCorrect}/${competencyTotal} correct (${competencyPercentage}%)`;
    competencyStats.style.cssText = `
      font-size: 0.875rem;
      color: ${competencyPercentage >= 70 ? '#059669' : competencyPercentage >= 50 ? '#d97706' : '#dc2626'};
      font-weight: 500;
    `;

    competencyCard.appendChild(competencyHeader);
    competencyCard.appendChild(competencyStats);
    competencyContainer.appendChild(competencyCard);
  });

  // Assemble the card
  card.appendChild(title);
  card.appendChild(progressContainer);
  card.appendChild(competencyContainer);

  return card;
}

function createIndividualQuizCard(quiz, quizNumber) {
  const score = quiz.score || 0;
  const maxScore = quiz.maxScore || quiz.questions?.length || 1;
  const percent = Math.round((score / maxScore) * 100);
  const incorrect = maxScore - score;
  
  const dateObj = quiz.completedAt?.toDate?.() || quiz.createdAt?.toDate?.() || new Date();
  const timeStr = dateObj.toLocaleString();

  // Determine progress color, card gradient, border color, and text color based on performance
  let progressColor, cardGradientFrom, cardGradientTo, borderColor, hoverBorderColor, percentTextColor;
  if (percent <= 20) {
    progressColor = '#DC2626'; // Red for low scores
    cardGradientFrom = 'rgba(127, 29, 29, 0.2)'; // red-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(153, 27, 27, 0.3)'; // red-800/30
    hoverBorderColor = 'rgba(220, 38, 38, 0.5)'; // red-600/50
    percentTextColor = '#f87171'; // red-400
  } else if (percent <= 40) {
    progressColor = '#EA580C'; // Orange for medium-low scores
    cardGradientFrom = 'rgba(154, 52, 18, 0.2)'; // orange-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(154, 52, 18, 0.3)'; // orange-800/30
    hoverBorderColor = 'rgba(234, 88, 12, 0.5)'; // orange-600/50
    percentTextColor = '#fb923c'; // orange-400
  } else if (percent <= 60) {
    progressColor = '#FBBF24'; // Yellow for medium scores
    cardGradientFrom = 'rgba(113, 63, 18, 0.2)'; // yellow-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(133, 77, 14, 0.3)'; // yellow-800/30
    hoverBorderColor = 'rgba(202, 138, 4, 0.5)'; // yellow-600/50
    percentTextColor = '#facc15'; // yellow-400
  } else if (percent <= 80) {
    progressColor = '#eab308'; // Yellow for good scores
    cardGradientFrom = 'rgba(113, 63, 18, 0.2)'; // yellow-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(133, 77, 14, 0.3)'; // yellow-800/30
    hoverBorderColor = 'rgba(202, 138, 4, 0.5)'; // yellow-600/50
    percentTextColor = '#fde047'; // yellow-400
  } else {
    progressColor = '#10b981'; // Green for excellent scores
    cardGradientFrom = 'rgba(20, 83, 45, 0.2)'; // green-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(22, 101, 52, 0.3)'; // green-800/30
    hoverBorderColor = 'rgba(5, 150, 105, 0.5)'; // green-600/50
    percentTextColor = '#34d399'; // green-400
  }

  const cardDiv = document.createElement('div');
  cardDiv.className = 'individual-quiz-card';
  cardDiv.style.cssText = `
    background: linear-gradient(to bottom right, ${cardGradientFrom}, ${cardGradientTo});
    border-radius: 16px;
    border: 1px solid ${borderColor};
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 24px;
    width: 100%;
    margin-bottom: 12px;
    transition: border-color 0.3s;
  `;
  
  // Add hover effect
  cardDiv.addEventListener('mouseenter', () => {
    cardDiv.style.borderColor = hoverBorderColor;
  });
  cardDiv.addEventListener('mouseleave', () => {
    cardDiv.style.borderColor = borderColor;
  });

  // Process competency data for this quiz
  const competencyStats = {};
  
  if (quiz.questionStructure) {
    quiz.questionStructure.forEach((question, index) => {
      const competency = question.competency;
      const questionId = `q${index + 1}`;
      const isCorrect = quiz.userAnswers?.[questionId] === question.correctAnswer;
      
      if (!competencyStats[competency]) {
        competencyStats[competency] = { correct: 0, total: 0 };
      }
      
      competencyStats[competency].total++;
      if (isCorrect) {
        competencyStats[competency].correct++;
      }
    });
  } else if (quiz.competencyStats) {
    Object.assign(competencyStats, quiz.competencyStats);
  } else {
    const allCompetencies = quiz.competencies || [];
    const correctCompetencies = quiz.correctCompetencies || [];
    
    allCompetencies.forEach(c => {
      competencyStats[c] = competencyStats[c] || { correct: 0, total: 0 };
      competencyStats[c].total++;
    });
    
    correctCompetencies.forEach(c => {
      competencyStats[c] = competencyStats[c] || { correct: 0, total: 0 };
      competencyStats[c].correct++;
    });
  }

  const competencyList = Object.entries(competencyStats)
    .map(([comp, { correct, total }]) => `
      <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid rgba(71, 85, 105, 0.3); text-align: right;">
        <span style="color: #fff; font-size: 16px; font-weight: 400; text-align: left;">${comp}</span>
        <span style="color: #e2e8f0; font-size: 16px; font-weight: 500; text-align: right;">${correct} / ${total}</span>
      </div>
    `).join('');

  cardDiv.innerHTML = `
    <!-- Header with title and date - spans full width -->
   

    <!-- Main content: Score circle + stats on left, competencies on right -->
    <div style="display: flex; align-items: center; gap: 32px; width: 100%;">
      <!-- Left side: Score circle and stats side by side -->
      <div style="flex-shrink: 0; display: flex; align-items: center; gap: 24px;">
        <!-- Score Circle -->
        <div style="position: relative; width: 96px; height: 96px; display: flex; align-items: center; justify-content: center;">
          <svg viewBox="0 0 100 100" style="position: absolute; inset: 0; width: 100%; height: 100%;">
            <circle cx="50" cy="50" r="45" fill="none" stroke="#374151" stroke-width="8" />
            <circle
              cx="50"
              cy="50"
              r="45"
              fill="none"
              stroke="${progressColor}"
              stroke-width="8"
              stroke-dasharray="${45 * 2 * Math.PI * (percent / 100)} ${45 * 2 * Math.PI}"
              stroke-linecap="round"
              style="transform: rotate(-90deg); transform-origin: 50% 50%;"
            />
          </svg>
          <span style="position: relative; z-index: 1; font-size: 1.875rem; font-weight: 900; color: ${percentTextColor};">${percent}%</span>
        </div>

        <!-- Stats to the right of circle -->
        <div style="text-align: left;">
          <p style="margin: 0; color: #cbd5e1; font-weight: 700;">Correct <span style="color: #fff;">${score}</span></p>
          <p style="margin: 0; color: #cbd5e1; font-weight: 700;">Incorrect <span style="color: #fff;">${incorrect}</span></p>
          <p style="margin: 0; color: #cbd5e1; font-weight: 700;">Skipped <span style="color: #fff;">0</span></p>
        </div>
      </div>

      <!-- Right side: Competency breakdown -->
      <div style="flex: 1; text-align: right;">
        <p style="margin: 0 0 0.75rem 0; color: #94a3b8; font-size: 0.875rem;">Performance breakdown</p>
        <p style="margin: 0 0 0.75rem 0; color: #94a3b8; font-size: 0.75rem;">${timeStr}</p>
        ${competencyList}
      </div>
    </div>
  `;

  return cardDiv;
}
// Global media recording variables
  
  
    // Tab underline + redirect
    function selectTab(selectedTab) {
      const tabText = selectedTab.textContent.trim();
      if (tabText === "Create") window.location.href = "create.html";
      if (tabText === "Resources") window.location.href = "practice.html";
      if (tabText === "Judging") window.location.href = "judging.html";
  
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      selectedTab.classList.add('active');
  
      const underline = document.querySelector('.tab-underline');
      underline.style.transform = `translateX(${selectedTab.offsetLeft}px)`;
      underline.style.width = `${selectedTab.offsetWidth}px`;
    }
  
    window.addEventListener('load', () => {
      const activeTab = document.querySelector('.tab.active');
      const underline = document.querySelector('.tab-underline');
      if (activeTab && underline) {
        underline.style.transform = `translateX(${activeTab.offsetLeft}px)`;
        underline.style.width = `${activeTab.offsetWidth}px`;
      }
      if (window.feather) feather.replace();
    });

  // Generate questions using OpenAI API
function getQuestionCount(timeString) {
  switch(timeString) {
    case '15 min': return 15;
    case '30 min': return 30;
    case '50 min': return 50;
    default: return 15;
  }
}

function getFallbackQuestions(count, competencies) {
  // Simple fallback questions if GPT fails
  return [
    {
      text: "What is the primary goal of business communication?",
      competency: competencies[0] || "Business Communication",
      correctAnswer: "Clear and effective information exchange",
      options: [
        "Clear and effective information exchange",
        "Using complex terminology",
        "Lengthy detailed explanations",
        "Informal casual language"
      ]
    },
    {
      text: "Which financial statement shows profitability over time?",
      competency: competencies[0] || "Accounting",
      correctAnswer: "Income Statement",
      options: [
        "Income Statement",
        "Balance Sheet",
        "Cash Flow Statement",
        "Trial Balance"
      ]
    }
  ].slice(0, count);
}


function resetForm() {
  document.querySelectorAll('.time-btn.selected').forEach(btn => btn.classList.remove('selected'));
  document.querySelectorAll('.difficulty-btn.selected').forEach(btn => btn.classList.remove('selected'));
  document.querySelectorAll('.competency-option:checked').forEach(checkbox => checkbox.checked = false);
  const simulateCheckbox = document.getElementById('simulate');
  if (simulateCheckbox) {
    simulateCheckbox.checked = false;
  }
}
// Add this new function to get the latest key changes for a competition
async function getLatestKeyChanges(competitionName) {
    if (!competitionName) return null;
    
    try {
        const snapshot = await db.collection('competition-submissions')
            .where('competition', '==', competitionName)
            .orderBy('processedAt', 'desc')
            .limit(1)
            .get();
        
        if (!snapshot.empty) {
            const latestDoc = snapshot.docs[0].data();
            return latestDoc.keyChanges || null;
        }
        
        return null;
    } catch (error) {
        console.error('Error fetching latest key changes:', error);
        return null;
    }
}
// 2. Fix the main generateQuizQuestions function (this is the entry point)
async function generateQuizQuestions() {
      // LINK PDFs FIRST
      const user = firebase.auth().currentUser;
      if (user) {
        try {
          const filesSnap = await db.collection('training').doc(user.uid).collection('files').get();
          const trainingPDFs = [];
          
          filesSnap.forEach(doc => {
            const data = doc.data();
            if (data.name && data.name !== 'undefined') {
              trainingPDFs.push({
                name: data.name,
                path: data.path,
                uploadedAt: data.uploadedAt
              });
            }
          });
          
          const assignmentSnap = await db.collection('assignments')
            .where('userId', '==', user.uid)
            .limit(1)
            .get();
          
          if (!assignmentSnap.empty && trainingPDFs.length > 0) {
            const assignmentId = assignmentSnap.docs[0].id;
            await db.collection('assignments').doc(assignmentId).update({
              trainingPDFs: trainingPDFs
            });
            console.log('âœ… Linked', trainingPDFs.length, 'PDFs to assignment');
          }
        } catch (err) {
          console.error('Error linking PDFs:', err.message);
        }
      }

      showLoading();
  try {
    // Get form data
    const selectedTime = document.querySelector('.time-btn.selected')?.textContent;
    const selectedDifficulty = document.querySelector('.difficulty-btn.selected')?.textContent;
    const selectedCompetencies = Array.from(document.querySelectorAll('.competency-option:checked'))
      .map(checkbox => checkbox.value);
    const simulate = document.getElementById('simulate')?.checked || false;

    // Validation
    if (!selectedTime) {
      alert('Please select a time limit');
      return;
    }
    if (!selectedDifficulty) {
      alert('Please select a difficulty level');
      return;
    }
    if (selectedCompetencies.length === 0) {
      alert('Please select at least one competency');
      return;
    }

    const formData = {
      time: selectedTime,
      difficulty: selectedDifficulty,
      competencies: selectedCompetencies,
      simulate: simulate,
      type: 'written'
    };

    // Show loading state
    const startBtn = document.querySelector('.start-btn');
    const originalText = startBtn.textContent;
    startBtn.textContent = 'Generating Questions...';
    startBtn.disabled = true;

    

    try {
      // Use your AI generation function from the second code
      const questions = await generateQuestionsFromCompetencies(
        selectedCompetencies, 
        getQuestionCount(selectedTime),
        selectedDifficulty,
        formData
      );
      
      // Close setup modal and open quiz modal
      closeWrittenModal();
      startQuiz(questions, formData);
      
      // Reset form
      resetForm();

    } catch (error) {
      console.error('Error creating quiz:', error);
      alert('Error creating quiz: ' + error.message);
    } finally {
      // Reset button
      startBtn.textContent = originalText;
      startBtn.disabled = false;
    }

  } catch (error) {
    console.error('Error in generateQuizQuestions:', error);
    alert('Error creating quiz: ' + error.message);
  }

   setTimeout(() => {
        hideLoading();
        // Rest of your quiz logic
    }, 1000);
}


async function generatePersonalizedTest() {
    // LINK PDFs FIRST
    const user = firebase.auth().currentUser;
    if (user) {
      try {
        const filesSnap = await db.collection('training').doc(user.uid).collection('files').get();
        const trainingPDFs = [];
        
        filesSnap.forEach(doc => {
          const data = doc.data();
          if (data.name && data.name !== 'undefined') {
            trainingPDFs.push({
              name: data.name,
              path: data.path,
              uploadedAt: data.uploadedAt
            });
          }
        });
        
        const assignmentSnap = await db.collection('assignments')
          .where('userId', '==', user.uid)
          .limit(1)
          .get();
        
        if (!assignmentSnap.empty && trainingPDFs.length > 0) {
          const assignmentId = assignmentSnap.docs[0].id;
          await db.collection('assignments').doc(assignmentId).update({
            trainingPDFs: trainingPDFs
          });
          console.log('âœ… Linked', trainingPDFs.length, 'PDFs to assignment');
        }
      } catch (err) {
        console.error('Error linking PDFs:', err.message);
      }
    }

    // Get form data
    const selectedTime = document.querySelector('.time-btn.selected')?.textContent;
    const selectedDifficulty = document.querySelector('.difficulty-btn.selected')?.textContent;
    const selectedCompetencies = Array.from(document.querySelectorAll('.competency-option:checked'))
        .map(checkbox => checkbox.value);

    const btn = document.querySelector('.personalized-btn');
    btn.textContent = 'Generating Test...';

    // Validation
    if (!selectedTime) {
        alert('Please select a time limit');
        return;
    }
    if (!selectedDifficulty) {
        alert('Please select a difficulty level');
        return;
    }
    if (selectedCompetencies.length === 0) {
        alert('Please select at least one competency');
        return;
    }

    const formData = {
        time: selectedTime,
        difficulty: selectedDifficulty,
        competencies: selectedCompetencies,
        simulate: document.getElementById('simulate')?.checked || false,
        type: 'written',
        personalized: true
    };



    try {
        // Get comprehensive user data for personalization
        const userData = await getComprehensiveUserData(selectedCompetencies);
        
        // Determine which competencies to focus on
        let focusCompetencies = await determineFocusCompetencies(
            selectedCompetencies, 
            userData
        );
        
        console.log('Focusing on competencies:', focusCompetencies);
        
        // Adjust difficulty based on performance if needed
        let adjustedDifficulty = selectedDifficulty;
        if (userData.performanceHistory && userData.performanceHistory.weakCompetencies.length > 0) {
            // If focusing on weak areas, start with medium difficulty
            const hasWeakCompetencies = focusCompetencies.some(comp => 
                userData.performanceHistory.weakCompetencies.includes(comp)
            );
            if (hasWeakCompetencies) {
                adjustedDifficulty = 'Medium';
            }
        }

        // Use personalized context for question generation
        const questions = await generatePersonalizedQuestions(
            focusCompetencies,
            getQuestionCount(formData.time),
            adjustedDifficulty,
            userData,
            formData
        );
        
        hideLoading();
        closeWrittenModal();
        startQuiz(questions, formData);

    } catch (error) {
        console.error('Error creating personalized quiz:', error);
        hideLoading();
        
        // Fallback to regular customized test if personalized fails
        alert('Personalized features unavailable. Using standard test instead.');
        generateQuizQuestions();
    }
}

async function getComprehensiveUserData(selectedCompetencies) {
    const user = firebase.auth().currentUser;
    if (!user) return { selectedCompetencies };
    
    try {
        const [performanceHistory, trainingData, userPreferences] = await Promise.all([
            getUserPerformanceHistory(user.uid),
            getUserTrainingData(user.uid),
            getUserCompetencyPreferences(user.uid, selectedCompetencies)
        ]);
        
        return {
            userId: user.uid,
            selectedCompetencies,
            performanceHistory,
            trainingData,
            userPreferences,
            hasTrainingData: !!trainingData,
            hasPerformanceHistory: !!performanceHistory
        };
    } catch (error) {
        console.error('Error getting comprehensive user data:', error);
        return { 
            userId: user.uid,
            selectedCompetencies,
            hasTrainingData: false,
            hasPerformanceHistory: false
        };
    }
}

async function getUserPerformanceHistory(userId) {
    try {
        const assignmentsRef = firebase.firestore().collection('assignments');
        const snapshot = await assignmentsRef
            .where('to', '==', userId)
            .where('status', '==', 'complete')
            .limit(10) // Increased limit for better data
            .get();
        
        if (snapshot.empty) return null;
        
        const competencyPerformance = {};
        const recentQuizzes = [];
        
        snapshot.docs.forEach(doc => {
            const data = doc.data();
            recentQuizzes.push({
                id: doc.id,
                date: data.completedAt || data.createdAt,
                competencyStats: data.competencyStats || {}
            });
            
            if (data.competencyStats) {
                Object.entries(data.competencyStats).forEach(([comp, stats]) => {
                    if (!competencyPerformance[comp]) {
                        competencyPerformance[comp] = { correct: 0, total: 0, attempts: 0 };
                    }
                    competencyPerformance[comp].correct += stats.correct || 0;
                    competencyPerformance[comp].total += stats.total || 0;
                    competencyPerformance[comp].attempts += 1;
                });
            }
        });
        
        // Calculate performance percentages and identify weak areas
        const weakCompetencies = [];
        const competencyPercentages = {};
        
        Object.entries(competencyPerformance).forEach(([comp, stats]) => {
            if (stats.total > 0) {
                const percentage = (stats.correct / stats.total) * 100;
                competencyPercentages[comp] = percentage;
                
                // Consider competency weak if less than 70% correct AND at least 3 attempts
                if (percentage < 70 && stats.attempts >= 3) {
                    weakCompetencies.push(comp);
                }
            }
        });
        
        // Sort by performance (worst first)
        weakCompetencies.sort((a, b) => 
            (competencyPercentages[a] || 100) - (competencyPercentages[b] || 100)
        );
        
        return {
            competencyPerformance,
            competencyPercentages,
            weakCompetencies,
            recentQuizzes,
            totalQuizzes: snapshot.docs.length
        };
        
    } catch (error) {
        console.error('Error getting user performance:', error);
        return null;
    }
}

async function getUserTrainingData(userId) {
    try {
        const userTrainingRef = firebase.firestore().collection('UserTraining');
        const doc = await userTrainingRef.doc(userId).get();
        
        if (doc.exists) {
            return doc.data();
        }
        return null;
    } catch (error) {
        console.error('Error getting user training data:', error);
        return null;
    }
}

async function getUserCompetencyPreferences(userId, selectedCompetencies) {
    try {
        // You might store user preferences in a separate collection
        const prefsRef = firebase.firestore().collection('userPreferences');
        const doc = await prefsRef.doc(userId).get();
        
        if (doc.exists) {
            const data = doc.data();
            // Return preferences that match currently selected competencies
            return {
                favoriteCompetencies: (data.favoriteCompetencies || []).filter(comp => 
                    selectedCompetencies.includes(comp)
                ),
                avoidedCompetencies: (data.avoidedCompetencies || []).filter(comp => 
                    selectedCompetencies.includes(comp)
                ),
                customWeights: data.competencyWeights || {}
            };
        }
        return {
            favoriteCompetencies: [],
            avoidedCompetencies: [],
            customWeights: {}
        };
    } catch (error) {
        console.error('Error getting user preferences:', error);
        return {
            favoriteCompetencies: [],
            avoidedCompetencies: [],
            customWeights: {}
        };
    }
}

async function determineFocusCompetencies(selectedCompetencies, userData) {
    let focusCompetencies = [...selectedCompetencies];
    
    // If we have performance data, prioritize weak areas
    if (userData.performanceHistory && userData.performanceHistory.weakCompetencies.length > 0) {
        const weakInSelected = userData.performanceHistory.weakCompetencies.filter(comp => 
            selectedCompetencies.includes(comp)
        );
        
        if (weakInSelected.length > 0) {
            // Include all selected competencies, but ensure weak ones are included
            // You could also weight distribution here
            console.log('Weak competencies in selection:', weakInSelected);
            
            // Optional: If many weak competencies, focus only on them
            if (weakInSelected.length >= selectedCompetencies.length / 2) {
                focusCompetencies = weakInSelected;
            }
        }
    }
    
    // Apply user preferences if available
    if (userData.userPreferences) {
        // Ensure favorite competencies are included
        userData.userPreferences.favoriteCompetencies.forEach(comp => {
            if (selectedCompetencies.includes(comp) && !focusCompetencies.includes(comp)) {
                focusCompetencies.push(comp);
            }
        });
        
        // Remove avoided competencies
        focusCompetencies = focusCompetencies.filter(comp => 
            !userData.userPreferences.avoidedCompetencies.includes(comp)
        );
    }
    
    // Limit to reasonable number based on test length
    const maxCompetencies = Math.min(focusCompetencies.length, 5);
    return focusCompetencies.slice(0, maxCompetencies);
}

async function generatePersonalizedQuestions(competencies, count, difficulty, userData, formData) {
    // Add personalization context to the formData
    const personalizedFormData = {
        ...formData,
        personalizationContext: {
            userId: userData.userId,
            weakCompetencies: userData.performanceHistory?.weakCompetencies || [],
            hasTrainingData: userData.hasTrainingData,
            userPreferences: userData.userPreferences
        }
    };
    
    // Use your existing question generator but with personalized context
    return await generateQuestionsFromCompetencies(
        competencies, 
        count, 
        difficulty, 
        personalizedFormData
    );
}
// 3. ADD THIS NEW FUNCTION:
// Add this new function first
async function getLatestKeyChanges(competitionName) {
    if (!competitionName) return null;
    
    try {
        const snapshot = await db.collection('competition-submissions')
            .where('competition', '==', competitionName)
            .orderBy('processedAt', 'desc')
            .limit(1)
            .get();
        
        if (!snapshot.empty) {
            const latestDoc = snapshot.docs[0].data();
            return latestDoc.keyChanges || null;
        }
        
        return null;
    } catch (error) {
        console.error('Error fetching latest key changes:', error);
        return null;
    }
}

// Modified main function
async function generatePersonalizedQuestionsWithGPT(formData) {
  const apiKey = "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";
  
  const questionCount = getQuestionCount(formData.time);
  const competenciesText = formData.competencies.join(', ');
  
  // Get training data from Firebase (using existing parameter structure)
  const selectedCompetition = document.getElementById('competitionSelectWritten')?.value;
  const trainingData = await getAllTrainingEntries(selectedCompetition);

  // Get latest key changes for this competition
  const latestKeyChanges = await getLatestKeyChanges(selectedCompetition);
  
  // Get dynamic competencies from latest submission
  const dynamicCompetencies = await getCompetenciesFromLatestSubmission(selectedCompetition);
  
  if (!trainingData || !trainingData.pdfContent) {
    console.log('No training data available, using fallback questions');
    return getFallbackQuestions(questionCount, formData.competencies);
  }
  
  // Build context-aware prompt - let AI determine competencies from content
  let prompt = `Generate ${questionCount} FBLA multiple choice questions using concepts from the study material, but make each question completely standalone.

CRITICAL REQUIREMENTS:
- Difficulty: ${formData.difficulty}
- Target competencies: ${competenciesText}
- Each question must have exactly 4 options
- Extract concepts from the study material but create original standalone questions
- Make questions realistic for FBLA competitions
- YOU must determine which FBLA competency each question belongs to based on the content`;

  // Add key changes to prompt if available
  if (latestKeyChanges) {
    prompt += `\n\nIMPORTANT RECENT CHANGES TO CONSIDER:
${latestKeyChanges}
Please incorporate these changes/updates when creating questions.`;
  }

  prompt += `\n\nABSOLUTE RULES - NEVER VIOLATE THESE:
- FORBIDDEN PHRASES: "the agreement", "the document", "the passage", "according to", "as stated", "mentioned above", "the text", "as specified", "the contract", "this document", "the material", "the content", "as outlined", "as described"
- NEVER ask what documents say, specify, outline, or contain
- DO use specific names, places, companies, activities, amounts, dates directly from the content
- Present specific details as if they are established facts, not as sourced from a document
- Ask about the specific things mentioned, not about what was mentioned

DIFFICULTY GUIDELINES:
- Easy: Straightforward definitions, basic concepts, obvious answers
- Medium: Application of concepts, moderate analysis, some calculation or reasoning required
- Hard: Complex scenarios, multiple concepts combined, requires deep understanding, tricky distractors that seem plausible

Study Material (USE CONCEPTS ONLY, DON'T REFERENCE):
${trainingData.pdfContent.substring(0, 5000)}`;

  // Add existing questions as style examples
  if (trainingData.userQuestions.length > 0) {
    prompt += `\n\nExample Question Style (note how they don't reference external material):`;
    trainingData.userQuestions.slice(0, 2).forEach((q, i) => {
      prompt += `\n${i + 1}. ${q.text}`;
    });
  }

  // Use dynamic competencies if available, otherwise use default FBLA competencies
  if (dynamicCompetencies.length > 0) {
    prompt += `\n\nAnalyze the study material concepts and create questions that naturally fit these specific competencies extracted from the latest submission:
${dynamicCompetencies.map(comp => `- ${comp}`).join('\n')}`;
  } else {
    prompt += `\n\nAnalyze the study material concepts and create questions that naturally fit these FBLA competencies:
- Business Communication
- Marketing
- Accounting
- Economics
- Business Law
- Management
- Entrepreneurship
- Finance
- International Business
- Business Ethics
- Parliamentary Procedure`;
  }

  prompt += `\n\nEXAMPLES - USE SPECIFIC CONTENT DIRECTLY WITHOUT REFERENCING THE SOURCE:

âŒ FORBIDDEN: "What is the role of the Club in the Activities as specified in the agreement?"
âœ… CORRECT: "What is San Jose Sharks' primary responsibility regarding participant safety during ice skating activities?"

âŒ FORBIDDEN: "According to the document, what venue is mentioned?"
âœ… CORRECT: "What safety requirements must be met at San Jose Arena for ice skating activities?"

âŒ FORBIDDEN: "The agreement states activities include which of the following?"
âœ… CORRECT: "Which of the following activities are typically included in ice skating programs: warm-ups, drills, games, or spectating?"

âŒ FORBIDDEN: "As outlined in the contract, what are the liability provisions?"
âœ… CORRECT: "What types of injuries would be covered under a comprehensive liability waiver for ice skating, gym activities, and athletic field exercises?"

âŒ FORBIDDEN: "The document mentions compensation. What does it specify?"
âœ… CORRECT: "What is the standard compensation structure for participants in recreational ice skating programs?"

USE the specific details (San Jose Sharks, ice skating, specific activities, etc.) but ask about them directly, not about what the document says about them.`;

  prompt += `\n\nReturn ONLY a JSON array in this exact format:
[
  {
    "text": "Question text here?",
    "competency": "Business Communication",
    "correctAnswer": "Correct option text",
    "options": ["Option A", "Option B", "Option C", "Option D"],
    "difficulty": "${formData.difficulty}",
    "source": "training_content"
  }
]`;

  try {
    const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({messages: [
          {
            role: 'system',
            content: `You are an expert FBLA written-competition exam designer.

Your role is to generate ORIGINAL, competition-accurate FBLA-style multiple-choice questions that match the structure, rigor, tone, and professional standards of official FBLA written tests.

You must follow ALL rules below.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE FBLA PHILOSOPHY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FBLA written tests assess professional correctness, precision, and applied business literacy.

They do NOT assess creativity, opinion, or open-ended reasoning.

Each question must test exactly ONE concept.

Questions must be concise, objective, and professionally worded.

Avoid unnecessary narrative unless the question type explicitly requires a scenario.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
APPROVED FBLA QUESTION ARCHETYPES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Every question MUST clearly belong to ONE of the following archetypes:

1. Definition / Term Identification  
   - Identifying the correct term based on a definition  
   - Selecting the correct meaning of a professional word or concept  

2. Classification / Category Recognition  
   - Determining where an item belongs within a professional category system  
   - Examples include document types, account categories, system types, business forms, or classifications  

3. Procedural / Workflow Knowledge  
   - Understanding the stages of a professional workflow specific to the competition area  
   - Identifying where information originates within that workflow  
   - Determining which document, tool, or action is appropriate at a given stage  
   - Recognizing correct sequencing of professional tasks within the domain  

4. Tool-to-Function Matching  
   - Matching software features, commands, utilities, or tools to their correct purpose  
   - Selecting the correct function used to accomplish a professional task  

5. Quantitative / Calculation Application  
   - Performing single-step or limited multi-step calculations  
   - Selecting the correct numeric result based on provided data  
   - Avoid unnecessary complexity or advanced math  

6. Language Precision & Usage  
   - Correct use of professional vocabulary  
   - Distinguishing homophones, word meanings, spelling, grammar, and standard usage  

7. Error Detection / Exception Identification  
   - Identifying what is incorrect, misspelled, or does NOT belong  
   - Using negation ("NOT") carefully and intentionally  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUESTION STRUCTURE RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Each question must assess ONE idea only.  
â€¢ Do not combine multiple concepts in one question.  
â€¢ Avoid ambiguous wording.  
â€¢ Use professional, neutral language.

Acceptable stem styles include:
- "Which of the followingâ€¦"
- "What term best describesâ€¦"
- "The document used toâ€¦"
- "Which action should be takenâ€¦"
- "Which of the following is NOTâ€¦"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ANSWER CHOICE DESIGN (CRITICAL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Each question MUST include exactly FOUR answer choices.

Answer choices must:
â€¢ Be the same grammatical form  
â€¢ Be similar in length  
â€¢ Belong to the same conceptual family  

Wrong answer choices (distractors) must be plausible and realistic.

Allowed distractor strategies include:
â€¢ Closely related terms within the same category  
â€¢ Common student misconceptions  
â€¢ Incorrect step within a workflow  
â€¢ Reversed or misapplied professional rules  
â€¢ Visually or linguistically similar words  
â€¢ Typical calculation or classification errors  

Never include joke answers or obviously incorrect options.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIFFICULTY CALIBRATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Easy:
â€¢ Direct recall or recognition  
â€¢ Minimal traps  

Medium:
â€¢ Requires discrimination between similar concepts  
â€¢ Includes common misconceptions  

Hard:
â€¢ Includes negation ("NOT")  
â€¢ Requires precise rule awareness  
â€¢ Uses subtle wording differences  
â€¢ Penalizes shallow memorization  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONTENT INTEGRITY RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All questions must be ORIGINAL.  
â€¢ Do NOT copy real FBLA questions.  
â€¢ Do NOT closely paraphrase known questions.  
â€¢ Use authentic structure only, not replicated wording.

Questions must feel realistic for competitive FBLA written events at the regional, state, or national level.

When study materials are provided, extract concepts, facts, names, dates, laws, and details from them. Present this information as established business knowledge. NEVER mention "the study guide", "the document", "the material", or use phrases like "according to", "as stated in", or "mentioned in".

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OUTPUT REQUIREMENTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Generate ONLY the requested number of questions.  
â€¢ Each question must have exactly four answer options.  
â€¢ Only ONE option may be correct.  
â€¢ Output valid JSON only.  
â€¢ Do not include explanations, commentary, or headings.  

You are writing as a professional exam author â€” not as a tutor or teacher.`
          },
          {
            role: 'user',
            content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt
          }
        ], temperature: 0.7, max_tokens: 4000});

    if (!response.ok) {
      throw new Error(`API Error: ${response.status} - ${response.statusText}`);
    }

    const data = response.data; let content = data.content.trim();
    
    // Clean JSON formatting
    content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    
    const generatedQuestions = JSON.parse(content);
    
    // Validate and sort questions
    const validatedQuestions = validateAndSortQuestions(generatedQuestions, formData);
    
    return validatedQuestions;

  } catch (error) {
    console.error('Enhanced GPT Error:', error);
    
    // Fallback to existing user questions if API fails
    if (trainingData.userQuestions.length > 0) {
      return trainingData.userQuestions.slice(0, questionCount);
    } else {
      return getFallbackQuestions(questionCount, formData.competencies);
    }
  }
}

async function getAllTrainingEntries(selectedCompetition) {
    const userId = getCurrentUserId();
    
    try {
        // Get all entries from the entries subcollection
        const entriesSnapshot = await db.collection('userTraining')
            .doc(userId)
            .collection('entries')
            .get();
        
        let combinedContent = '';
        let allUserQuestions = [];
        
        // Process each entry
        entriesSnapshot.forEach(doc => {
            const data = doc.data();
            
            // Filter by competition if specified (or include all if 'general' or no filter)
            if (!selectedCompetition || selectedCompetition === 'general' || data.competition === selectedCompetition) {
                // Combine PDF content
                if (data.content) {
                    combinedContent += data.content + '\n\n';
                }
                
                // Combine user questions
                if (data.userQuestions && Array.isArray(data.userQuestions)) {
                    allUserQuestions = allUserQuestions.concat(data.userQuestions);
                }
            }
        });
        
        // Also check old trainingEntries subcollection for backwards compatibility
        const trainingEntriesSnapshot = await db.collection('userTraining')
            .doc(userId)
            .collection('trainingEntries')
            .get();
            
        trainingEntriesSnapshot.forEach(doc => {
            const data = doc.data();
            
            if (!selectedCompetition || selectedCompetition === 'general' || data.competition === selectedCompetition) {
                if (data.content) {
                    combinedContent += data.content + '\n\n';
                }
                
                if (data.userQuestions && Array.isArray(data.userQuestions)) {
                    allUserQuestions = allUserQuestions.concat(data.userQuestions);
                }
            }
        });
        
        console.log(`Found ${entriesSnapshot.size + trainingEntriesSnapshot.size} total entries`);
        console.log(`Combined content length: ${combinedContent.length} characters`);
        console.log(`Total user questions: ${allUserQuestions.length}`);
        
        return {
            pdfContent: combinedContent.trim(),
            userQuestions: allUserQuestions
        };
        
    } catch (error) {
        console.error('Error getting all training entries:', error);
        return {
            pdfContent: '',
            userQuestions: []
        };
    }
}


function startQuiz(questions, formData) {
  // If this is a written practice, set window.writtenQuestions
  if (formData.type === 'written') {
    window.writtenQuestions = questions;
    window.writtenAnswers = {};
    currentQuestionIndex = 0;
    writtenAnswers = {};
    
    // Calculate time
    const timeInMinutes = parseInt(formData.time) || 15;
    writtenTimeRemaining = timeInMinutes * 60;
    
    // Setup quiz modal
    document.getElementById('quizTitle').textContent = `${formData.difficulty} ${formData.type} Practice`;
    
    // Create stars for quiz modal
    createQuizStars();
    
    // Show quiz modal
    document.getElementById('quizModal').style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
    // Load first question and start timer
    loadWrittenQuestion();
    startWrittenTimer();
  } else {
    // Regular quiz flow
  currentQuiz = {
    questions: questions,
    settings: formData,
    startTime: new Date()
  };
  
  currentQuestionIndex = 0;
  userAnswers = {};
  quizStartTime = Date.now();
  
  // Setup quiz modal
  document.getElementById('quizTitle').textContent = `${formData.difficulty} ${formData.type} Practice`;
  
  // Start timer if needed
  if (formData.time) {
    startQuizTimer(formData.time);
  }
  
  // Load first question
  loadQuestion(0);
  
  // Create stars for quiz modal
  createQuizStars();
  
  // Show quiz modal
  document.getElementById('quizModal').style.display = 'flex';
  document.body.style.overflow = 'hidden';
  }
}

// Load question into modal
function loadQuestion(index) {
  const question = currentQuiz.questions[index];
  const totalQuestions = currentQuiz.questions.length;
  
  // Update progress
  document.getElementById('quizProgress').textContent = `Question ${index + 1} of ${totalQuestions}`;
  const progressPercent = Math.round(((index + 1) / totalQuestions) * 100);
  document.getElementById('progressFill').style.width = `${progressPercent}%`;
  const progressPercentEl = document.getElementById('progressPercent');
  if (progressPercentEl) {
    progressPercentEl.textContent = progressPercent;
  }
  
  // Update question content
  document.getElementById('questionCompetency').textContent = question.competency || 'General';
  document.getElementById('questionText').textContent = question.text || question.question || 'Loading question...';
  
  // Create options
  const optionsContainer = document.getElementById('optionsContainer');
  optionsContainer.innerHTML = '';
  
  question.options.forEach((option, optionIndex) => {
    const optionButton = document.createElement('button');
    optionButton.className = 'practice-quiz-option-btn';
    optionButton.type = 'button';
    optionButton.setAttribute('data-option-index', optionIndex);
    optionButton.setAttribute('data-question-index', index);
    
    // Check if this option was previously selected
    const isSelected = userAnswers[`q${index}`] === option;
    if (isSelected) {
      optionButton.classList.add('selected');
    }
    
    optionButton.innerHTML = `
      <div class="practice-quiz-option-radio ${isSelected ? 'selected' : ''}">
        ${isSelected ? '<div class="practice-quiz-option-dot"></div>' : ''}
      </div>
      <span class="practice-quiz-option-text">${option}</span>
    `;
    
    // Add click handler - prevent multiple selections
    optionButton.addEventListener('click', (event) => {
      // Only allow selection if not already selected
      if (!optionButton.classList.contains('selected')) {
        selectOption(event, optionIndex, option, index);
      }
    });
    
    optionsContainer.appendChild(optionButton);
  });
  
  // Update navigation buttons
  document.getElementById('prevBtn').disabled = index === 0;
  document.getElementById('nextBtn').style.display = index === totalQuestions - 1 ? 'none' : 'block';
  document.getElementById('submitBtn').style.display = index === totalQuestions - 1 ? 'block' : 'none';
}

function selectOption(event, optionIndex, optionText, questionIndex) {
  // Prevent event bubbling and default behavior
  event.stopPropagation();
  event.preventDefault();
  
  // Get the question index
  const qIndex = questionIndex !== undefined ? questionIndex : currentQuestionIndex;
  
  // Remove previous selection from all options in this question
  const optionsContainer = event.currentTarget.parentElement;
  const options = optionsContainer.querySelectorAll('.practice-quiz-option-btn');
  
  options.forEach(option => {
    option.classList.remove('selected');
    const radio = option.querySelector('.practice-quiz-option-radio');
    const dot = option.querySelector('.practice-quiz-option-dot');
    if (radio) {
      radio.classList.remove('selected');
    }
    if (dot) {
      dot.remove();
    }
  });

  // Add selection to clicked option only
  event.currentTarget.classList.add('selected');
  
  // Update the radio button visual
  const radio = event.currentTarget.querySelector('.practice-quiz-option-radio');
  if (radio) {
    radio.classList.add('selected');
    if (!radio.querySelector('.practice-quiz-option-dot')) {
      const dot = document.createElement('div');
      dot.className = 'practice-quiz-option-dot';
      radio.appendChild(dot);
    }
  }

  // Store answer - only one answer per question
  userAnswers[`q${qIndex}`] = optionText;
  
  // Enable next button if not already enabled
  const nextBtn = document.getElementById('nextBtn');
  if (nextBtn && nextBtn.disabled) {
    nextBtn.disabled = false;
  }
}


function nextQuestion() {
  // Check if this is a written practice - prioritize window.writtenQuestions (for "create your own")
  const questions = (window.writtenQuestions && window.writtenQuestions.length > 0) ? window.writtenQuestions : 
                   (writtenQuestions && writtenQuestions.length > 0) ? writtenQuestions : null;
  
  if (questions) {
    if (currentQuestionIndex < questions.length - 1) {
      currentQuestionIndex++;
      loadWrittenQuestion();
    }
  } else if (currentQuiz && currentQuiz.questions) {
  if (currentQuestionIndex < currentQuiz.questions.length - 1) {
    currentQuestionIndex++;
    loadQuestion(currentQuestionIndex);
    }
  }
}

function previousQuestion() {
  // Check if this is a written practice - prioritize window.writtenQuestions (for "create your own")
  const questions = (window.writtenQuestions && window.writtenQuestions.length > 0) ? window.writtenQuestions : 
                   (writtenQuestions && writtenQuestions.length > 0) ? writtenQuestions : null;
  
  if (questions) {
    if (currentQuestionIndex > 0) {
      currentQuestionIndex--;
      loadWrittenQuestion();
    }
  } else if (currentQuiz && currentQuiz.questions) {
  if (currentQuestionIndex > 0) {
    currentQuestionIndex--;
    loadQuestion(currentQuestionIndex);
    }
  }
}

// Submit quiz
async function submitQuiz() {
    // Check if this is a written practice assignment - check both window.writtenQuestions (for "create your own") and local writtenQuestions
    const hasWrittenQuestions = (window.writtenQuestions && window.writtenQuestions.length > 0) || 
                                (writtenQuestions && writtenQuestions.length > 0);
    
    if (hasWrittenQuestions) {
      // For "create your own" tests, we might not have window.latestAssignmentId, so handle both cases
      if (window.latestAssignmentId) {
        // This is from a notification assignment
        await submitWrittenPractice();
        return;
      } else {
        // This is a "create your own" test - submit it without assignment ID
        await submitWrittenPracticeForCreateYourOwn();
        return;
      }
    }

    if (hasResultsBeenShown) return;
    hasResultsBeenShown = true;

   if (!currentQuiz) {
        alert('Error: No quiz data found. Please start a new quiz.');
        return;
    }

  if (quizTimer) {
    clearInterval(quizTimer);
  }
  
  // Calculate results
  quizResults = calculateQuizResults();
  
  // Save to Firebase FIRST
  try {
    console.log('Saving quiz results...');
    await saveQuizResultsToFirebase(quizResults);
    console.log('Quiz results saved successfully!');
    
    // Force a reload of the quiz cards from Firebase
    await reloadQuizCardsFromFirebase();
    
  } catch (error) {
    console.error('Error saving quiz results:', error);
    alert('Warning: Quiz results may not have been saved properly.');
  }
  
  // Close quiz modal and show results
  closeQuizModal();
  showQuizResults(quizResults);

     setTimeout(() => {
        hasResultsBeenShown = false;
    }, 3000);

}

async function reloadQuizCardsFromFirebase() {
  const user = firebase.auth().currentUser;
  if (!user) return;
  
  try {
    console.log('Reloading quiz cards from Firebase...');
    
    const assignmentsRef = firebase.firestore().collection('assignments');
    const snapshot = await assignmentsRef
      .where('to', '==', user.uid)
      .where('type', 'in', ['written', 'quiz'])
      .where('status', '==', 'complete')
      .orderBy('createdAt', 'desc')
      .get();
    
    if (snapshot.empty) {
      console.log('No quiz results found');
      return;
    }
    
    const allQuizzes = snapshot.docs.map(doc => {
      const data = doc.data();
      console.log('Quiz data from Firebase:', data);
      return data;
    });
    
    // Clear existing quiz container
    const existingContainer = document.querySelector('.quiz-container');
    if (existingContainer) {
      existingContainer.remove();
    }
    
    // Hide the original performance section
    const originalPerformanceSection = document.querySelector('.performance-section');
    if (originalPerformanceSection) {
      originalPerformanceSection.style.display = 'none';
    }
    
    // Create a new container for all quiz cards
    const quizContainer = document.createElement('div');
    quizContainer.className = 'quiz-container';
    quizContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      margin-top: 2rem;
    `;
    
    // Create individual quiz cards
    allQuizzes.forEach((quiz, index) => {
      const quizCard = createIndividualQuizCard(quiz, index + 1);
      quizContainer.appendChild(quizCard);
    });
    
    // Insert the quiz container into the performance cards container
    const performanceContainer = document.getElementById('performanceCardsContainer');
    if (performanceContainer) {
      performanceContainer.innerHTML = ''; // Clear existing
      performanceContainer.appendChild(quizContainer);
    } else {
      // Fallback to old method if container doesn't exist
      const createExamCard = document.querySelector('.create-practice-card');
      if (createExamCard) {
        createExamCard.parentNode.insertBefore(quizContainer, createExamCard.nextSibling);
      }
    }
    
    console.log('Quiz cards reloaded successfully');
    
  } catch (error) {
    console.error('Error reloading quiz cards:', error);
  }
}



function createQuizResultCard(results) {
  const quizContainer = document.querySelector('.quiz-container') || document.createElement('div');
  quizContainer.className = 'quiz-container';
  quizContainer.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    margin-top: 2rem;
  `;
  
  // Hide original performance section if it exists
  const performanceSection = document.querySelector('.performance-section');
  if (performanceSection) {
    performanceSection.style.display = 'none';
  }
  
  // Create the card using the EXACT same structure as createIndividualQuizCard
  const card = createIndividualQuizCardFromResults(results, 1);
  
  quizContainer.prepend(card);
  
  // Insert the quiz container into the performance cards container
  const performanceContainer = document.getElementById('performanceCardsContainer');
  if (performanceContainer) {
    performanceContainer.prepend(quizContainer);
  } else {
    // Fallback to old method if container doesn't exist
    const createExamCard = document.querySelector('.create-practice-card');
    if (createExamCard) {
      createExamCard.parentNode.insertBefore(quizContainer, createExamCard.nextSibling);
    }
  }
}

// New function that creates a card using the EXACT same structure as your existing createIndividualQuizCard
function createIndividualQuizCardFromResults(results, quizNumber) {
  const score = results.correct;
  const maxScore = results.total;
  const percent = results.percentage;
  const incorrect = results.incorrect;
  
  const timeStr = new Date().toLocaleString();

  // Determine progress color, card gradient, border color, and text color based on performance
  let progressColor, cardGradientFrom, cardGradientTo, borderColor, hoverBorderColor, percentTextColor;
  if (percent <= 20) {
    progressColor = '#DC2626'; // Red for low scores
    cardGradientFrom = 'rgba(127, 29, 29, 0.2)'; // red-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(153, 27, 27, 0.3)'; // red-800/30
    hoverBorderColor = 'rgba(220, 38, 38, 0.5)'; // red-600/50
    percentTextColor = '#f87171'; // red-400
  } else if (percent <= 40) {
    progressColor = '#EA580C'; // Orange for medium-low scores
    cardGradientFrom = 'rgba(154, 52, 18, 0.2)'; // orange-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(154, 52, 18, 0.3)'; // orange-800/30
    hoverBorderColor = 'rgba(234, 88, 12, 0.5)'; // orange-600/50
    percentTextColor = '#fb923c'; // orange-400
  } else if (percent <= 60) {
    progressColor = '#FBBF24'; // Yellow for medium scores
    cardGradientFrom = 'rgba(113, 63, 18, 0.2)'; // yellow-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(133, 77, 14, 0.3)'; // yellow-800/30
    hoverBorderColor = 'rgba(202, 138, 4, 0.5)'; // yellow-600/50
    percentTextColor = '#facc15'; // yellow-400
  } else if (percent <= 80) {
    progressColor = '#eab308'; // Yellow for good scores
    cardGradientFrom = 'rgba(113, 63, 18, 0.2)'; // yellow-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(133, 77, 14, 0.3)'; // yellow-800/30
    hoverBorderColor = 'rgba(202, 138, 4, 0.5)'; // yellow-600/50
    percentTextColor = '#fde047'; // yellow-400
  } else {
    progressColor = '#10b981'; // Green for excellent scores
    cardGradientFrom = 'rgba(20, 83, 45, 0.2)'; // green-900/20
    cardGradientTo = 'rgba(0, 0, 0, 1)'; // black
    borderColor = 'rgba(22, 101, 52, 0.3)'; // green-800/30
    hoverBorderColor = 'rgba(5, 150, 105, 0.5)'; // green-600/50
    percentTextColor = '#34d399'; // green-400
  }

  const cardDiv = document.createElement('div');
  cardDiv.className = 'individual-quiz-card';
  cardDiv.style.cssText = `
    background: linear-gradient(to bottom right, ${cardGradientFrom}, ${cardGradientTo});
    border-radius: 16px;
    border: 1px solid ${borderColor};
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 24px;
    width: 100%;
    margin-bottom: 12px;
    transition: border-color 0.3s;
  `;
  
  // Add hover effect
  cardDiv.addEventListener('mouseenter', () => {
    cardDiv.style.borderColor = hoverBorderColor;
  });
  cardDiv.addEventListener('mouseleave', () => {
    cardDiv.style.borderColor = borderColor;
  });

  // Convert results.competencyStats to match the expected format
  const competencyStats = {};
  Object.entries(results.competencyStats).forEach(([comp, stats]) => {
    competencyStats[comp] = {
      correct: stats.correct,
      total: stats.total
    };
  });

  const competencyList = Object.entries(competencyStats)
    .map(([comp, { correct, total }]) => `
      <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid rgba(71, 85, 105, 0.3); text-align: right;">
        <span style="color: #fff; font-size: 16px; font-weight: 400; text-align: left;">${comp}</span>
        <span style="color: #e2e8f0; font-size: 16px; font-weight: 500; text-align: right;">${correct} / ${total}</span>
      </div>
    `).join('');

  cardDiv.innerHTML = `
    <!-- Main content: Score circle + stats on left, competencies on right -->
    <div style="display: flex; align-items: center; gap: 32px; width: 100%;">
      <!-- Left side: Score circle and stats side by side -->
      <div style="flex-shrink: 0; display: flex; align-items: center; gap: 24px;">
        <!-- Score Circle -->
        <div style="position: relative; width: 96px; height: 96px; display: flex; align-items: center; justify-content: center;">
          <svg viewBox="0 0 100 100" style="position: absolute; inset: 0; width: 100%; height: 100%;">
            <circle cx="50" cy="50" r="45" fill="none" stroke="#374151" stroke-width="8" />
            <circle
              cx="50"
              cy="50"
              r="45"
              fill="none"
              stroke="${progressColor}"
              stroke-width="8"
              stroke-dasharray="${45 * 2 * Math.PI * (percent / 100)} ${45 * 2 * Math.PI}"
              stroke-linecap="round"
              style="transform: rotate(-90deg); transform-origin: 50% 50%;"
            />
          </svg>
          <span style="position: relative; z-index: 1; font-size: 1.875rem; font-weight: 900; color: ${percentTextColor};">${percent}%</span>
        </div>

        <!-- Stats to the right of circle -->
        <div style="text-align: left;">
          <p style="margin: 0; color: #cbd5e1; font-weight: 700;">Correct <span style="color: #fff;">${score}</span></p>
          <p style="margin: 0; color: #cbd5e1; font-weight: 700;">Incorrect <span style="color: #fff;">${incorrect}</span></p>
          <p style="margin: 0; color: #cbd5e1; font-weight: 700;">Skipped <span style="color: #fff;">0</span></p>
        </div>
      </div>

      <!-- Right side: Competency breakdown -->
      <div style="flex: 1; text-align: right;">
        <p style="margin: 0 0 0.75rem 0; color: #94a3b8; font-size: 0.875rem;">Performance breakdown</p>
        <p style="margin: 0 0 0.75rem 0; color: #94a3b8; font-size: 0.75rem;">${timeStr}</p>
        ${competencyList}
      </div>
    </div>
  `;

  return cardDiv;
}

function calculateQuizResults() {
  const questions = currentQuiz.questions;
  let correct = 0;
  const competencyStats = {};
  const questionResults = [];

  if (!currentQuiz || !currentQuiz.questions) {
        return {
            correct: 0,
            incorrect: 0,
            total: 0,
            percentage: 0,
            timeUsed: 0,
            competencyStats: {},
            questionResults: [],
            quizSettings: {}
        };
    }

  
  questions.forEach((question, index) => {
    const userAnswer = userAnswers[`q${index}`];
    const isCorrect = userAnswer === question.correctAnswer;
    
    if (isCorrect) correct++;
    
    // Track competency performance
    if (!competencyStats[question.competency]) {
      competencyStats[question.competency] = { correct: 0, total: 0 };
    }
    competencyStats[question.competency].total++;
    if (isCorrect) {
      competencyStats[question.competency].correct++;
    }
    
    questionResults.push({
      question: question.text,
      userAnswer: userAnswer,
      correctAnswer: question.correctAnswer,
      isCorrect: isCorrect,
      competency: question.competency,
      options: question.options // Include options for Firebase storage
    });
  });
  
  const totalQuestions = questions.length;
  const percentage = Math.round((correct / totalQuestions) * 100);
  const timeUsed = Date.now() - quizStartTime;
  
  return {
    correct,
    incorrect: totalQuestions - correct,
    total: totalQuestions,
    percentage,
    timeUsed,
    competencyStats,
    questionResults,
    quizSettings: currentQuiz.settings
  };
}

// Add a manual refresh function for testing
function forceRefreshQuizData() {
  console.log('Manually refreshing quiz data...');
  reloadQuizCardsFromFirebase();
}

// Add this to window for debugging
window.forceRefreshQuizData = forceRefreshQuizData;


function showQuizResults(results) {
  // Update score display
  document.getElementById('finalScore').textContent = `${results.percentage}%`;
  document.getElementById('correctCount').textContent = results.correct;
  document.getElementById('incorrectCount').textContent = results.incorrect;
  document.getElementById('timeUsed').textContent = formatTime(results.timeUsed);
  
  // Update score circle with consistent styling
  const scoreCircle = document.querySelector('#quizResultsModal .score-circle');
  if (scoreCircle) {
    const degrees = (results.percentage / 100) * 360;
    scoreCircle.style.background = `conic-gradient(#3b82f6 0deg ${degrees}deg, #e5e7eb ${degrees}deg 360deg)`;
  }
  
  // Show competency breakdown using the SAME styling as other cards
  const breakdownContainer = document.getElementById('competencyBreakdown');
  breakdownContainer.innerHTML = '<h3 style="margin-bottom: 1rem; font-size: 18px; font-weight: 600; color: #374151;">Performance by Competency</h3>';
  
  Object.entries(results.competencyStats).forEach(([competency, stats]) => {
    const percentage = Math.round((stats.correct / stats.total) * 100);
    const resultDiv = document.createElement('div');
    resultDiv.style.cssText = `
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      padding: 12px 0; 
      border-bottom: 1px solid #f3f4f6;
    `;
    resultDiv.innerHTML = `
      <span style="color: #374151; font-size: 16px; font-weight: 400;">${competency}</span>
      <span style="color: #374151; font-size: 16px; font-weight: 500;">${stats.correct} / ${stats.total}</span>
    `;
    breakdownContainer.appendChild(resultDiv);
  });
  
  // Show results modal
  document.getElementById('quizResultsModal').style.display = 'block';
}


// Timer functions
function startQuizTimer(timeLimit) {
  const minutes = parseInt(timeLimit.split(' ')[0]);
  let totalSeconds = minutes * 60;
  
  quizTimer = setInterval(() => {
    totalSeconds--;
    
    if (totalSeconds <= 0) {
      clearInterval(quizTimer);
      submitQuiz(); // Auto-submit when time runs out
      return;
    }
    
    const mins = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    document.getElementById('quizTimer').textContent = 
      `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }, 1000);
}

// Utility functions
function formatTime(milliseconds) {
  const minutes = Math.floor(milliseconds / 60000);
  const seconds = Math.floor((milliseconds % 60000) / 1000);
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

// Modal functions
function closeQuizModal() {
  const modal = document.getElementById('quizModal');
  if (modal) {
    modal.style.display = 'none';
  }
  document.body.style.overflow = 'auto';
  if (quizTimer) {
    clearInterval(quizTimer);
  }
}

// Create stars for quiz modal
function createQuizStars() {
  const starsContainer = document.getElementById('quizStarsContainer');
  if (!starsContainer) return;
  
  // Clear existing stars
  starsContainer.innerHTML = '';
  
  // Create 200 stars
  for (let i = 0; i < 200; i++) {
    const star = document.createElement('div');
    star.className = 'practice-quiz-star';
    
    const size = Math.random() * 3 + 0.5;
    const duration = Math.random() * 4 + 2;
    const delay = Math.random() * 2;
    const randomLeft = Math.random() * 100;
    const randomTop = Math.random() * 100;
    const randomOpacity = Math.random() * 0.9 + 0.3;
    
    star.style.width = size + 'px';
    star.style.height = size + 'px';
    star.style.left = randomLeft + '%';
    star.style.top = randomTop + '%';
    star.style.opacity = randomOpacity;
    star.style.animation = `practice-quiz-twinkle ${duration}s ease-in-out infinite`;
    star.style.animationDelay = delay + 's';
    star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
    
    starsContainer.appendChild(star);
  }
}

function closeQuizResultsModal() {
  document.getElementById('quizResultsModal').style.display = 'none';
}

function reviewQuestions() {
  if (!quizResults) return;
  
  reviewQuestionIndex = 0;
  showReviewQuestion();
  document.getElementById('quizResultsModal').style.display = 'none';
  
  // Create review modal if it doesn't exist
  let reviewModal = document.getElementById('reviewModal');
  if (!reviewModal) {
    reviewModal = document.createElement('div');
    reviewModal.id = 'reviewModal';
    reviewModal.className = 'modal';
    reviewModal.innerHTML = `
      <div class="modal-content" style="max-width: 800px;">
        <span class="close" onclick="closeModal('reviewModal')">&times;</span>
        <h2>Question Review</h2>
        <div id="reviewQuestionContainer"></div>
        <div class="review-navigation">
          <button id="reviewPrevBtn" onclick="prevReviewQuestion()" disabled>Previous</button>
          <span id="reviewProgress">1 of ${quizResults.questionResults.length}</span>
          <button id="reviewNextBtn" onclick="nextReviewQuestion()">Next</button>
          <button onclick="closeModal('reviewModal')" style="margin-left: auto;">Close Review</button>
        </div>
      </div>
    `;
    document.body.appendChild(reviewModal);
  }
  
  reviewModal.style.display = 'block';
}

function showReviewQuestion() {
  const container = document.getElementById('reviewQuestionContainer');
  if (!container || !quizResults) return;
  
  const question = quizResults.questionResults[reviewQuestionIndex];
  const questionObj = currentQuiz.questions[reviewQuestionIndex];
  
  const optionsHTML = questionObj.options.map(option => {
    let optionClass = '';
    if (option === question.userAnswer && option === question.correctAnswer) {
      optionClass = 'correct selected';
    } else if (option === question.userAnswer) {
      optionClass = 'incorrect selected';
    } else if (option === question.correctAnswer) {
      optionClass = 'correct';
    }
    
    return `
      <div class="review-option ${optionClass}">
        ${option}
        ${option === question.correctAnswer && option !== question.userAnswer ? 
          '<span style="color: #10b981; margin-left: 8px;">âœ“ Correct answer</span>' : ''}
      </div>
    `;
  }).join('');
  
  container.innerHTML = `
    <div class="review-question">
      <div class="competency-tag">${questionObj.competency}</div>
      <div class="review-question-text">${questionObj.text}</div>
      <div class="review-options">
        ${optionsHTML}
      </div>
      ${questionObj.explanation ? `
        <div class="review-explanation">
          <strong>Explanation:</strong> ${questionObj.explanation}
        </div>
      ` : ''}
    </div>
  `;
  
  // Update navigation buttons
  document.getElementById('reviewPrevBtn').disabled = reviewQuestionIndex === 0;
  document.getElementById('reviewNextBtn').disabled = reviewQuestionIndex === quizResults.questionResults.length - 1;
  document.getElementById('reviewProgress').textContent = `${reviewQuestionIndex + 1} of ${quizResults.questionResults.length}`;
}

function nextReviewQuestion() {
  if (reviewQuestionIndex < quizResults.questionResults.length - 1) {
    reviewQuestionIndex++;
    showReviewQuestion();
  }
}

function prevReviewQuestion() {
  if (reviewQuestionIndex > 0) {
    reviewQuestionIndex--;
    showReviewQuestion();
  }
}

// Update the selectOption function for better selection handling
function selectOption(event, optionIndex, optionText) {
  const options = event.currentTarget.parentElement.querySelectorAll('.option-item');
  const clickedOption = event.currentTarget;
  
  // Check if this option is already selected
  const isSelected = clickedOption.classList.contains('selected');
  
  // Remove selection from all options
  options.forEach(option => {
    option.classList.remove('selected');
  });
  
  // Toggle selection
  if (!isSelected) {
    clickedOption.classList.add('selected');
    userAnswers[`q${currentQuestionIndex}`] = optionText;
  } else {
    userAnswers[`q${currentQuestionIndex}`] = null;
  }
  
  // Update the radio button visual
  const radio = clickedOption.querySelector('.option-radio');
  if (radio) {
    radio.innerHTML = clickedOption.classList.contains('selected') ? 'â—' : '';
  }
}




// Save quiz results to Firebase
async function saveQuizResultsToFirebase(results) {
    const user = firebase.auth().currentUser;
    if (!user) {
        console.error('User not authenticated');
        return;
    }

    try {
        // FIXED: Remove undefined values and add null checks
        const quizResult = {
            userId: user.uid,
            to: user.uid,
            type: 'written',
            score: results.correct || 0,
            maxScore: results.total || 0,
            percentage: results.percentage || 0,
            timeUsed: results.timeUsed || 0,
            
            // FIXED: Add null checks for questionResults - use options from questionResults directly
            questions: (results.questionResults || []).map((q, index) => {
                // Get options from questionResults first, then try writtenQuestions, then currentQuiz, then empty array
                let options = q.options || [];
                if (!options || options.length === 0) {
                    if (typeof writtenQuestions !== 'undefined' && writtenQuestions && writtenQuestions[index] && writtenQuestions[index].options) {
                        options = writtenQuestions[index].options;
                    } else if (typeof currentQuiz !== 'undefined' && currentQuiz && currentQuiz !== null && currentQuiz.questions && currentQuiz.questions[index] && currentQuiz.questions[index].options) {
                        options = currentQuiz.questions[index].options;
                    } else {
                        options = [];
                    }
                }
                return {
                text: q.question || '',
                userAnswer: q.userAnswer || '',
                correctAnswer: q.correctAnswer || '',
                correct: q.isCorrect || false,
                competency: q.competency || '',
                questionId: `q${index + 1}`,
                    options: options
                };
            }),
            
            // FIXED: Add null checks
            competencyStats: results.competencyStats || {},
            settings: results.quizSettings || {},
            title: `${(results.quizSettings && results.quizSettings.difficulty) || 'Practice'} Quiz`,
            difficulty: (results.quizSettings && results.quizSettings.difficulty) || 'medium',
            timeLimit: (results.quizSettings && results.quizSettings.time) || 0,
            competencies: (results.quizSettings && results.quizSettings.competencies) || [],
            
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            completedAt: firebase.firestore.FieldValue.serverTimestamp(),
            status: 'complete'
        };

        // FIXED: Remove any remaining undefined values
        Object.keys(quizResult).forEach(key => {
            if (quizResult[key] === undefined) {
                quizResult[key] = null;
            }
        });

        console.log('Saving quiz result to Firebase:', quizResult);

        const docRef = await firebase.firestore().collection('assignments').add(quizResult);
        console.log('Quiz result saved with ID:', docRef.id);

        return docRef.id;
    } catch (error) {
        console.error('Error saving quiz results to Firebase:', error);
        throw error;
    }
}


async function generateQuestionsWithGPT(formData) {
  const apiKey = "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";
  
  const questionCount = getQuestionCount(formData.time);
  const competenciesText = formData.competencies.join(', ');
  
  // Get training data from Firebase (using existing parameter structure)
  const selectedCompetition = document.getElementById('competitionSelectWritten')?.value;
const trainingData = await getAllTrainingEntries(selectedCompetition);
  
  if (!trainingData || !trainingData.pdfContent) {
    console.log('No training data available, using fallback questions');
    return getFallbackQuestions(questionCount, formData.competencies);
  }
  
  // Build context-aware prompt - let AI determine competencies from content
  let prompt = `Generate ${questionCount} FBLA multiple choice questions using concepts from the study material, but make each question completely standalone.

CRITICAL REQUIREMENTS:
- Difficulty: ${formData.difficulty}
- Target competencies: ${competenciesText}
- Each question must have exactly 4 options
- Extract concepts from the study material but create original standalone questions
- Make questions realistic for FBLA competitions
- YOU must determine which FBLA competency each question belongs to based on the content

ABSOLUTE RULES - NEVER VIOLATE:
- NEVER use: "this agreement", "such as this", "the document", "the passage", "according to", "as stated", "mentioned above", "the text"
- NEVER reference the SOURCE of information (don't say "the document states" or "as mentioned")
- DO use specific facts, names, dates, laws, companies, and details from the study material
- Present all information as established business knowledge
- Reference specific laws, regulations, court cases, historical events, etc. when relevant
- Use concrete examples and specific details, just don't cite where they came from

DIFFICULTY GUIDELINES:
- Easy: Straightforward definitions, basic concepts, obvious answers
- Medium: Application of concepts, moderate analysis, some calculation or reasoning required
- Hard: Complex scenarios, multiple concepts combined, requires deep understanding, tricky distractors that seem plausible

Study Material (USE CONCEPTS ONLY, DON'T REFERENCE):
${trainingData.pdfContent.substring(0, 5000)}`;

  // Add existing questions as style examples
  if (trainingData.userQuestions.length > 0) {
    prompt += `\n\nExample Question Style (note how they don't reference external material):`;
    trainingData.userQuestions.slice(0, 2).forEach((q, i) => {
      prompt += `\n${i + 1}. ${q.text}`;
    });
  }

  prompt += `\n\nAnalyze the study material concepts and create questions that naturally fit these FBLA competencies:
- Business Communication
- Marketing  
- Accounting
- Economics
- Business Law
- Management
- Entrepreneurship
- Finance
- International Business
- Business Ethics
- Parliamentary Procedure

EXAMPLES - USE SPECIFIC DETAILS WITHOUT REFERENCING SOURCE:

âŒ NEVER: "What role does an agreement such as this play in Entrepreneurship?"
âœ… DO: "What is the primary purpose of liability waivers for ice skating activities in entrepreneurial ventures?"

âŒ NEVER: "According to the document, what compensation will participants receive?"  
âœ… DO: "Under the Fair Labor Standards Act of 1938, which type of compensation must be provided to non-exempt employees?"

âŒ NEVER: "The agreement mentions activities. What are they?"
âœ… DO: "Which activities are typically included in comprehensive liability waivers for recreational facilities?"

âŒ NEVER: "As stated in the passage, the Sarbanes-Oxley Act requires..."
âœ… DO: "The Sarbanes-Oxley Act of 2002 requires public companies to maintain which type of financial controls?"

Use specific names, dates, laws, companies, amounts, percentages - just present them as established facts, not as "mentioned in the document".`;

  prompt += `\n\nReturn ONLY a JSON array in this exact format:
[
  {
    "text": "Question text here?",
    "competency": "Business Communication",
    "correctAnswer": "Correct option text",
    "options": ["Option A", "Option B", "Option C", "Option D"],
    "difficulty": "${formData.difficulty}",
    "source": "training_content"
  }
]`;

  try {
    const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({messages: [
          {
            role: 'system',
            content: `You are an expert FBLA written-competition exam designer.

Your role is to generate ORIGINAL, competition-accurate FBLA-style multiple-choice questions that match the structure, rigor, tone, and professional standards of official FBLA written tests.

You must follow ALL rules below.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE FBLA PHILOSOPHY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FBLA written tests assess professional correctness, precision, and applied business literacy.

They do NOT assess creativity, opinion, or open-ended reasoning.

Each question must test exactly ONE concept.

Questions must be concise, objective, and professionally worded.

Avoid unnecessary narrative unless the question type explicitly requires a scenario.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
APPROVED FBLA QUESTION ARCHETYPES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Every question MUST clearly belong to ONE of the following archetypes:

1. Definition / Term Identification  
   - Identifying the correct term based on a definition  
   - Selecting the correct meaning of a professional word or concept  

2. Classification / Category Recognition  
   - Determining where an item belongs within a professional category system  
   - Examples include document types, account categories, system types, business forms, or classifications  

3. Procedural / Workflow Knowledge  
   - Understanding the stages of a professional workflow specific to the competition area  
   - Identifying where information originates within that workflow  
   - Determining which document, tool, or action is appropriate at a given stage  
   - Recognizing correct sequencing of professional tasks within the domain  

4. Tool-to-Function Matching  
   - Matching software features, commands, utilities, or tools to their correct purpose  
   - Selecting the correct function used to accomplish a professional task  

5. Quantitative / Calculation Application  
   - Performing single-step or limited multi-step calculations  
   - Selecting the correct numeric result based on provided data  
   - Avoid unnecessary complexity or advanced math  

6. Language Precision & Usage  
   - Correct use of professional vocabulary  
   - Distinguishing homophones, word meanings, spelling, grammar, and standard usage  

7. Error Detection / Exception Identification  
   - Identifying what is incorrect, misspelled, or does NOT belong  
   - Using negation ("NOT") carefully and intentionally  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUESTION STRUCTURE RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Each question must assess ONE idea only.  
â€¢ Do not combine multiple concepts in one question.  
â€¢ Avoid ambiguous wording.  
â€¢ Use professional, neutral language.

Acceptable stem styles include:
- "Which of the followingâ€¦"
- "What term best describesâ€¦"
- "The document used toâ€¦"
- "Which action should be takenâ€¦"
- "Which of the following is NOTâ€¦"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ANSWER CHOICE DESIGN (CRITICAL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Each question MUST include exactly FOUR answer choices.

Answer choices must:
â€¢ Be the same grammatical form  
â€¢ Be similar in length  
â€¢ Belong to the same conceptual family  

Wrong answer choices (distractors) must be plausible and realistic.

Allowed distractor strategies include:
â€¢ Closely related terms within the same category  
â€¢ Common student misconceptions  
â€¢ Incorrect step within a workflow  
â€¢ Reversed or misapplied professional rules  
â€¢ Visually or linguistically similar words  
â€¢ Typical calculation or classification errors  

Never include joke answers or obviously incorrect options.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIFFICULTY CALIBRATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Easy:
â€¢ Direct recall or recognition  
â€¢ Minimal traps  

Medium:
â€¢ Requires discrimination between similar concepts  
â€¢ Includes common misconceptions  

Hard:
â€¢ Includes negation ("NOT")  
â€¢ Requires precise rule awareness  
â€¢ Uses subtle wording differences  
â€¢ Penalizes shallow memorization  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONTENT INTEGRITY RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All questions must be ORIGINAL.  
â€¢ Do NOT copy real FBLA questions.  
â€¢ Do NOT closely paraphrase known questions.  
â€¢ Use authentic structure only, not replicated wording.

Questions must feel realistic for competitive FBLA written events at the regional, state, or national level.

When study materials are provided, extract concepts, facts, names, dates, laws, and details from them. Present this information as established business knowledge. NEVER mention "the study guide", "the document", "the material", or use phrases like "according to", "as stated in", or "mentioned in".

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OUTPUT REQUIREMENTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Generate ONLY the requested number of questions.  
â€¢ Each question must have exactly four answer options.  
â€¢ Only ONE option may be correct.  
â€¢ Output valid JSON only.  
â€¢ Do not include explanations, commentary, or headings.  

You are writing as a professional exam author â€” not as a tutor or teacher.`
          },
          {
            role: 'user',
            content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt
          }
        ], temperature: 0.7, max_tokens: 4000});

    if (!response.ok) {
      throw new Error(`API Error: ${response.status} - ${response.statusText}`);
    }

    const data = response.data; let content = data.content.trim();
    
    // Clean JSON formatting
    content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    
    const generatedQuestions = JSON.parse(content);
    
    // Validate and sort questions
    const validatedQuestions = validateAndSortQuestions(generatedQuestions, formData);
    
    return validatedQuestions;

  } catch (error) {
    console.error('Enhanced GPT Error:', error);
    
    // Fallback to existing user questions if API fails
    if (trainingData.userQuestions.length > 0) {
      return trainingData.userQuestions.slice(0, questionCount);
    } else {
      return getFallbackQuestions(questionCount, formData.competencies);
    }
  }
}


function validateAndSortQuestions(questions, formData) {
  const validQuestions = [];
  
  questions.forEach((q, index) => {
    try {
      // Validate question structure
      if (!q.text || !q.correctAnswer || !Array.isArray(q.options) || q.options.length !== 4) {
        console.warn(`Question ${index + 1} has invalid structure, skipping`);
        return;
      }
      
      // Ensure correct answer is in options
      if (!q.options.includes(q.correctAnswer)) {
        console.warn(`Question ${index + 1}: correctAnswer not found in options, skipping`);
        return;
      }
      
      // Set competency if missing
      if (!q.competency) {
        q.competency = formData.competencies[0] || 'General Business';
      }
      
      // Set difficulty if missing
      if (!q.difficulty) {
        q.difficulty = formData.difficulty;
      }
      
      validQuestions.push(q);
      
    } catch (error) {
      console.warn(`Error validating question ${index + 1}:`, error);
    }
  });
  
  // Sort questions by competency, then by difficulty
  validQuestions.sort((a, b) => {
    if (a.competency !== b.competency) {
      return a.competency.localeCompare(b.competency);
    }
    
    const difficultyOrder = { 'Easy': 1, 'Medium': 2, 'Hard': 3 };
    return (difficultyOrder[a.difficulty] || 2) - (difficultyOrder[b.difficulty] || 2);
  });
  
  return validQuestions;
}


async function getUserPerformanceHistory() {
  const user = firebase.auth().currentUser;
  if (!user) return null;
  
  try {
    const assignmentsRef = firebase.firestore().collection('assignments');
    const snapshot = await assignmentsRef
      .where('to', '==', user.uid)
      .where('status', '==', 'complete')
      .orderBy('createdAt', 'desc')
      .limit(10) // Get last 10 quizzes
      .get();
    
    if (snapshot.empty) return null;
    
    const competencyPerformance = {};
    const allCompetencies = [];
    
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.competencyStats) {
        Object.entries(data.competencyStats).forEach(([comp, stats]) => {
          if (!competencyPerformance[comp]) {
            competencyPerformance[comp] = { correct: 0, total: 0, attempts: 0 };
          }
          competencyPerformance[comp].correct += stats.correct;
          competencyPerformance[comp].total += stats.total;
          competencyPerformance[comp].attempts++;
        });
      }
    });
    
    // Determine weak and strong areas
    const weakCompetencies = [];
    const strongCompetencies = [];
    
    Object.entries(competencyPerformance).forEach(([comp, stats]) => {
      const percentage = (stats.correct / stats.total) * 100;
      if (percentage < 70) {
        weakCompetencies.push(comp);
      } else if (percentage > 85) {
        strongCompetencies.push(comp);
      }
    });
    
    return {
      competencyPerformance,
      weakCompetencies,
      strongCompetencies,
      totalQuizzes: snapshot.docs.length
    };
    
  } catch (error) {
    console.error('Error getting user performance history:', error);
    return null;
  }
}

function filterPerformanceBySelection(userHistory, formData) {
  const { competencies, difficulty } = formData;
  const filtered = {};
  
  // Filter by selected competencies
  competencies.forEach(comp => {
    if (userHistory.competencyPerformance[comp]) {
      const stats = userHistory.competencyPerformance[comp];
      const percentage = (stats.correct / stats.total) * 100;
      
      // Determine if this competency needs more practice based on difficulty setting
      let needsPractice = false;
      if (difficulty === 'Easy' && percentage < 60) needsPractice = true;
      if (difficulty === 'Medium' && percentage < 75) needsPractice = true;
      if (difficulty === 'Hard' && percentage < 85) needsPractice = true;
      
      filtered[comp] = {
        ...stats,
        percentage,
        needsPractice
      };
    }
  });
  
  return filtered;
}


async function getTrainingContext(selectedCompetition) {
    try {
        const currentUserId = getCurrentUserId();
        
        if (!currentUserId) {
            console.log('No user ID available');
            return null;
        }
        
        // Get all training entries for this user
        const trainingEntriesRef = db.collection('userTraining').doc(currentUserId)
            .collection('trainingEntries')
            .orderBy('timestamp', 'desc')
            .limit(10); // Get last 10 entries
        
        const snapshot = await trainingEntriesRef.get();
        
        if (snapshot.empty) {
            console.log('No training data found for user:', currentUserId);
            return null;
        }
        
        // Combine all training data
        let combinedContent = '';
        const allQuestions = [];
        
        snapshot.forEach(doc => {
            const data = doc.data();
            if (data.content) {
                combinedContent += data.content + '\n\n';
            }
            if (data.userQuestions && Array.isArray(data.userQuestions)) {
                allQuestions.push(...data.userQuestions);
            }
        });
        
        return {
            userQuestions: allQuestions,
            pdfContent: combinedContent
        };
        
    } catch (error) {
        console.error('Error fetching training context:', error);
        return null;
    }
}

async function clearTrainingData() {
    const userId = getCurrentUserId();
    console.log('Deleting everything for user:', userId);
    
    try {
        // Check what exists before deletion
        const entriesSnapshot = await db.collection('userTraining').doc(userId).collection('entries').get();
        const trainingSnapshot = await db.collection('userTraining').doc(userId).collection('trainingEntries').get();
        
        console.log('BEFORE DELETION:');
        console.log('Entries found:', entriesSnapshot.size);
        console.log('TrainingEntries found:', trainingSnapshot.size);
        
        // Delete all documents in entries subcollection
        const entriesDeletePromises = [];
        entriesSnapshot.forEach(doc => {
            console.log('Deleting entry doc:', doc.id);
            entriesDeletePromises.push(doc.ref.delete());
        });
        
        // Delete all documents in trainingEntries subcollection  
        const trainingDeletePromises = [];
        trainingSnapshot.forEach(doc => {
            console.log('Deleting training doc:', doc.id);
            trainingDeletePromises.push(doc.ref.delete());
        });
        
        // Delete the main document
        console.log('Deleting main document...');
        const mainDocDelete = db.collection('userTraining').doc(userId).delete();
        
        // Execute all deletions
        await Promise.all([...entriesDeletePromises, ...trainingDeletePromises, mainDocDelete]);
        
        console.log('All deletions completed!');
        
        // Verify deletion
        const entriesCheck = await db.collection('userTraining').doc(userId).collection('entries').get();
        const trainingCheck = await db.collection('userTraining').doc(userId).collection('trainingEntries').get();
        console.log('AFTER DELETION:');
        console.log('Entries remaining:', entriesCheck.size);
        console.log('TrainingEntries remaining:', trainingCheck.size);
        
        showSuccessMessage('All training data has been deleted!');

        
    } catch (error) {
        console.error('Error clearing training data:', error);
        console.log('Full error details:', error);
        alert('Error clearing training data: ' + error.message);
    }
}
function showSuccessMessage(message) {
    console.log('Attempting to show success message:', message);
    
    // Method 1: Try to find clear button with multiple selectors
    const possibleSelectors = [
        '.clear-training-btn',
        '[onclick*="clearTrainingData"]',
        'button[onclick*="clear"]',
        '.btn[onclick*="Training"]',
        'input[onclick*="clearTrainingData"]'
    ];
    
    let clearButton = null;
    for (const selector of possibleSelectors) {
        clearButton = document.querySelector(selector);
        if (clearButton) break;
    }
    
    // Method 2: If no button found, try finding any button with "clear" text
    if (!clearButton) {
        const allButtons = document.querySelectorAll('button, input[type="button"], .btn');
        clearButton = Array.from(allButtons).find(btn => 
            btn.textContent.toLowerCase().includes('clear') || 
            btn.value?.toLowerCase().includes('clear')
        );
    }
    
    // Method 3: If still no button, create message in body
    let targetElement = clearButton?.parentNode || document.body;
    
    // Remove any existing success message
    document.querySelectorAll('.success-message').forEach(msg => msg.remove());
    
    // Create success message with guaranteed visibility
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.textContent = message;
    successMessage.style.cssText = `
        color: #10b981 !important;
        font-size: 16px !important;
        font-weight: bold !important;
        margin: 10px 0 !important;
        padding: 10px !important;
        background: #ecfdf5 !important;
        border: 1px solid #10b981 !important;
        border-radius: 4px !important;
        opacity: 1 !important;
        transition: opacity 0.3s ease !important;
        position: relative !important;
        z-index: 9999 !important;
        display: block !important;
    `;
    
    // Insert message
    if (clearButton) {
        // Insert after the button
        clearButton.parentNode.insertBefore(successMessage, clearButton.nextSibling);
        console.log('Success message inserted after clear button');
    } else {
        // Fallback: add to body
        targetElement.appendChild(successMessage);
        console.log('Success message added to body');
    }
    
    console.log('Success message element created and added');
    
    // Fade out after 4 seconds
    setTimeout(() => {
        console.log('Starting fadeout');
        successMessage.style.opacity = '0';
        setTimeout(() => {
            if (successMessage.parentNode) {
                successMessage.remove();
                console.log('Success message removed');
            }
        }, 300);
    }, 4000);
}
function getCurrentUserId() {
    const user = auth.currentUser;
    return user ? user.uid : 'anonymous';
}

function parseTrainingContent(content) {
  const result = {
    questions: [],
    pdfContent: content
  };
  
  if (!content) return result;
  
  // Split content into sections/paragraphs for easier processing
  const sections = content.split('\n\n').filter(section => section.trim());
  
  // Extract existing questions if any (look for question patterns)
  sections.forEach(section => {
    // Look for question patterns (sentences ending with ?)
    const questionMatches = section.match(/[^.!?]*\?/g);
    if (questionMatches) {
      questionMatches.forEach(question => {
        if (question.trim().length > 10) {
          result.questions.push({
            text: question.trim(),
            source: 'training_content',
            competency: null // Let AI determine competency
          });
        }
      });
    }
  });
  
  return result;
}

// CHANGE THIS FUNCTION:
async function populateCompetitionsDropdown() {
    try {
        // ADD THIS CHECK FIRST
        const user = firebase.auth().currentUser;
        if (!user) {
            console.log('No user logged in');
            return;
        }

        const userDoc = await firebase.firestore().collection('users').doc(user.uid).get();
        const compData = userDoc.data()?.competitions;
        
        // FIX: Handle both array and string cases
        const competitions = Array.isArray(compData) ? compData : 
                           (typeof compData === 'string' ? [compData] : ['general']);
        
        console.log('Found competitions:', competitions);
        
        // ADD ALL DROPDOWN IDs THAT NEED POPULATION
        const dropdownIds = [
            'competitionSelect', 
            'competitionSelectWritten', 
            'competitionSelectSpeaking', 
            'competitionSelectCase',
            'deleteCompetitionSelect' // Add any others you have
        ];
        
        // POPULATE EACH DROPDOWN
        dropdownIds.forEach(id => {
            const dropdown = document.getElementById(id);
            if (dropdown) {
                dropdown.innerHTML = '<option value="">Select competition...</option>';
                (Array.isArray(competitions) ? competitions : [competitions]).forEach(comp => {
                    const option = document.createElement('option');
                    option.value = comp;
                    option.textContent = comp;
                    dropdown.appendChild(option);
                });
            }
        });
        
    } catch (error) {
        console.error('Error populating dropdowns:', error);
    }
}// Execute the function
populateCompetitionsDropdown();

// ADD THIS NEW FUNCTION:
async function setupCompetitionDropdowns() {
    // Call this when each modal opens
    await populateCompetitionsDropdown();
}

// Clear training context (optional utility function)
 async function clearTrainingContext() {
    const userId = getCurrentUserId();
    console.log('Deleting everything for user:', userId);
    
    try {
        // Check what exists before deletion
        const entriesSnapshot = await db.collection('userTraining').doc(userId).collection('entries').get();
        const trainingSnapshot = await db.collection('userTraining').doc(userId).collection('trainingEntries').get();
        
        console.log('BEFORE DELETION:');
        console.log('Entries found:', entriesSnapshot.size);
        console.log('TrainingEntries found:', trainingSnapshot.size);
        
        // Delete all documents in entries subcollection
        const entriesDeletePromises = [];
        entriesSnapshot.forEach(doc => {
            console.log('Deleting entry doc:', doc.id);
            entriesDeletePromises.push(doc.ref.delete());
        });
        
        // Delete all documents in trainingEntries subcollection  
        const trainingDeletePromises = [];
        trainingSnapshot.forEach(doc => {
            console.log('Deleting training doc:', doc.id);
            trainingDeletePromises.push(doc.ref.delete());
        });
        
        // Delete the main document
        console.log('Deleting main document...');
        const mainDocDelete = db.collection('userTraining').doc(userId).delete();
        
        // Execute all deletions
        await Promise.all([...entriesDeletePromises, ...trainingDeletePromises, mainDocDelete]);
        
        console.log('All deletions completed!');
        
        // Verify deletion
        const entriesCheck = await db.collection('userTraining').doc(userId).collection('entries').get();
        const trainingCheck = await db.collection('userTraining').doc(userId).collection('trainingEntries').get();
        console.log('AFTER DELETION:');
        console.log('Entries remaining:', entriesCheck.size);
        console.log('TrainingEntries remaining:', trainingCheck.size);
        
                showSuccessMessage('All training data has been deleted!');

        
    } catch (error) {
        console.error('Error clearing training data:', error);
        console.log('Full error details:', error);
        alert('Error clearing training data: ' + error.message);
    }
}

function getFallbackQuestions(count, competencies) {
  const fallbackQuestions = [
    {
      text: "What is the primary purpose of parliamentary procedure?",
      competency: "Parliamentary Procedure",
      correctAnswer: "To make meetings more efficient",
      options: [
        "To make meetings more efficient",
        "To give the president more power",
        "To eliminate debate",
        "To make meetings longer"
      ]
    },
    {
      text: "Which motion is used to end a meeting?",
      competency: "Parliamentary Procedure",
      correctAnswer: "Adjourn",
      options: [
        "Adjourn",
        "Recess",
        "Postpone",
        "Table"
      ]
    },
    {
      text: "What is the most effective way to communicate in business?",
      competency: "Business Communication",
      correctAnswer: "Clear and concise messaging",
      options: [
        "Clear and concise messaging",
        "Using complex terminology",
        "Lengthy detailed explanations",
        "Informal casual language"
      ]
    },
    {
      text: "What is the marketing mix also known as?",
      competency: "Marketing",
      correctAnswer: "The 4 P's",
      options: [
        "The 4 P's",
        "The 4 C's",
        "The 5 S's",
        "The 3 R's"
      ]
    },
    {
      text: "What is the basic accounting equation?",
      competency: "Accounting", 
      correctAnswer: "Assets = Liabilities + Owner's Equity",
      options: [
        "Assets = Liabilities + Owner's Equity",
        "Revenue = Expenses + Profit",
        "Assets = Revenue - Expenses",
        "Liabilities = Assets + Equity"
      ]
    }
  ];
  
  // Return the requested number of questions (cycle through if needed)
  const result = [];
  for (let i = 0; i < count; i++) {
    result.push(fallbackQuestions[i % fallbackQuestions.length]);
  }
  
  return result;
}


function addLoadingStyles() {
    const style = document.createElement('style');
    style.textContent = `
        /* Light theme loading container with fade animation */
        #cq-written-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #cq-written-loading.show {
            opacity: 1;
        }
        
        /* HUGE Gradient balls background */
        .gradient-balls {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }
        
        .ball {
            position: absolute;
            border-radius: 50%;
            opacity: 0.4;
            filter: blur(100px);
            animation: float 25s infinite ease-in-out;
        }
        
        .ball-1 {
            width: 600px;
            height: 600px;
            background: linear-gradient(45deg, #93c5fd, #3b82f6);
            top: 10%;
            left: 5%;
            animation-delay: 0s;
            animation-duration: 30s;
        }
        
        .ball-2 {
            width: 550px;
            height: 550px;
            background: linear-gradient(45deg, #6ee7b7, #10b981);
            top: 60%;
            right: 5%;
            animation-delay: -7s;
            animation-duration: 25s;
        }
        
        .ball-3 {
            width: 650px;
            height: 650px;
            background: linear-gradient(45deg, #d8b4fe, #8b5cf6);
            bottom: 10%;
            left: 15%;
            animation-delay: -12s;
            animation-duration: 35s;
        }
        
        .ball-4 {
            width: 500px;
            height: 500px;
            background: linear-gradient(45deg, #fcd34d, #f59e0b);
            top: 15%;
            right: 15%;
            animation-delay: -5s;
            animation-duration: 28s;
        }
        
        .ball-5 {
            width: 700px;
            height: 700px;
            background: linear-gradient(45deg, #fda4af, #ec4899);
            bottom: 5%;
            right: 10%;
            animation-delay: -15s;
            animation-duration: 32s;
        }
        
        @keyframes float {
            0% {
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            33% {
                transform: translate(80px, -60px) scale(1.1) rotate(120deg);
            }
            66% {
                transform: translate(-60px, 70px) scale(0.9) rotate(240deg);
            }
            100% {
                transform: translate(0, 0) scale(1) rotate(360deg);
            }
        }
        
        .cq-loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem 2.5rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            position: relative;
            z-index: 2;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
        }
        
        .cq-loading-spinner {
            width: 70px;
            height: 70px;
            border: 3px solid rgba(59, 130, 246, 0.1);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: cq-spin 1.2s ease-in-out infinite;
            margin-bottom: 1.5rem;
            box-sizing: border-box;
        }
        
        @keyframes cq-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .cq-loading-text {
            font-size: 1.5rem;
            color: #1e293b;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        .cq-loading-subtext {
            font-size: 1.1rem;
            color: #64748b;
            margin-bottom: 1.5rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        .cq-loading-progress {
            width: 300px;
            height: 8px;
            background-color: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 1rem;
        }
        
        .cq-loading-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            border-radius: 4px;
            transition: width 0.4s ease;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .ball {
                filter: blur(70px);
            }
            
            .ball-1, .ball-2, .ball-3, .ball-4, .ball-5 {
                width: 400px;
                height: 400px;
            }
            
            .cq-loading-container {
                padding: 2rem 1.5rem;
                width: 85%;
            }
            
            .cq-loading-text {
                font-size: 1.3rem;
            }
            
            .cq-loading-subtext {
                font-size: 1rem;
            }
            
            .cq-loading-progress {
                width: 250px;
            }
        }
    `;
    document.head.appendChild(style);
}

    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const icon = button.querySelector('.chevron-icon');
      const isActive = button.classList.contains('active');
  
      button.classList.toggle('active');
      content.style.maxHeight = isActive ? null : content.scrollHeight + "px";
      if (icon) icon.classList.toggle('rotate', !isActive);
    }
  
    // Modals
    function openModal(id) {
      const modal = document.getElementById(id);
      if (modal) {
        if (id === 'writtenModal' || id === 'speakingModal') {
          modal.style.display = 'flex';
        } else {
          modal.style.display = 'block';
        }
      }
    }
    function closeModal(id) {
      const modal = document.getElementById(id);
      if (modal) modal.style.display = 'none';
    }
  
   
    async function openWrittenModal() { 
  openModal('writtenModal');
  await setupCompetitionDropdowns();
  await populateCompetitionDropdown('competitionSelectWritten');
  
  // Populate default competencies if none are selected
  const checkboxGroup = document.querySelector('.written-checkbox-group');
  if (checkboxGroup && checkboxGroup.children.length === 0) {
    const defaultCompetencies = [
      'Business Communication',
      'Marketing',
      'Accounting',
      'Economics',
      'Business Law',
      'Management'
    ];
    defaultCompetencies.forEach((comp) => {
      const checkboxItem = document.createElement('div');
      checkboxItem.className = 'written-checkbox-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'competency-option';
      checkbox.value = comp;
      checkbox.id = `competency-${comp.replace(/\s+/g, '-')}`;
      
      const label = document.createElement('label');
      label.setAttribute('for', checkbox.id);
      label.textContent = comp;
      
      checkboxItem.appendChild(checkbox);
      checkboxItem.appendChild(label);
      checkboxGroup.appendChild(checkboxItem);
    });
  }

  // LOAD MENTEES WITH MATCHING COMPETITIONS
  setTimeout(async () => {
    const currentUser = firebase.auth().currentUser;
    if (!currentUser) return;
    
    try {
      const userDoc = await db.collection('users').doc(currentUser.uid).get();
      const mentorComps = userDoc.data()?.competitions || [];
      
      const snap = await db.collection('users')
        .where('competitions', 'array-contains-any', mentorComps)
        .get();
      
      const menteesList = document.getElementById('menteesList');
      if (!menteesList) return;
      
      snap.docs.forEach(userDoc => {
        const userId = userDoc.id;
        const userName = userDoc.data().name || userDoc.data().email;
        
        const exists = menteesList.querySelector(`input[value="${userId}"]`);
        if (exists) return;
        
        const label = document.createElement('label');
        label.className = 'written-checkbox-item';
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.marginBottom = '10px';
        label.style.color = 'white';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = userId;
        checkbox.style.marginRight = '10px';
        
        const text = document.createElement('span');
        text.innerText = userName;
        
        label.appendChild(checkbox);
        label.appendChild(text);
        menteesList.appendChild(label);
      });
    } catch (err) {
      console.error('Error loading mentees:', err);
    }
  }, 300);

  addLoadingStyles();
}


async function openSpeakingModal() { 
    openModal('speakingModal');
    await populateCompetitionDropdown('competitionSelectSpeaking');
}

async function openCaseModal() { 
    openModal('caseModal');
    await populateCompetitionDropdown('competitionSelectCase');
        await initializeCaseModalCompetitions(); // Add this line
           await populateCompetitionDropdown('competitionSelectCase');
}


// Add this function to your JavaScript
function openCasePracticeModal() {
    const caseData = {
        competition: document.getElementById('caseCompetition')?.textContent || 'Unknown',
        difficulty: document.getElementById('caseDifficulty')?.textContent || 'Easy',
        competencies: document.getElementById('caseCompetencies')?.textContent || '',
        caseText: document.querySelector('#caseContentContainer [style*="white-space: pre-wrap"]')?.textContent || 'No case available'
    };
    
    if (typeof openCameraModal === 'function') {
        // Store original functions BEFORE opening modal
        if (!window.originalCameraFunctions) {
            window.originalCameraFunctions = {
                startCameraRecording: window.startCameraRecording,
                stopCameraRecording: window.stopCameraRecording,
                toggleRecording: window.toggleRecording,
                initializeCamera: window.initializeCamera
            };
        }
        
        // Override functions immediately
        overrideCameraFunctions();
        
        openCameraModal();
        setTimeout(() => {
            try {
                setupCasePracticeModal(caseData);
            } catch (error) {
                console.error('Error setting up case practice modal:', error);
                setTimeout(() => setupCasePracticeModal(caseData), 500);
            }
        }, 1000);
    }
}


function overrideRecordingFunctions() {
    // Override startCameraRecording to handle our modified DOM
    if (window.originalCameraFunctions?.startCameraRecording) {
        window.startCameraRecording = function() {
            // Find the record button in our new container
            const recordBtn = document.querySelector('#caseControlsContainer [onclick*="toggleRecording"]');
            if (recordBtn) {
                recordBtn.classList.add('recording');
            }
            // Call original function
            return window.originalCameraFunctions.startCameraRecording();
        };
    }
    
    // Override stopCameraRecording to handle our modified DOM
    if (window.originalCameraFunctions?.stopCameraRecording) {
        window.stopCameraRecording = function() {
            // Find the record button in our new container
            const recordBtn = document.querySelector('#caseControlsContainer [onclick*="toggleRecording"]');
            if (recordBtn) {
                recordBtn.classList.remove('recording');
            }
            // Call original function
            return window.originalCameraFunctions.stopCameraRecording();
        };
    }
}

function overrideCameraFunctions() {
    // Override startCameraRecording
    if (window.originalCameraFunctions?.startCameraRecording) {
        window.startCameraRecording = function() {
            // Find record button in NEW location
            const recordBtn = document.querySelector('#caseControlsContainer [onclick*="toggleRecording"], #caseControlsContainer .record-button');
            if (recordBtn) {
                recordBtn.classList.add('recording');
                console.log('Recording started - button updated');
            } else {
                console.warn('Record button not found in caseControlsContainer');
            }
            return window.originalCameraFunctions.startCameraRecording();
        };
    }
    
    // Override stopCameraRecording
    if (window.originalCameraFunctions?.stopCameraRecording) {
        window.stopCameraRecording = function() {
            // Find record button in NEW location
            const recordBtn = document.querySelector('#caseControlsContainer [onclick*="toggleRecording"], #caseControlsContainer .record-button');
            if (recordBtn) {
                recordBtn.classList.remove('recording');
                console.log('Recording stopped - button updated');
            } else {
                console.warn('Record button not found in caseControlsContainer');
            }
            return window.originalCameraFunctions.stopCameraRecording();
        };
    }
    
    // Override initializeCamera to ensure video element exists
    if (window.originalCameraFunctions?.initializeCamera) {
        window.initializeCamera = function() {
            // Ensure video element exists before initialization
            let videoElement = document.getElementById('videoPreview');
            if (!videoElement) {
                console.log('Creating missing videoPreview element');
                videoElement = document.createElement('video');
                videoElement.id = 'videoPreview';
                videoElement.autoplay = true;
                videoElement.playsinline = true;
                videoElement.muted = true; // Important for autoplay
                videoElement.style.cssText = `
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    display: block;
                    background: #000;
                `;
                
                // Try to place in the correct container if it exists
                const videoContainer = document.getElementById('caseVideoContainer');
                if (videoContainer) {
                    videoContainer.appendChild(videoElement);
                } else {
                    // Fallback to body if container doesn't exist yet
                    document.body.appendChild(videoElement);
                }
            }
            return window.originalCameraFunctions.initializeCamera();
        };
    }
}

// New function to directly initialize camera
async function directCameraInit() {
    const video = document.getElementById('videoPreview');
    
    if (!video) {
        console.error('Video element not found for camera init!');
        return;
    }
    
    try {
        console.log('Requesting camera access...');
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: false 
        });
        
        console.log('Camera access granted!');
        video.srcObject = stream;
        
        // Update status
        const statusEl = document.getElementById('videoStatus');
        if (statusEl) {
            statusEl.textContent = 'Camera Feed: Active';
            statusEl.style.background = 'rgba(34, 197, 94, 0.8)';
        }
        
        return stream;
    } catch (err) {
        console.error('Camera error:', err.name, err.message);
        
        // Update status
        const statusEl = document.getElementById('videoStatus');
        if (statusEl) {
            statusEl.textContent = 'Camera Feed: Error';
            statusEl.style.background = 'rgba(239, 68, 68, 0.8)';
        }
    }
}

function setupCasePracticeModal(caseData) {
    const modalWrapper = document.getElementById('cameraModal');
    const modalContent = document.querySelector('#cameraModal .camera-questions-container')?.parentElement ||
                       document.querySelector('#cameraModal > div');
    
    if (!modalContent || !modalWrapper) {
        console.error('Modal elements not found');
        return;
    }
    
    console.log('Setting up case practice modal...');
    
    // Get existing elements BEFORE transforming
    let existingVideo = document.getElementById('videoPreview');
    const existingButtons = Array.from(modalContent.querySelectorAll('button'));
    const existingClose = modalContent.querySelector('[onclick*="close"], [onclick*="closeCamera"]');
    
    // If video element doesn't exist, create it
    // If video element doesn't exist, create it
if (!existingVideo) {
    console.log('Creating new video element');
    existingVideo = document.createElement('video');
    existingVideo.id = 'videoPreview';
    existingVideo.autoplay = true;
    existingVideo.playsinline = true;
    existingVideo.muted = true;
}
    
    // Store original content for restoration
    if (!modalWrapper.dataset.originalContent) {
        modalWrapper.dataset.originalContent = modalContent.innerHTML;
        modalWrapper.dataset.originalVideoParent = existingVideo.parentElement?.id || 'unknown';
    }
    
    // Store current stream if it exists
    const currentStream = existingVideo ? existingVideo.srcObject : null;
    
    // Transform modal with starry background
    modalWrapper.style.cssText = `
        display: flex !important;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        z-index: 9999;
        align-items: center;
        justify-content: center;
        padding: 15px;
        overflow: hidden;
    `;
    
    // Create stars container
    if (!document.getElementById('casePracticeStars')) {
        const starsContainer = document.createElement('div');
        starsContainer.id = 'casePracticeStars';
        starsContainer.style.cssText = `
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        `;
        modalWrapper.appendChild(starsContainer);
        
        // Generate stars
        for (let i = 0; i < 200; i++) {
            const star = document.createElement('div');
            const size = Math.random() * 3 + 0.5;
            const duration = Math.random() * 4 + 2;
            const delay = Math.random() * 2;
            const randomLeft = Math.random() * 100;
            const randomTop = Math.random() * 100;
            const randomOpacity = Math.random() * 0.9 + 0.3;
            
            star.style.cssText = `
                position: absolute;
                width: ${size}px;
                height: ${size}px;
                left: ${randomLeft}%;
                top: ${randomTop}%;
                background: white;
                border-radius: 50%;
                opacity: ${randomOpacity};
                animation: twinkle ${duration}s ease-in-out infinite;
                animation-delay: ${delay}s;
                box-shadow: 0 0 ${size * 2}px rgba(255, 255, 255, 0.8);
    `;
            starsContainer.appendChild(star);
        }
        
        // Add twinkle animation
        if (!document.getElementById('casePracticeStarsStyle')) {
            const style = document.createElement('style');
            style.id = 'casePracticeStarsStyle';
            style.textContent = `
                @keyframes twinkle {
                    0%, 100% { opacity: 0.1; transform: scale(1); }
                    50% { opacity: 0.8; transform: scale(1.2); }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    modalContent.style.cssText = `
        display: flex;
        flex-direction: row;
        gap: 15px;
        width: 95vw;
        height: 90vh;
        max-width: none;
        position: relative;
        background: transparent;
        border: none;
        z-index: 2;
        padding: 0;
        margin: 0;
    `;
    
    modalContent.innerHTML = `
        <!-- Left Panel - Camera -->
        <div style="flex: 1; display: flex; flex-direction: column; gap: 12px; background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9)); border: 2px solid rgba(251, 146, 60, 0.4); border-radius: 16px; padding: 15px; height: 100%; min-height: 0; backdrop-filter: blur(10px); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 40px rgba(251, 146, 60, 0.2);">
            <h2 style="margin: 0; color: white; font-size: 22px; font-weight: 900; background: linear-gradient(to right, #fb923c, #fbbf24); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">${caseData.competition} Case Practice</h2>
            <div id="caseVideoContainer" style="flex: 1; background: #000; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(251, 146, 60, 0.3), inset 0 0 60px rgba(251, 146, 60, 0.1); position: relative; min-height: 0; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(251, 146, 60, 0.3);">
                <!-- Video will be placed here -->
                <div id="videoStatus" style="position: absolute; top: 12px; left: 12px; color: #10b981; background: rgba(15, 23, 42, 0.9); padding: 6px 12px; border-radius: 8px; font-size: 11px; font-weight: 700; z-index: 10; border: 1px solid rgba(16, 185, 129, 0.5); box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);">
                    Camera Feed: Active
                </div>
            </div>
            <div id="caseControlsContainer" style="display: flex; gap: 12px; justify-content: center; align-items: center; flex-wrap: wrap; padding: 0;">
                <!-- Buttons will be placed here -->
            </div>
        </div>
        
        <!-- Right Panel - Case Text -->
        <div style="flex: 1; overflow-y: auto; background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9)); border: 2px solid rgba(251, 146, 60, 0.4); border-radius: 16px; padding: 15px; height: 100%; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 40px rgba(251, 146, 60, 0.2); min-height: 0; backdrop-filter: blur(10px);">
            <div style="background: linear-gradient(to right, rgba(220, 38, 38, 0.3), rgba(249, 115, 22, 0.3)); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; color: white; box-shadow: 0 4px 20px rgba(220, 38, 38, 0.2); border: 1px solid rgba(251, 146, 60, 0.4);">
                <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
                    <div style="flex: 1; min-width: 150px;">
                        <div style="font-size: 10px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 5px; color: #fbbf24;">DIFFICULTY</div>
                        <div style="font-size: 16px; font-weight: 700; color: #fff; text-transform: uppercase;">${caseData.difficulty}</div>
                </div>
                    <div style="flex: 2; min-width: 200px;">
                        <div style="font-size: 10px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 5px; color: #fbbf24;">COMPETENCIES</div>
                        <div style="font-size: 14px; font-weight: 500; color: #e2e8f0; line-height: 1.4;">${caseData.competencies}</div>
            </div>
                </div>
            </div>
            <div style="line-height: 1.7; white-space: pre-wrap; color: #cbd5e1; font-size: 14px; background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.6), rgba(15, 23, 42, 0.6)); padding: 1.25rem; border-radius: 12px; border: 1px solid rgba(251, 146, 60, 0.3); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);">
                <h3 style="color: #fff; margin: 0 0 0.75rem 0; font-size: 1.1rem; font-weight: 900; background: linear-gradient(to right, #fb923c, #fbbf24); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; border-bottom: 2px solid rgba(251, 146, 60, 0.4); padding-bottom: 0.5rem;">a Case Scenario</h3>
                ${caseData.caseText}
            </div>
        </div>
        
        <!-- Close Button -->
        <div id="caseCloseButton" style="position: fixed; top: 20px; right: 20px; font-size: 24px; font-weight: bold; cursor: pointer; color: #fb923c; z-index: 10001; background: rgba(30, 41, 59, 0.9); width: 44px; height: 44px; border-radius: 10px; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; border: 2px solid rgba(251, 146, 60, 0.4); box-shadow: 0 4px 12px rgba(251, 146, 60, 0.2);">
            Ã—
        </div>
    `;
    
    // Add hover effect to close button
    const closeBtn = document.getElementById('caseCloseButton');
    if (closeBtn) {
        closeBtn.addEventListener('mouseenter', () => {
            closeBtn.style.background = 'rgba(251, 146, 60, 0.2)';
            closeBtn.style.borderColor = 'rgba(251, 146, 60, 0.6)';
            closeBtn.style.color = '#ea580c';
            closeBtn.style.transform = 'scale(1.1)';
        });
        closeBtn.addEventListener('mouseleave', () => {
            closeBtn.style.background = 'rgba(30, 41, 59, 0.8)';
            closeBtn.style.borderColor = 'rgba(251, 146, 60, 0.4)';
            closeBtn.style.color = '#fb923c';
            closeBtn.style.transform = 'scale(1)';
        });
    }
    
    // Move video element to new container
    const videoContainer = document.getElementById('caseVideoContainer');
    if (videoContainer) {
        // If video doesn't exist, wait for it to be created by initializeCamera
        if (existingVideo && existingVideo.parentElement !== videoContainer) {
            videoContainer.appendChild(existingVideo);
        }
        
        // Ensure video styling when it exists
                // Ensure video styling when it exists
        if (existingVideo) {
            existingVideo.autoplay = true;
            existingVideo.playsinline = true;
            existingVideo.muted = true;
            existingVideo.style.cssText = `
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
                background: #000;
                position: absolute;
                top: 0;
                left: 0;
            `;
            
            // Restore stream if it was lost
            if (currentStream && !existingVideo.srcObject) {
                try {
                    existingVideo.srcObject = currentStream;
                    console.log('Restored video stream');
                } catch (err) {
                    console.error('Error restoring stream:', err);
                }
            }
        }
        
        // Check video status
        setTimeout(() => {
            const videoEl = document.getElementById('videoPreview');
            const statusEl = document.getElementById('videoStatus');
            
            if (!videoEl) {
                statusEl.textContent = 'Camera Feed: Initializing...';
                statusEl.style.background = 'rgba(15, 23, 42, 0.9)';
                statusEl.style.color = '#fbbf24';
                statusEl.style.border = '1px solid rgba(251, 191, 36, 0.5)';
                statusEl.style.boxShadow = '0 0 15px rgba(251, 191, 36, 0.3)';
                
                // Try to reinitialize camera
                setTimeout(() => {
                    if (window.originalCameraFunctions?.initializeCamera) {
                        console.log('Attempting to initialize camera...');
                        try {
                            window.originalCameraFunctions.initializeCamera();
                        } catch (err) {
                            console.error('Error initializing camera:', err);
                        }
                    }
                }, 500);
            } else if (videoEl.srcObject) {
                statusEl.textContent = 'Camera Feed: Active';
                statusEl.style.background = 'rgba(15, 23, 42, 0.9)';
                statusEl.style.color = '#10b981';
                statusEl.style.border = '1px solid rgba(16, 185, 129, 0.5)';
                statusEl.style.boxShadow = '0 0 15px rgba(16, 185, 129, 0.3)';
            } else {
                statusEl.textContent = 'Camera Feed: No Stream';
                statusEl.style.background = 'rgba(15, 23, 42, 0.9)';
                statusEl.style.color = '#ef4444';
                statusEl.style.border = '1px solid rgba(239, 68, 68, 0.5)';
                statusEl.style.boxShadow = '0 0 15px rgba(239, 68, 68, 0.3)';
                
                // Try to reinitialize camera
                setTimeout(() => {
                    if (window.originalCameraFunctions?.initializeCamera) {
                        console.log('Attempting to initialize camera...');
                        try {
                            window.originalCameraFunctions.initializeCamera();
                        } catch (err) {
                            console.error('Error initializing camera:', err);
                        }
                    }
                }, 500);
            }
        }, 500);
    }
    
    // Move buttons to new controls container (excluding close/X buttons)
    const controlsContainer = document.getElementById('caseControlsContainer');
    if (controlsContainer && existingButtons.length > 0) {
        existingButtons.forEach(btn => {
            // Skip close buttons (X buttons, close buttons)
            const btnText = btn.textContent?.trim() || '';
            const btnOnClick = btn.onclick?.toString() || '';
            const isCloseButton = btnText === 'Ã—' || 
                                 btnText === 'X' || 
                                 btnText.toLowerCase().includes('close') ||
                                 btnOnClick.includes('close') ||
                                 btn.classList.contains('close') ||
                                 btn.classList.contains('camera-close');
            
            if (!isCloseButton) {
            // Preserve original onclick handlers
            const originalOnClick = btn.onclick;
            btn.onclick = originalOnClick;
            controlsContainer.appendChild(btn);
            }
        });
        console.log(`Moved buttons to new container (excluding close buttons)`);
    }
    
    // Setup close button
    const closeButton = document.getElementById('caseCloseButton');
    if (closeButton) {
        closeButton.onclick = function() {
            restoreOriginalModal();
            if (window.originalCameraFunctions) {
                // Restore original functions
                window.startCameraRecording = window.originalCameraFunctions.startCameraRecording;
                window.stopCameraRecording = window.originalCameraFunctions.stopCameraRecording;
                window.toggleRecording = window.originalCameraFunctions.toggleRecording;
                window.initializeCamera = window.originalCameraFunctions.initializeCamera;
            }
            // Close modal
            modalWrapper.style.display = 'none';
        };

             // Initialize camera automatically using direct method
    setTimeout(() => {
        const videoEl = document.getElementById('videoPreview');
        if (videoEl && !videoEl.srcObject) {
            console.log('Auto-initializing camera with direct method...');
            directCameraInit();
        }
    }, 1000);
        
        // Hover effects already handled above
    }
}
function restoreOriginalModal() {
    const modalWrapper = document.getElementById('cameraModal');
    if (modalWrapper && modalWrapper.dataset.originalContent) {
        const modalContent = document.querySelector('#cameraModal .camera-questions-container')?.parentElement ||
                           document.querySelector('#cameraModal > div');
        if (modalContent) {
            modalContent.innerHTML = modalWrapper.dataset.originalContent;
            delete modalWrapper.dataset.originalContent;
        }
    }
}

// Add CSS for better visual feedback with orange/red theme
const style = document.createElement('style');
style.id = 'casePracticeModalStyle';
style.textContent = `
    #caseControlsContainer button {
        transition: all 0.3s ease;
        min-width: 140px;
        background: rgba(30, 41, 59, 0.6) !important;
        border: 2px solid rgba(251, 146, 60, 0.4) !important;
        color: #fb923c !important;
        border-radius: 12px !important;
        padding: 12px 20px !important;
        font-weight: 700 !important;
    }
    
    #caseControlsContainer button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(251, 146, 60, 0.4);
        background: rgba(251, 146, 60, 0.2) !important;
        border-color: rgba(251, 146, 60, 0.6) !important;
        color: #fbbf24 !important;
    }
    
    #caseControlsContainer .record-btn,
    #caseControlsContainer button[onclick*="toggleRecording"] {
        background: linear-gradient(135deg, #dc2626, #f97316, #fbbf24) !important;
        border: 3px solid rgba(251, 146, 60, 0.5) !important;
        color: white !important;
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3), 0 0 20px rgba(251, 146, 60, 0.2) !important;
    }
    
    #caseControlsContainer .record-btn:hover,
    #caseControlsContainer button[onclick*="toggleRecording"]:hover {
        background: linear-gradient(135deg, #ea580c, #fb923c, #fde047) !important;
        box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4), 0 0 30px rgba(251, 146, 60, 0.3) !important;
    }
    
    #caseControlsContainer .recording,
    #caseControlsContainer button.recording {
        background: linear-gradient(135deg, #dc2626, #f97316, #fbbf24) !important;
        animation: recordingPulse 1.5s ease-in-out infinite;
        box-shadow: 0 0 40px rgba(220, 38, 38, 0.8), 0 0 80px rgba(251, 146, 60, 0.5) !important;
    }
    
    @keyframes recordingPulse {
        0%, 100% { 
            box-shadow: 0 0 40px rgba(220, 38, 38, 0.8), 0 0 80px rgba(251, 146, 60, 0.5);
        }
        50% { 
            box-shadow: 0 0 60px rgba(220, 38, 38, 1), 0 0 120px rgba(251, 146, 60, 0.7);
        }
    }
    
    #caseControlsContainer button[onclick*="submit"] {
        background: linear-gradient(to right, #dc2626, #f97316, #fbbf24) !important;
        border: none !important;
        color: white !important;
        font-weight: 900 !important;
        text-transform: uppercase !important;
        letter-spacing: 0.05em !important;
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3) !important;
    }
    
    #caseControlsContainer button[onclick*="submit"]:hover {
        background: linear-gradient(to right, #ea580c, #fb923c, #fde047) !important;
        box-shadow: 0 8px 20px rgba(220, 38, 38, 0.4) !important;
    }
`;
if (!document.getElementById('casePracticeModalStyle')) {
document.head.appendChild(style);
}

async function restartCameraStream() {
    try {
        const videoElement = document.getElementById('videoPreview');
        if (!videoElement) return;
        
        // Stop any existing stream
        if (videoElement.srcObject) {
            videoElement.srcObject.getTracks().forEach(track => track.stop());
        }
        
        // Get new camera stream
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: 1280, height: 720 },
            audio: true 
        });
        
        videoElement.srcObject = stream;
        await videoElement.play();
        
    } catch (error) {
        console.error('Error restarting camera:', error);
    }
}

function waitForCameraInitialization() {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 50; // 5 seconds max wait
        
        function checkCamera() {
            attempts++;
            const videoElement = document.getElementById('videoPreview');
            const stream = videoElement?.srcObject;
            
            if (videoElement && stream) {
                resolve();
            } else if (attempts < maxAttempts) {
                setTimeout(checkCamera, 100);
            } else {
                reject(new Error('Camera initialization timeout'));
            }
        }
        
        checkCamera();
    });
}


document.addEventListener('DOMContentLoaded', function() {
    // Initialize case modal when DOM is ready
    setTimeout(() => {
        initializeCaseModalCompetitions();

    }, 1000);
});

async function populateCompetitionDropdown() {
    try {
        const user = firebase.auth().currentUser;
        if (!user) return;
        
        const userDoc = await db.collection('users').doc(user.uid).get();
        
        if (!userDoc.exists) return;
        
        const userData = userDoc.data();
        const compData = userData.competitions;
        
        // Handle both array and string cases
        const competitions = Array.isArray(compData) ? compData : 
                           (typeof compData === 'string' ? [compData] : []);
        
        const dropdown = document.getElementById('competitionSelectWritten');
        if (!dropdown) return;
        
        // Clear existing options except the first "Select competition..." option
        dropdown.innerHTML = '<option value="">Select competition...</option>';
        
        // Add competition options
        competitions.forEach(comp => {
            const option = document.createElement('option');
            option.value = comp;
            option.textContent = comp;
            dropdown.appendChild(option);
        });
        
        // Select the first competition by default
        if (competitions.length > 0) {
            dropdown.value = competitions[0];
            // Trigger the competency population for the default selection
            await populateCompetencyOptions(competitions[0]);
        }
        
        console.log('âœ… Competition dropdown populated with:', competitions);
        // Add this after you populate the case dropdown
const caseDropdown = document.getElementById('competitionSelectCase');
if (caseDropdown) {
    caseDropdown.innerHTML = '<option value="">Select competition...</option>';
    competitions.forEach(comp => {
        const option = document.createElement('option');
        option.value = comp;
        option.textContent = comp;
        caseDropdown.appendChild(option);
    });
    if (competitions.length > 0) {
        caseDropdown.value = competitions[0];
    }
    
    // ðŸŽ¯ ADD THIS: Event listener to update competencies when case dropdown changes
    caseDropdown.addEventListener('change', async function(e) {
        const selectedCompetition = e.target.value;
        if (selectedCompetition) {
            await populateCompetencyOptionsForCase(selectedCompetition);
        }
    });
    
    // ðŸŽ¯ ALSO trigger it initially for the auto-selected value
    if (competitions.length > 0) {
        await populateCompetencyOptionsForCase(competitions[0]);
    }
}
        
    } catch (error) {
        console.error('âŒ Error populating competition dropdown:', error);
    }
}


function closeWrittenModal() { closeModal('writtenModal'); }
  
    function closeSpeakingModal() { closeModal('speakingModal'); }

    function closeCaseModal() { closeModal('caseModal'); }
  
    // UI Selectors
    function selectTime(button) {
      document.querySelectorAll('.time-btn').forEach(btn => btn.classList.remove('selected'));
      button.classList.add('selected');
      // Also ensure the data-time attribute is set for compatibility
      if (!button.hasAttribute('data-time')) {
        const timeText = button.textContent.trim();
        const timeMatch = timeText.match(/(\d+)/);
        if (timeMatch) {
          button.setAttribute('data-time', timeMatch[1]);
        }
      }
    }
  
    function selectDifficulty(button, difficulty) {
      document.querySelectorAll('#caseModal .difficulty-btn').forEach(btn => btn.classList.remove('selected'));
      button.classList.add('selected');
      // Store selected difficulty for later use
      window.selectedCaseDifficulty = difficulty;
    }

    function setupCompetencyCheckboxes() {
    // Use event delegation for dynamically created checkboxes
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('competency-option')) {
            // Checkbox was clicked - handle the selection
            const checkbox = e.target;
            console.log('Checkbox clicked:', checkbox.value, checkbox.checked);
            
            // You can add any additional logic here
            updateSelectedCompetencies();
        }
    });
    
    // Also handle the select all button
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('select-all-btn') || 
            e.target.closest('.select-all-btn')) {
            selectAllCompetencies();
        }
    });
}
  
    function selectAllCompetencies() {
    const checkboxes = document.querySelectorAll('#caseModal .competency-option');
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
    
    checkboxes.forEach(checkbox => {
        checkbox.checked = !allChecked;
        // Trigger change event to update styling
        checkbox.dispatchEvent(new Event('change'));
    });
    
    console.log('Select all toggled. Checked:', !allChecked);
}

// Function to get selected competencies
function getSelectedCompetencies() {
    const selected = Array.from(document.querySelectorAll('.competency-option:checked'))
        .map(checkbox => checkbox.value);
    console.log('Selected competencies:', selected);
    return selected;
}
  
    // Question Generator (Speaking)
    // Add this hardcoded question bank
const SPEAKING_QUESTIONS_BANK = [
    "What inspired you to choose this particular topic for your speech?",
    "How does this topic relate to current business trends?",
    "What real-world applications does your topic have in the business world?",
    "What challenges did you face while researching this topic?",
    "How would you explain this concept to someone without business knowledge?",
    "What are the potential risks or drawbacks of your proposed solution?",
    "How does your topic impact small businesses specifically?",
    "What role does technology play in your topic area?",
    "How has this topic evolved over the past decade?",
    "What ethical considerations are involved in your topic?",
    "How would you implement your ideas in a real business setting?",
    "What are the financial implications of your topic?",
    "How does your topic relate to leadership and management?",
    "What are the global perspectives on your topic?",
    "How would you measure the success of your proposed solutions?",
    "What are the long-term implications of your topic?",
    "How does your topic connect to entrepreneurship?",
    "What regulatory or legal aspects should be considered?",
    "How would different stakeholders view your topic?",
    "What are the competitive advantages of your approach?"
];

// Replace the generateQuestions function:
// Global variable to store current questions


async function generateQuestions() {
    const speechInput = document.getElementById("speechInput");
    const speech = speechInput.value.trim();
    const selectedCompetition = document.getElementById('competitionSelectSpeaking')?.value;
    const questionArea = document.getElementById("questionArea");
    const questionList = document.getElementById("questionList");

    if (!speech) {
        alert("Paste your speech first!");
        return;
    }

    if (!selectedCompetition) {
        alert("Please select a competition!");
        return;
    }

    try {
        const apiKey = "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";
        
        // Improved prompt with strict formatting
        const prompt = `ANALYZE THIS SPEECH AND CREATE 3 FOLLOW-UP QUESTIONS:

SPEECH TEXT:
"""
${speech}
"""

CRITICAL FORMATTING REQUIREMENTS:
- Return EXACTLY 3 questions
- Each question must be on its own line
- Do NOT number the questions (no "1.", "2.", "3.")
- Do NOT use bullet points
- Each line should contain exactly one complete question ending with "?"
- Do not include any other text, explanations, or formatting

Generate 3 thoughtful, challenging questions that test the speaker's understanding:`;

        console.log("ðŸš€ Sending request to GPT...");
        console.log("Speech length:", speech.length);

        const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({messages: [{
                    role: 'system',
                    content: `You are an expert debate coach. Create 3 challenging follow-up questions based on speech content. Return ONLY the 3 questions, one per line, with no numbers, bullets, or additional text.`
                }, {
                    role: 'user',
                    content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt
                }], temperature: 0.7, max_tokens: 4000});

        // Firebase functions return { data: ... } directly
        if (!response || !response.data) {
            console.error("API Error: Invalid response", response);
            throw new Error(`API Error: Invalid response`);
        }

        const data = response.data;
        // Handle different response formats
        const responseText = (data.content || data.text || data || '').toString().trim();
        
        console.log("âœ… Raw GPT Response:", responseText);

        // SIMPLIFIED PARSING - Just split by new lines and filter
        let generatedQuestions = responseText.split('\n')
            .map(line => line.trim())
            .filter(line => {
                // Keep lines that are actual questions (end with ? and have reasonable length)
                return line.endsWith('?') && 
                       line.length > 10 && 
                       line.length < 250 &&
                       !line.startsWith('1.') && 
                       !line.startsWith('2.') && 
                       !line.startsWith('3.') &&
                       !line.startsWith('-') &&
                       !line.startsWith('â€¢');
            })
            .slice(0, 3); // Take first 3 valid questions

        console.log("ðŸ“ Parsed questions:", generatedQuestions);

        // If we have exactly 3 questions, use them directly
        if (generatedQuestions.length === 3) {
            console.log("ðŸŽ¯ Successfully parsed 3 questions from GPT response");
            currentGeneratedQuestions = generatedQuestions;
        } 
        // If we have some questions but not 3, try to extract more
        else if (generatedQuestions.length > 0 && generatedQuestions.length < 3) {
            console.log("ðŸ”„ Found some questions, trying to extract more...");
            
            // Try splitting by question marks more aggressively
            const allQuestions = responseText.split('?')
                .map(q => q.trim() + '?')
                .filter(q => q.length > 15 && q.length < 250)
                .slice(0, 3);
            
            if (allQuestions.length >= 2) {
                generatedQuestions = allQuestions;
                console.log("âœ… Extracted additional questions:", generatedQuestions);
            }
        }

        // Final check - if we still don't have good questions, use the raw response lines
        if (generatedQuestions.length < 2) {
            console.log("âš ï¸ Using raw response lines as fallback");
            generatedQuestions = responseText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 20)
                .slice(0, 3);
        }

        // Store questions globally
        currentGeneratedQuestions = generatedQuestions;
        console.log("ðŸŽ¯ Final questions to use:", currentGeneratedQuestions);

        // Update the UI
        speechInput.closest(".modal-section").style.display = "none";
        questionList.innerHTML = "";
        
        generatedQuestions.forEach((q, index) => {
            const card = document.createElement("div");
            card.className = "question-card";
            card.innerHTML = `<strong>Question ${index + 1}:</strong> ${q}`;
            questionList.appendChild(card);
        });

        questionArea.classList.remove("hidden");
        
        console.log("âœ… Questions displayed in UI");
        
    } catch (error) {
        console.error('âŒ Error generating questions:', error);
        
        // Enhanced fallback with speech context
        const fallbackQuestions = [
            "What was the most important point you wanted your audience to remember from your speech?",
            "How would you apply the concepts from your speech to address current business challenges?",
            "What research or experience influenced the perspectives you shared in your speech?"
        ];
        
        currentGeneratedQuestions = fallbackQuestions;

        // Update UI with fallback questions
        speechInput.closest(".modal-section").style.display = "none";
        questionList.innerHTML = "";
        fallbackQuestions.forEach((q, index) => {
            const card = document.createElement("div");
            card.className = "question-card";
            card.innerHTML = `<strong>Question ${index + 1}:</strong> ${q}`;
            questionList.appendChild(card);
        });
        questionArea.classList.remove("hidden");
        
        console.log("ðŸ”„ Using fallback questions due to error");
    }
}

// Function to get competencies from the most recent submission
// Function to get competencies from the most recent submission
async function getCompetenciesFromLatestSubmission(competitionName) {
    if (!competitionName) {
        console.log('âš ï¸ No competition name provided');
        return [];
    }
    
    try {
        console.log('ðŸ” Searching for submissions for competition:', competitionName);
        
        const snapshot = await db.collection('competition-submissions')
            .where('competition', '==', competitionName)
            .orderBy('processedAt', 'desc')
            .limit(1)
            .get();
        
        console.log('ðŸ“Š Snapshot empty?', snapshot.empty);
        console.log('ðŸ“Š Number of docs found:', snapshot.size);
        
        if (!snapshot.empty) {
            const latestDoc = snapshot.docs[0].data();
            const extractedCompetencies = latestDoc.extractedCompetencies;
            
            console.log('ðŸ“‹ Raw extractedCompetencies:', extractedCompetencies);
            
            if (extractedCompetencies) {
                const competencyLines = extractedCompetencies
                    .split('\n')
                    .filter(line => /^[A-Z]\.\s+/.test(line.trim()))
                    .map(line => line.replace(/^[A-Z]\.\s*/, '').trim())
                    .filter(comp => comp.length > 0);
                
                console.log('âœ… Extracted competency lines:', competencyLines);
                return competencyLines;
            } else {
                console.log('âš ï¸ No extractedCompetencies field found');
            }
        } else {
            console.log('âš ï¸ No submissions found for competition:', competitionName);
        }
        
        return [];
    } catch (error) {
        console.error('âŒ Error fetching competencies:', error);
        return [];
    }
}

// Add this RIGHT AFTER you create the event listener
document.addEventListener('DOMContentLoaded', function() {
    const dropdown = document.getElementById('competitionSelectWritten');
    console.log('ðŸŽ¯ Dropdown element found:', dropdown);
    
    if (dropdown) {
        dropdown.addEventListener('change', async function(e) {
            console.log('ðŸ”¥ DROPDOWN CHANGED!!!');
            console.log('Selected value:', e.target.value);
            const selectedCompetition = e.target.value;
            if (selectedCompetition) {
                await populateCompetencyOptions(selectedCompetition);
            }
        });
        
        console.log('âœ… Change listener attached to dropdown');
    } else {
        console.error('âŒ Dropdown not found!');
    }
});


async function populateCompetencyOptions(competitionName) {
    console.log('ðŸš€ populateCompetencyOptions called with:', competitionName);
    
    const competencies = await getCompetenciesFromLatestSubmission(competitionName);
    console.log('ðŸ“¦ Competencies returned:', competencies);
    
    const checkboxGroup = document.querySelector('.written-checkbox-group');
    
    if (!checkboxGroup) {
        console.error('âŒ Checkbox group not found!');
        return;
    }
    
    console.log('âœ… Checkbox group found');
    
    // Clear existing checkboxes
    checkboxGroup.innerHTML = '';
    
    // Use extracted competencies or fallback to defaults
    const competenciesToUse = competencies.length > 0 ? competencies : [
        'Business Communication',
        'Marketing',
        'Accounting',
        'Economics',
        'Business Law',
        'Management',
        'Entrepreneurship',
        'Finance',
        'International Business',
        'Business Ethics',
        'Parliamentary Procedure'
    ];
    
    console.log('âœ¨ Using competencies:', competenciesToUse);
    
    competenciesToUse.forEach((comp, index) => {
        console.log(`  Adding competency ${index + 1}:`, comp);
        
        const checkboxItem = document.createElement('div');
        checkboxItem.className = 'written-checkbox-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'competency-option';
        checkbox.value = comp;
        checkbox.id = `competency-${comp.replace(/\s+/g, '-')}`;
        
        const label = document.createElement('label');
        label.setAttribute('for', checkbox.id);
        label.textContent = comp;
        
        checkboxItem.appendChild(checkbox);
        checkboxItem.appendChild(label);
        checkboxGroup.appendChild(checkboxItem);
    });
    
    console.log('âœ… Competencies populated successfully!');
}

// Add CSS to ensure checkboxes are visible and clickable
function fixCheckboxCSS() {
    const style = document.createElement('style');
    style.textContent = `
        /* Ensure checkboxes are visible and clickable */
        .competency-option {
            width: 18px !important;
            height: 18px !important;
            margin-right: 8px !important;
            cursor: pointer !important;
            position: relative !important;
            z-index: 1 !important;
        }
        
        .checkbox-group label {
            display: flex !important;
            align-items: center !important;
            margin-bottom: 8px !important;
            cursor: pointer !important;
            padding: 4px 0 !important;
        }
        
        .checkbox-group label:hover {
            background-color: #f5f5f5 !important;
            border-radius: 4px !important;
        }
        
        /* Make sure the checkbox group container is properly styled */
        .checkbox-group {
            max-height: 300px !important;
            overflow-y: auto !important;
            padding: 10px !important;
            border: 1px solid #e0e0e0 !important;
            border-radius: 8px !important;
            margin-top: 10px !important;
        }
    `;
    document.head.appendChild(style);
}

// Initialize everything when the page loads
document.addEventListener('DOMContentLoaded', function() {
    setupCompetencyCheckboxes();
    fixCheckboxCSS();
    
    // Also set up the competition dropdown change listener
    const competitionDropdown = document.getElementById('competitionSelectWritten');
    if (competitionDropdown) {
        competitionDropdown.addEventListener('change', async function(e) {
            const selectedCompetition = e.target.value;
            if (selectedCompetition) {
                await populateCompetencyOptions(selectedCompetition);
            }
        });
    }
    
    // Test function to verify checkboxes are working
    window.testCheckboxes = function() {
        const checkboxes = document.querySelectorAll('.competency-option');
        console.log('Found checkboxes:', checkboxes.length);
        checkboxes.forEach((cb, i) => {
            console.log(`Checkbox ${i}:`, cb.value, cb.checked, cb);
        });
    };
});

// For speaking modal
document.getElementById('competitionSelectSpeaking')?.addEventListener('change', function(e) {
    const selectedCompetition = e.target.value;
    if (selectedCompetition) {
        populateCompetencyOptionsForSpeaking(selectedCompetition);
    }
});

// For case modal  
document.getElementById('competitionSelectCase')?.addEventListener('change', function(e) {
    const selectedCompetition = e.target.value;
    if (selectedCompetition) {
        populateCompetencyOptionsForCase(selectedCompetition);
    }
});

// You'll need to create similar functions for speaking and case modals
async function populateCompetencyOptionsForSpeaking(competitionName) {
    // Similar implementation but for speaking modal
    const competencies = await getCompetenciesFromLatestSubmission(competitionName);
    const competencyGrid = document.querySelector('.speaking-modal .competency-grid');
    
    if (competencyGrid) {
        competencyGrid.innerHTML = '';
        competencies.forEach(comp => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" class="competency-option" value="${comp}"> ${comp}`;
            competencyGrid.appendChild(label);
        });
    }
}

async function populateCompetencyOptionsForCase(competitionName) {
    // Similar implementation but for case modal
    const competencies = await getCompetenciesFromLatestSubmission(competitionName);
    const competencyGrid = document.querySelector('#caseModal .competency-grid');
    
    if (competencyGrid) {
        competencyGrid.innerHTML = '';
        competencies.forEach(comp => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" class="competency-option" value="${comp}"> ${comp}`;
            competencyGrid.appendChild(label);
        });
    }
}
 // Save quiz to Firebase
async function saveQuizToFirebase(quizData) {
  const user = firebase.auth().currentUser;
  if (!user) {
    throw new Error('User not authenticated');
  }

  const quizDoc = {
    title: `${quizData.difficulty} ${quizData.type} Practice`,
    type: quizData.type,
    difficulty: quizData.difficulty,
    timeLimit: quizData.time,
    competencies: quizData.competencies,
    questions: quizData.questions, // This now matches your exact format
    questionCount: quizData.questions.length,
    createdBy: user.uid,
    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    status: 'ready',
    simulate: quizData.simulate || false,
    // Add fields for quiz taking
    maxScore: quizData.questions.length,
    passingScore: Math.ceil(quizData.questions.length * 0.7) // 70% to pass
  };

  const docRef = await firebase.firestore().collection('quizzes').add(quizDoc);
  return docRef.id;
}


function formatCaseStudyContent() {
    // Get the case content element
    const caseContent = document.getElementById('caseContent');
    if (!caseContent) return;
    
    // Get the raw text content
    const rawText = caseContent.textContent || caseContent.innerText;
    
    // Parse the content to extract competencies and prompt sections
    const sections = parseCaseStudyContent(rawText);
    
    // Create the formatted HTML structure
    const formattedHTML = createFormattedCaseStudyHTML(sections);
    
    // Replace the content
    caseContent.innerHTML = formattedHTML;
}

function parseCaseStudyContent(text) {
    const sections = {
        competition: '',
        difficulty: '',
        focusCompetencies: [],
        scenario: '',
        challenge: '',
        questions: [],
        competencies: []
    };
    
    // Split by sections
    const lines = text.split('\n').filter(line => line.trim());
    
    let currentSection = '';
    
    lines.forEach(line => {
        line = line.trim();
        
        if (line.includes('Competition:')) {
            sections.competition = line.replace('Competition:', '').trim();
        } else if (line.includes('Difficulty:')) {
            sections.difficulty = line.replace('Difficulty:', '').trim();
        } else if (line.includes('Focus Competencies:')) {
            const competenciesText = line.replace('Focus Competencies:', '').trim();
            sections.focusCompetencies = competenciesText.split(',').map(c => c.trim());
        } else if (line.includes('SCENARIO BACKGROUND:') || line.includes('1. SCENARIO BACKGROUND:')) {
            currentSection = 'scenario';
        } else if (line.includes('SPECIFIC CHALLENGE OR PROBLEM:') || line.includes('2. SPECIFIC CHALLENGE OR PROBLEM:')) {
            currentSection = 'challenge';
        } else if (line.includes('KEY QUESTIONS') || line.includes('3. KEY QUESTIONS')) {
            currentSection = 'questions';
        } else if (line.includes('EXPECTED COMPETENCIES') || line.includes('4. EXPECTED COMPETENCIES')) {
            currentSection = 'competencies';
        } else if (currentSection && line) {
            if (currentSection === 'questions' && /^[a-d]\)/.test(line)) {
                sections.questions.push(line);
            } else if (currentSection === 'competencies' && line.includes(':')) {
                sections.competencies.push(line);
            } else {
                // Add to the current section
                if (sections[currentSection]) {
                    sections[currentSection] += ' ' + line;
                } else {
                    sections[currentSection] = line;
                }
            }
        }
    });
    
    return sections;
}

function createFormattedCaseStudyHTML(sections) {
    return `
    <div class="case-study-container" style="
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
        margin-top: 20px;
    ">
        <!-- Competencies Box -->
        <div class="competencies-box" style="
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e5e7eb;
            border-left: 5px solid #3b82f6;
        ">
            <div class="box-header" style="
                display: flex;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 1px solid #e5e7eb;
            ">
                <div class="box-icon" style="
                    width: 40px;
                    height: 40px;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin-right: 15px;
                    font-weight: bold;
                    color: white;
                    background-color: #3b82f6;
                ">C</div>
                <h3 style="
                    font-size: 1.3rem;
                    font-weight: 700;
                    color: #1e293b;
                    margin: 0;
                ">Competencies Tested</h3>
            </div>
            
            <div class="competencies-content">
                ${sections.focusCompetencies.map(competency => `
                    <div class="competency-item" style="
                        margin-bottom: 15px;
                        padding: 12px 15px;
                        background-color: #f8fafc;
                        border-radius: 8px;
                        border-left: 3px solid #3b82f6;
                    ">
                        <div class="competency-title" style="
                            font-weight: 600;
                            color: #1e293b;
                            margin-bottom: 5px;
                        ">${competency}</div>
                    </div>
                `).join('')}
                
                ${sections.competencies && sections.competencies.length > 0 ? `
                    ${sections.competencies.map(competency => {
                        const [title, description] = competency.split(':');
                        return `
                            <div class="competency-item" style="
                                margin-bottom: 15px;
                                padding: 12px 15px;
                                background-color: #f8fafc;
                                border-radius: 8px;
                                border-left: 3px solid #3b82f6;
                            ">
                                <div class="competency-title" style="
                                    font-weight: 600;
                                    color: #1e293b;
                                    margin-bottom: 5px;
                                ">${title}</div>
                                <div class="competency-desc" style="
                                    font-size: 0.9rem;
                                    color: #64748b;
                                ">${description}</div>
                            </div>
                        `;
                    }).join('')}
                ` : ''}
            </div>
        </div>
        
        <!-- Case Prompt Box -->
        <div class="prompt-box" style="
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e5e7eb;
            border-left: 5px solid #10b981;
        ">
            <div class="box-header" style="
                display: flex;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 1px solid #e5e7eb;
            ">
                <div class="box-icon" style="
                    width: 40px;
                    height: 40px;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin-right: 15px;
                    font-weight: bold;
                    color: white;
                    background-color: #10b981;
                ">P</div>
                <h3 style="
                    font-size: 1.3rem;
                    font-weight: 700;
                    color: #1e293b;
                    margin: 0;
                ">Case Study Prompt</h3>
            </div>
            
            <div class="prompt-content">
                <!-- Meta Info -->
                <div class="meta-info" style="
                    display: flex;
                    gap: 20px;
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #f0f9ff;
                    border-radius: 8px;
                    font-size: 0.9rem;
                ">
                    <div>
                        <strong>Competition:</strong> ${sections.competition}
                    </div>
                    <div>
                        <strong>Difficulty:</strong> ${sections.difficulty}
                    </div>
                </div>
                
                <!-- Scenario -->
                <div class="prompt-section" style="margin-bottom: 25px;">
                    <div class="prompt-section-title" style="
                        font-weight: 600;
                        color: #1e293b;
                        margin-bottom: 10px;
                        font-size: 1.1rem;
                    ">Scenario Background</div>
                    <div class="prompt-section-content" style="
                        background-color: #f8fafc;
                        padding: 15px;
                        border-radius: 8px;
                        line-height: 1.6;
                    ">
                        ${sections.scenario || 'No scenario provided'}
                    </div>
                </div>
                
                <!-- Challenge -->
                <div class="prompt-section" style="margin-bottom: 25px;">
                    <div class="prompt-section-title" style="
                        font-weight: 600;
                        color: #1e293b;
                        margin-bottom: 10px;
                        font-size: 1.1rem;
                    ">Specific Challenge</div>
                    <div class="prompt-section-content" style="
                        background-color: #f8fafc;
                        padding: 15px;
                        border-radius: 8px;
                        line-height: 1.6;
                    ">
                        ${sections.challenge || 'No challenge provided'}
                    </div>
                </div>
                
                <!-- Questions -->
                <div class="prompt-section">
                    <div class="prompt-section-title" style="
                        font-weight: 600;
                        color: #1e293b;
                        margin-bottom: 10px;
                        font-size: 1.1rem;
                    ">Key Questions</div>
                    <div class="prompt-section-content" style="
                        background-color: #f8fafc;
                        padding: 15px;
                        border-radius: 8px;
                    ">
                        <ol class="question-list" style="
                            padding-left: 20px;
                            margin: 0;
                        ">
                            ${sections.questions.map(question => `
                                <li style="margin-bottom: 8px; line-height: 1.5;">${question}</li>
                            `).join('')}
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <style>
        @media (max-width: 768px) {
            .case-study-container {
                grid-template-columns: 1fr !important;
            }
        }
    </style>
    `;
}

function enhanceGeneratedCase() {
    // Wait a bit for the content to be rendered
    setTimeout(() => {
        formatCaseStudyContent();
    }, 100);
}
  
    // Case Prompt Generator
async function generateCase() {
    const selectedCompetition = document.getElementById('competitionSelectCase')?.value;
    const selectedCompetencies = Array.from(document.querySelectorAll('#caseModal .competency-option:checked'))
        .map(checkbox => checkbox.value);
    document.querySelector('#caseModal .generate-btn').textContent = 'Generating Case...';

    document.getElementById('caseCompetition').textContent = selectedCompetition;
    
    if (selectedCompetencies.length === 0 || selectedCompetencies.length > 5) {
        alert("Please choose between 1 to 5 competencies.");
        return;
    }

    if (!selectedCompetition) {
        alert("Please select a competition!");
        return;
    }

    const difficulty = document.querySelector('.difficulty-btn.selected')?.textContent;
    if (!difficulty) {
        alert("Please select a difficulty.");
        return;
    }

    try {
        const apiKey = "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";
        
        const trainingData = await getAllTrainingEntries(selectedCompetition);
        const latestKeyChanges = await getLatestKeyChanges(selectedCompetition);
        
        let prompt = `Generate a realistic ${selectedCompetition} case study scenario with EASY difficulty.

SPECIFIC REQUIREMENTS:
- Competition: ${selectedCompetition}
- Focus Competencies: ${selectedCompetencies.join(', ')}
- Difficulty: ${difficulty}
- Make it appropriate for high school students
- Include specific business scenarios that test these competencies
- Provide clear context and challenges

COMPETENCY FOCUS AREAS:`;

        selectedCompetencies.forEach(comp => {
            prompt += `\n- ${comp}: `;
            switch(comp) {
                case 'Teamwork':
                    prompt += "Include group dynamics, collaboration challenges, team roles";
                    break;
                case 'Leadership':
                    prompt += "Include decision-making, motivating others, responsibility";
                    break;
                case 'Innovation':
                    prompt += "Include creative problem-solving, new ideas, adapting to change";
                    break;
                case 'Communication':
                    prompt += "Include clear messaging, conflict resolution, presentation skills";
                    break;
                case 'Ethics':
                    prompt += "Include moral dilemmas, integrity, doing the right thing";
                    break;
                case 'Problem Solving':
                    prompt += "Include analytical thinking, solution development, implementation";
                    break;
                default:
                    prompt += "Include relevant business challenges and decision points";
            }
        });

        if (trainingData?.pdfContent) {
            prompt += `\n\nCOMPETITION CONTEXT (use for inspiration but create original case):
${trainingData.pdfContent.substring(0, 2000)}`;
        }

        if (latestKeyChanges) {
            prompt += `\n\nRECENT COMPETITION UPDATES TO CONSIDER:
${latestKeyChanges}`;
        }

        prompt += `\n\nCASE STRUCTURE:
1. Scenario Background (setting, context, characters)
2. Specific Challenge or Problem
3. Key Questions the participant should address
4. Expected competencies to demonstrate

Make the case engaging, realistic, and clearly connected to the selected competencies.`;

        console.log("Generating case with prompt:", prompt);

        const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({messages: [{
                    role: 'system',
                    content: `You are an expert ${selectedCompetition} case study writer. Create engaging, realistic business scenarios that clearly test specific competencies. Make cases appropriate for high school students and directly relevant to the competition focus.`
                }, {
                    role: 'user',
                    content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt
                }], temperature: 0.7, max_tokens: 4000});

        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }

        const data = response.data;
        const generatedCase = data.content;

        // Hide prompt section and show results
        document.getElementById('casePromptSection').style.display = 'none';
        document.getElementById('caseResultSection').style.display = 'block';
        
        // Hide the old case prompt box
        const oldCaseBox = document.querySelector('#caseResultSection > div[style*="background:#f3f6fa"]');
        if (oldCaseBox) {
            oldCaseBox.style.display = 'none';
        }
        
        // Update the metadata box (for backward compatibility)
        document.getElementById('caseDifficulty').textContent = difficulty;
        document.getElementById('caseCompetencies').textContent = selectedCompetencies.join(', ');
        
        // Update or create the case content with new styling
        let caseContentContainer = document.getElementById('caseContentContainer');
        if (!caseContentContainer) {
            caseContentContainer = document.createElement('div');
            caseContentContainer.id = 'caseContentContainer';
            document.getElementById('caseResultSection').appendChild(caseContentContainer);
        }
        
        caseContentContainer.innerHTML = `
            <!-- Metadata Box -->
            <div style="
                background: linear-gradient(to bottom right, rgba(59, 130, 246, 0.3), rgba(30, 41, 59, 0.6));
                padding: 1rem;
                border-radius: 12px;
                margin-bottom: 1rem;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                border: 1px solid rgba(59, 130, 246, 0.4);
                color: white;
            ">
                <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: center;">
                    <div style="flex: 1; min-width: 200px;">
                        <div style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 5px; color: #93c5fd;">COMPETITION</div>
                        <div style="font-size: 15px; font-weight: 700; color: #fff;">${selectedCompetition}</div>
                    </div>
                    <div style="flex: 1; min-width: 150px;">
                        <div style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 5px; color: #93c5fd;">DIFFICULTY</div>
                        <div style="font-size: 15px; font-weight: 700; color: #fff; text-transform: uppercase;">${difficulty}</div>
                    </div>
                    <div style="flex: 2; min-width: 250px;">
                        <div style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 5px; color: #93c5fd;">FOCUS COMPETENCIES</div>
                        <div style="font-size: 13px; font-weight: 500; color: #e2e8f0; line-height: 1.4;">${selectedCompetencies.join(', ')}</div>
                    </div>
                </div>
            </div>
            
            <!-- Case Content Box -->
            <div style="
                background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.8));
                padding: 1rem;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                border: 1px solid rgba(251, 146, 60, 0.3);
                line-height: 1.6;
                margin-bottom: 1rem;
            ">
                <h3 style="
                    color: #fff;
                    margin: 0 0 0.75rem 0;
                    font-size: 1.1rem;
                    font-weight: 900;
                    background: linear-gradient(to right, #fb923c, #fbbf24);
                    -webkit-background-clip: text;
                    background-clip: text;
                    -webkit-text-fill-color: transparent;
                    border-bottom: 2px solid rgba(251, 146, 60, 0.4);
                    padding-bottom: 0.5rem;
                ">ðŸ“‹ Case Study</h3>
                <div style="color: #cbd5e1; white-space: pre-wrap; font-size: 13px; line-height: 1.6; margin: 0;">${generatedCase}</div>
            </div>
        `;
        
        enhanceGeneratedCase();
        document.querySelector('#caseModal .generate-btn').textContent = 'Generate Case';

    } catch (error) {
        console.error('Error generating case:', error);
        
        const fallbackCase = generateFallbackCase(selectedCompetition, selectedCompetencies, difficulty);
        
        document.getElementById('casePromptSection').style.display = 'none';
        document.getElementById('caseResultSection').style.display = 'block';
        document.getElementById('caseDifficulty').textContent = difficulty;
        document.getElementById('caseCompetencies').textContent = selectedCompetencies.join(', ');
        
        // Hide the old case prompt box
        const oldCaseBox = document.querySelector('#caseResultSection > div[style*="background:#f3f6fa"]');
        if (oldCaseBox) {
            oldCaseBox.style.display = 'none';
        }
        
        let caseContentContainer = document.getElementById('caseContentContainer');
        if (!caseContentContainer) {
            caseContentContainer = document.createElement('div');
            caseContentContainer.id = 'caseContentContainer';
            document.getElementById('caseResultSection').appendChild(caseContentContainer);
        }
        
        caseContentContainer.innerHTML = `
            <!-- Metadata Box -->
            <div style="
                background: linear-gradient(to bottom right, rgba(59, 130, 246, 0.3), rgba(30, 41, 59, 0.6));
                padding: 1.25rem 1.5rem;
                border-radius: 16px;
                margin-bottom: 1.5rem;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                border: 1px solid rgba(59, 130, 246, 0.4);
                color: white;
            ">
                <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
                    <div style="flex: 1; min-width: 200px;">
                        <div style="font-size: 10px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 6px; color: #93c5fd;">COMPETITION</div>
                        <div style="font-size: 16px; font-weight: 700; color: #fff;">${selectedCompetition}</div>
                    </div>
                    <div style="flex: 1; min-width: 150px;">
                        <div style="font-size: 10px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 6px; color: #93c5fd;">DIFFICULTY</div>
                        <div style="font-size: 16px; font-weight: 700; color: #fff; text-transform: uppercase;">${difficulty}</div>
                    </div>
                    <div style="flex: 2; min-width: 250px;">
                        <div style="font-size: 10px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 6px; color: #93c5fd;">FOCUS COMPETENCIES</div>
                        <div style="font-size: 14px; font-weight: 500; color: #e2e8f0; line-height: 1.5;">${selectedCompetencies.join(', ')}</div>
                    </div>
                </div>
            </div>
            
            <!-- Case Content Box -->
            <div style="
                background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.8));
                padding: 1.5rem;
                border-radius: 16px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                border: 1px solid rgba(251, 146, 60, 0.3);
                line-height: 1.7;
                margin-bottom: 1.5rem;
            ">
                <h3 style="
                    color: #fff;
                    margin: 0 0 1.25rem 0;
                    font-size: 1.25rem;
                    font-weight: 900;
                    background: linear-gradient(to right, #fb923c, #fbbf24);
                    -webkit-background-clip: text;
                    background-clip: text;
                    -webkit-text-fill-color: transparent;
                    border-bottom: 2px solid rgba(251, 146, 60, 0.4);
                    padding-bottom: 0.75rem;
                ">ðŸ“‹ Case Study</h3>
                <div style="color: #cbd5e1; white-space: pre-wrap; font-size: 14px; line-height: 1.7; margin: 0;">${fallbackCase}</div>
            </div>
        `;
    }
    setupModalReset();
}

function openCaseCameraModal(caseData = null) {
    // Add modal HTML if it doesn't exist
    if (!document.getElementById('cameraModal')) {
        addCameraModalHTML();
        addCameraModalCSS();
        addImprovedCameraCSS();
    }
    
    // Get case data from the current generated case
    const caseInfo = caseData || {
        competition: document.getElementById('caseCompetition')?.textContent || 'Unknown',
        difficulty: document.getElementById('caseDifficulty')?.textContent || 'Easy',
        competencies: document.getElementById('caseCompetencies')?.textContent || '',
        caseText: document.getElementById('caseText')?.textContent || 
                  document.querySelector('#caseContentContainer [style*="white-space: pre-wrap"]')?.textContent || 
                  'No case available'
    };
    
    // Store case info globally for recording metadata
    window.currentCaseInfo = caseInfo;
    
    // Update modal title
    document.getElementById('cameraModalTitle').textContent = `${caseInfo.competition} Case Practice`;
    
    // Replace question elements with case prompt display
    const q1Element = document.getElementById('cameraQ1');
    const q2Element = document.getElementById('cameraQ2');
    
    if (q1Element && q2Element) {
        // Hide original questions and create case display
        q1Element.style.display = 'none';
        q2Element.style.display = 'none';
        
        // Create or update case display container
        let caseDisplay = document.getElementById('cameraCaseDisplay');
        if (!caseDisplay) {
            caseDisplay = document.createElement('div');
            caseDisplay.id = 'cameraCaseDisplay';
            q2Element.parentNode.insertBefore(caseDisplay, q2Element);
        }
        
        caseDisplay.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
                padding: 15px;
                border-radius: 10px;
                margin-bottom: 15px;
                color: white;
                font-size: 14px;
            ">
                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 150px;">
                        <div style="font-size: 11px; opacity: 0.9; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 3px;">Difficulty</div>
                        <div style="font-size: 16px; font-weight: 600;">${caseInfo.difficulty}</div>
                    </div>
                    <div style="flex: 2; min-width: 200px;">
                        <div style="font-size: 11px; opacity: 0.9; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 3px;">Focus Competencies</div>
                        <div style="font-size: 14px; font-weight: 500;">${caseInfo.competencies}</div>
                    </div>
                </div>
            </div>
            
            <div style="
                background: white;
                padding: 20px;
                border-radius: 10px;
                max-height: 400px;
                overflow-y: auto;
                border: 1px solid #e0e0e0;
                box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            ">
                <h4 style="
                    margin-top: 0;
                    margin-bottom: 15px;
                    color: #333;
                    font-size: 16px;
                    border-bottom: 2px solid #4A90E2;
                    padding-bottom: 8px;
                ">ðŸ“‹ Case Study</h4>
                <div style="
                    color: #444;
                    line-height: 1.7;
                    font-size: 14px;
                    white-space: pre-wrap;
                ">${caseInfo.caseText}</div>
            </div>
            
            <div style="
                margin-top: 15px;
                padding: 12px;
                background: #fff3cd;
                border-left: 4px solid #ffc107;
                border-radius: 5px;
                font-size: 13px;
                color: #856404;
            ">
                <strong>ðŸ’¡ Recording Instructions:</strong> Read the case carefully, then record your response addressing the key questions and demonstrating the focus competencies.
            </div>
        `;
    }
    
    // Reset recording state
    isRecording = false;
    window.recordedBlob = null;
    resetRecordingUI();
    
    // Show modal with animation
    const modal = document.getElementById('cameraModal');
    modal.style.display = 'flex';
    setTimeout(() => modal.classList.add('active'), 10);
    
    // Initialize camera
    initializeCamera();
}

// Update the button event listeners in your generateCase function
// Add this after the case is generated:
function setupCasePracticeButtons() {
    // Add event listeners to Audio and Video buttons
    const audioBtn = document.querySelector('button:contains("Audio")'); // Adjust selector as needed
    const videoBtn = document.querySelector('button:contains("Video")'); // Adjust selector as needed
    
    if (audioBtn) {
        audioBtn.addEventListener('click', () => {
            openCaseCameraModal();
        });
    }
    
    if (videoBtn) {
        videoBtn.addEventListener('click', () => {
            openCaseCameraModal();
        });
    }
}


// Add fallback case generator
function generateFallbackCase(competition, competencies, difficulty) {
    const competencyText = competencies.join(' and ');
    
    return `
    <strong>${competition} Case Scenario</strong>
    <br><br>
    <strong>Scenario:</strong> You are part of a student team organizing a ${competition} event for your school. Your team has been tasked with planning and executing a major project with limited resources and tight deadlines.
    <br><br>
    <strong>Challenge:</strong> Your team is facing internal conflicts, budget constraints, and competing priorities from different stakeholders. You need to demonstrate ${competencyText} to successfully complete the project.
    <br><br>
    <strong>Your Task:</strong>
    1. How would you address the team conflicts and improve collaboration?
    2. What strategies would you use to manage the limited resources effectively?
    3. How would you communicate with stakeholders about challenges and progress?
    4. What creative solutions can you propose to overcome the obstacles?
    <br><br>
    <strong>Expected Demonstration:</strong> Show how you would apply ${competencyText} to resolve this situation and achieve a successful outcome.
    `;
}

// --- Recording ---
 // Fix the stopAllMedia function
window.stopAllMedia = function() {
    if (window.mediaRecorder && typeof window.mediaRecorder.stop === 'function' && window.mediaRecorder.state !== "inactive") {
        try {
            window.mediaRecorder.stop();
        } catch(e) {
            console.log('Error stopping recorder:', e);
        }
    }
    
    if (window.mediaStream && typeof window.mediaStream.getTracks === 'function') {
        window.mediaStream.getTracks().forEach(track => track.stop());
        window.mediaStream = null;
    }
    
    // Also try cameraStream
    if (window.cameraStream && typeof window.cameraStream.getTracks === 'function') {
        window.cameraStream.getTracks().forEach(track => track.stop());
        window.cameraStream = null;
    }
};

// Now check if the layout looks right
console.log('Does it look better? Camera on left, one case on right?');
  
    function startAudio(context) {
      stopAllMedia();
      recordedChunks = [];
  
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          mediaStream = stream;
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
          mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const audioURL = URL.createObjectURL(blob);
            const audio = document.getElementById(`audioPlayback${capitalize(context)}`);
            audio.src = audioURL;
            audio.style.display = 'block';
          };
          mediaRecorder.start();
          document.getElementById(`stopBtn${capitalize(context)}`).style.display = 'inline-block';
        })
        .catch(err => {
          alert('Microphone permission denied.');
          console.error(err);
        });
    }
  
    function startVideo(context) {
      stopAllMedia();
      recordedChunks = [];
  
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
          mediaStream = stream;
          const video = document.getElementById(`videoPreview${capitalize(context)}`);
          video.srcObject = stream;
          video.muted = true;
          video.play();
          video.style.display = 'block';
  
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
          mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const videoURL = URL.createObjectURL(blob);
            video.srcObject = null;
            video.src = videoURL;
            video.controls = true;
            video.muted = false;
            video.play();
          };
          mediaRecorder.start();
          document.getElementById(`stopBtn${capitalize(context)}`).style.display = 'inline-block';
        })
        .catch(err => {
          alert('Camera permission denied.');
          console.error(err);
        });
    }
  
    function stopRecording(context) {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
      const stopBtn = document.getElementById(`stopBtn${capitalize(context)}`);
      if (stopBtn) stopBtn.style.display = 'none';
    }
  
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    // ============ MEILISEARCH INTEGRATION ============
    // Search functionality disabled - search bar removed
    // =========== END MEILISEARCH ============
    
    // Close mobile nav when clicking a nav link
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.blaze-nav .blaze-nav-link').forEach(link => {
        link.addEventListener('click', () => {
          if (window.innerWidth <= 768) {
            if (window.toggleMobileNav) {
              window.toggleMobileNav();
            }
          }
        });
      });
    });

    document.addEventListener('DOMContentLoaded', function() {
  // Initialize modal elements
  const modal = document.getElementById('pdfModal');
  if (!modal) {
    console.error('Modal element not found');
    return;
  }

  const openBtn = document.getElementById('openModalBtn');
  const closeBtn = modal.querySelector('.close');

  // Only add event listeners if elements exist
  if (openBtn) {
    openBtn.addEventListener('click', openTrainingModal);
  } else {
    console.error('Open modal button not found');
  }

  if (closeBtn) {
    closeBtn.addEventListener('click', closeTrainingModal);
  } else {
    console.error('Close button not found in modal');
  }

  // Rest of your initialization code...
});

async function loadCompetitionName() {
   await populateCompetitionDropdown();
}

function addCameraModalCSS() {
    const styles = `
    <style>
        .camera-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow: hidden;
        }
        
        .camera-modal-overlay::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(251, 146, 60, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(234, 88, 12, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(250, 204, 21, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }
        
        .camera-modal-overlay.active {
            opacity: 1;
        }
        
        /* Animated stars background */
        .camera-modal-overlay::after {
            content: '';
            position: absolute;
            inset: 0;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, #fff, transparent),
                radial-gradient(2px 2px at 60% 70%, #fff, transparent),
                radial-gradient(1px 1px at 50% 50%, #fff, transparent),
                radial-gradient(1px 1px at 80% 10%, #fff, transparent),
                radial-gradient(2px 2px at 90% 40%, #fff, transparent),
                radial-gradient(1px 1px at 33% 60%, #fff, transparent),
                radial-gradient(2px 2px at 10% 80%, #fff, transparent),
                radial-gradient(1px 1px at 70% 20%, #fff, transparent);
            background-size: 200% 200%;
            background-position: 0% 0%;
            animation: starfield 20s linear infinite;
            opacity: 0.6;
            pointer-events: none;
        }
        
        @keyframes starfield {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }
        
        .camera-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }
        
        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(251, 146, 60, 0.3);
        }
        
        .camera-title {
            color: #f1f5f9;
            font-size: 1.5rem;
            font-weight: 900;
            margin: 0;
            background: linear-gradient(to right, #fb923c, #fbbf24);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .camera-close {
            background: rgba(30, 41, 59, 0.5);
            border: 2px solid rgba(71, 85, 105, 0.5);
            border-radius: 0.5rem;
            color: #fb923c;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .camera-close:hover {
            background: rgba(251, 146, 60, 0.2);
            border-color: rgba(251, 146, 60, 0.5);
            color: #ea580c;
        }
        
        .assignment-questions {
            padding: 20px 30px;
            background: rgba(15, 23, 42, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            gap: 20px;
            border-bottom: 1px solid rgba(251, 146, 60, 0.2);
        }
        
        .question-card {
            flex: 1;
            background: linear-gradient(to bottom right, rgba(30, 41, 59, 0.6), rgba(15, 23, 42, 0.6));
            border: 1px solid rgba(251, 146, 60, 0.3);
            border-radius: 12px;
            padding: 15px;
            color: #cbd5e1;
            backdrop-filter: blur(10px);
        }
        
        .question-card strong {
            color: #fb923c;
            display: block;
            margin-bottom: 8px;
            font-weight: 700;
        }
        
        .question-card p {
            color: #e2e8f0;
            margin: 0;
        }
        
        .camera-main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            background: rgba(15, 23, 42, 0.2);
        }
        
        .video-preview {
            width: 80%;
            max-width: 800px;
            height: 40vh;
            background: #000;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(251, 146, 60, 0.2), 0 0 60px rgba(251, 146, 60, 0.1);
            position: relative;
            border: 2px solid rgba(251, 146, 60, 0.3);
        }
        
        .video-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .spark-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        .recording-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(to right, #dc2626, #f97316);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 700;
            display: none;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
        }
        
        .recording-indicator.active {
            display: block;
        }
        
        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                box-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
            }
            50% { 
                opacity: 0.8;
                box-shadow: 0 0 30px rgba(220, 38, 38, 0.8);
            }
        }
        
        .recording-timer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid rgba(251, 146, 60, 0.5);
            color: #fbbf24;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 1rem;
            font-family: monospace;
            font-weight: 700;
            display: none;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
        }
        
        .recording-timer.active {
            display: block;
        }
        
        .camera-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 30px;
            background: rgba(15, 23, 42, 0.4);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(251, 146, 60, 0.2);
        }
        
        .camera-toggle {
            background: rgba(30, 41, 59, 0.6);
            border: 2px solid rgba(251, 146, 60, 0.4);
            color: #fb923c;
            padding: 12px 16px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .camera-toggle:hover {
            background: rgba(251, 146, 60, 0.2);
            border-color: rgba(251, 146, 60, 0.6);
            color: #fbbf24;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 146, 60, 0.3);
        }
        
        .camera-toggle.camera-off {
            background: rgba(220, 38, 38, 0.2);
            border-color: #dc2626;
            color: #f87171;
        }
        
        .record-btn {
            background: linear-gradient(135deg, #dc2626, #f97316, #fbbf24);
            border: 3px solid rgba(251, 146, 60, 0.5);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.4), 0 0 40px rgba(251, 146, 60, 0.3);
            color: white;
        }
        
        .record-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 35px rgba(220, 38, 38, 0.5), 0 0 60px rgba(251, 146, 60, 0.4);
        }
        
        .record-btn.recording {
            background: linear-gradient(135deg, #dc2626, #f97316, #fbbf24);
            animation: recordingPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(220, 38, 38, 0.8), 0 0 80px rgba(251, 146, 60, 0.5);
        }
        
        @keyframes recordingPulse {
            0%, 100% { 
                box-shadow: 0 0 40px rgba(220, 38, 38, 0.8), 0 0 80px rgba(251, 146, 60, 0.5);
            }
            50% { 
                box-shadow: 0 0 60px rgba(220, 38, 38, 1), 0 0 120px rgba(251, 146, 60, 0.7);
            }
        }
        
        .camera-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px 30px;
            background: rgba(15, 23, 42, 0.4);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(251, 146, 60, 0.2);
        }
        
        .action-btn {
            background: linear-gradient(to right, #dc2626, #f97316, #fbbf24);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        
        .action-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(220, 38, 38, 0.4);
            background: linear-gradient(to right, #ea580c, #fb923c, #fde047);
        }
        
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            background: rgba(71, 85, 105, 0.5);
        }
        
        .no-camera {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #cbd5e1;
            font-size: 1.1rem;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.8));
            border: 2px solid rgba(251, 146, 60, 0.3);
        }
        
        .no-camera-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        
        .audio-wave {
            display: flex;
            gap: 4px;
            margin: 20px 0;
        }
        
        .wave-bar {
            width: 4px;
            height: 20px;
            background: linear-gradient(to top, #fb923c, #fbbf24);
            border-radius: 2px;
            animation: wave 1s infinite ease-in-out;
            box-shadow: 0 0 8px rgba(251, 146, 60, 0.5);
        }
        
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes wave {
            0%, 40%, 100% { transform: scaleY(0.4); }
            20% { transform: scaleY(1); }
        }
    </style>`;
    
    document.head.insertAdjacentHTML('beforeend', styles);
}



// Spark Animation for Video Preview - Declare variables before use (use window to ensure global scope)
window.sparkAnimationId = null;
window.sparks = [];

function openCameraModal(questions = null) {
    // Add modal HTML if it doesn't exist
    if (!document.getElementById('cameraModal')) {
        addCameraModalHTML();
        addCameraModalCSS();
        addImprovedCameraCSS();
    }
    
    // Initialize spark animation (with error handling to not block modal opening)
    try {
        initializeSparkAnimation();
    } catch (error) {
        console.error('Error initializing spark animation:', error);
        // Continue anyway - modal should still open
    }
    
    // Use the generated questions if available, otherwise use currentGeneratedQuestions
    const questionsToUse = questions || currentGeneratedQuestions;
    
    if (questionsToUse && questionsToUse.length > 0) {
        window.currentAssignmentQuestions = {
            title: "Speaking Assessment",
            q1: questionsToUse[0] || "What is your strategy for this scenario?",
            q2: questionsToUse[1] || "How would you handle unexpected challenges?"
        };
    }
    
    // Set assignment questions
    if (window.currentAssignmentQuestions) {
        document.getElementById('cameraModalTitle').textContent = window.currentAssignmentQuestions.title;
        document.getElementById('cameraQ1').textContent = window.currentAssignmentQuestions.q1;
        document.getElementById('cameraQ2').textContent = window.currentAssignmentQuestions.q2;
    }
    
    // Reset recording state
    isRecording = false;
    window.recordedBlob = null;
    resetRecordingUI();
    
    // Show modal with animation
    const modal = document.getElementById('cameraModal');
    if (!modal) {
        console.error('Camera modal not found!');
        return;
    }
    modal.style.display = 'flex';
    setTimeout(() => {
        if (modal) {
            modal.classList.add('active');
        }
    }, 10);
    
    // Initialize camera
    try {
    initializeCamera();
    } catch (error) {
        console.error('Error initializing camera:', error);
        // Continue anyway - modal is already open
    }
}

function closeCameraModal() {
    const modal = document.getElementById('cameraModal');
    modal.classList.remove('active');
    stopSparkAnimation();
    setTimeout(() => {
        modal.style.display = 'none';
        stopAllMedia();
    }, 300);
    
    // Clear assignment data
    window.latestAssignmentId = null;
    window.currentAssignment = null;
      closeModal('speakingModal'); // This will close the speaking modal too
}

async function initializeCamera() {
    try {
        const constraints = {
            video: cameraEnabled,
            audio: micEnabled
        };
        
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        updateVideoDisplay();
        
        // Set initial button states
        const cameraToggle = document.getElementById('cameraToggle');
        const micToggle = document.getElementById('micToggle');
        
        if (!cameraEnabled) {
            cameraToggle.classList.add('camera-off');
            cameraToggle.title = 'Turn Camera On';
        } else {
            cameraToggle.classList.remove('camera-off');
            cameraToggle.title = 'Turn Camera Off';
        }
        
        if (!micEnabled) {
            micToggle.classList.add('camera-off');
            micToggle.title = 'Turn Microphone On';
        } else {
            micToggle.classList.remove('camera-off');
            micToggle.title = 'Turn Microphone Off';
        }
        
    } catch (error) {
        console.error('Error accessing camera:', error);
        alert('Could not access camera/microphone. Please ensure permissions are granted.');
    }
}

function toggleCamera() {
    cameraEnabled = !cameraEnabled;
    const toggleBtn = document.getElementById('cameraToggle');
    
    // Update button appearance
    if (cameraEnabled) {
        toggleBtn.classList.remove('camera-off');
        toggleBtn.title = 'Turn Camera Off';
    } else {
        toggleBtn.classList.add('camera-off');
        toggleBtn.title = 'Turn Camera On';
    }
    
    // Restart stream with new constraints
    restartCameraStream();
}

function toggleMic() {
    micEnabled = !micEnabled;
    const toggleBtn = document.getElementById('micToggle');
    
    // Update button appearance
    if (micEnabled) {
        toggleBtn.classList.remove('camera-off');
        toggleBtn.title = 'Turn Microphone Off';
    } else {
        toggleBtn.classList.add('camera-off');
        toggleBtn.title = 'Turn Microphone On';
    }
    
    // Restart stream with new constraints
    restartCameraStream();
}

async function restartCameraStream() {
    // Stop current stream
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
    }
    
    // Get new stream with updated constraints
    try {
        const constraints = {
            video: cameraEnabled,
            audio: micEnabled
        };
        
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        updateVideoDisplay();
        
    } catch (error) {
        console.error('Error restarting camera stream:', error);
        // Fallback to audio-only if camera fails
        if (cameraEnabled) {
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ audio: micEnabled });
                cameraEnabled = false;
                document.getElementById('cameraToggle').classList.add('camera-off');
                updateVideoDisplay();
            } catch (audioError) {
                console.error('Error accessing audio:', audioError);
                alert('Could not access camera or microphone');
            }
        }
    }
}

function updateVideoDisplay() {
    const videoElement = document.getElementById('cameraPreview');
    const noCameraView = document.getElementById('noCameraView');
    
    if (cameraEnabled && cameraStream) {
        videoElement.srcObject = cameraStream;
        videoElement.style.display = 'block';
        noCameraView.style.display = 'none';
    } else {
        videoElement.style.display = 'none';
        videoElement.srcObject = null;
        noCameraView.style.display = 'flex';
    }
}


function toggleRecording() {
    if (isRecording) {
        stopCameraRecording(); // Use camera-specific function
    } else {
        startCameraRecording();
    }
}

function startCameraRecording() {
    if (!cameraStream) {
        alert('Camera not initialized');
        return;
    }
    
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(cameraStream);
    
    mediaRecorder.ondataavailable = function(event) {
        console.log('Data available, blob size:', event.data.size);
        if (event.data.size > 0) {
            recordedChunks.push(event.data);
        }
    };
    
    mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' }); // or 'audio/webm'
        console.log('Recording finished, blob size:', blob.size);
        window.recordedBlob = blob; // Store globally
        
        // Auto-download after a short delay
        setTimeout(() => {
            downloadCameraRecording();
        }, 500);
        
        document.getElementById('submitRecording').disabled = false;
    };
    
    mediaRecorder.start();
    isRecording = true;
    
    // Update UI
    document.getElementById('recordButton').textContent = 'â¹';
    document.getElementById('recordButton').classList.add('recording');
    document.getElementById('recordingIndicator').classList.add('active');
    document.getElementById('recordingTimer').classList.add('active');
    
    // Start timer
    startRecordingTimer();
}

function stopCameraRecording() {
    console.log('Stopping camera recording...');
    
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        isRecording = false;
        
        // Update UI
        document.getElementById('recordButton').textContent = 'â—';
        document.getElementById('recordButton').classList.remove('recording');
        document.getElementById('recordingIndicator').classList.remove('active');
        document.getElementById('recordingTimer').classList.remove('active');
        
        stopRecordingTimer();
        
    } else {
        console.log('No active recording to stop');
    }
}


function startRecording() {
    if (!cameraStream) {
        alert('Camera not initialized');
        return;
    }
    
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(cameraStream);
    
    mediaRecorder.ondataavailable = function(event) {
        console.log('Data available, blob size:', event.data.size);
        if (event.data.size > 0) {
            recordedChunks.push(event.data);
        }
    };
    
    mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        console.log('Recording finished, blob size:', blob.size);
        window.recordingBlob = blob; // Fixed: use recordingBlob
        document.getElementById('submitRecording').disabled = false;
    };
    
    mediaRecorder.start();
    isRecording = true;
    
    // Update UI
    document.getElementById('recordButton').textContent = 'â¹';
    document.getElementById('recordButton').classList.add('recording');
    document.getElementById('recordingIndicator').classList.add('active');
    document.getElementById('recordingTimer').classList.add('active');
    
    // Start timer
    recordingSeconds = 0;
    recordingTimer = setInterval(() => {
        recordingSeconds++;
        const minutes = Math.floor(recordingSeconds / 60);
        const seconds = recordingSeconds % 60;
        document.getElementById('recordingTimer').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
}


function stopRecording(type) {
    console.log(`Stopping ${type} recording...`);
    
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        isRecording = false;
        
        // Update UI immediately
        document.getElementById('recordButton').textContent = 'â—';
        document.getElementById('recordButton').classList.remove('recording');
        document.getElementById('recordingIndicator').classList.remove('active');
        document.getElementById('recordingTimer').classList.remove('active');
        
        // Stop timer
        if (recordingTimer) {
            clearInterval(recordingTimer);
            recordingTimer = null;
        }
        
        // Show download modal after brief delay
        setTimeout(() => {
            showDownloadModal();
        }, 500);
        
    } else {
        console.log('No active recording to stop');
    }
    
    // Hide stop button if it exists
    const stopBtn = document.getElementById(`stopBtn${type.charAt(0).toUpperCase() + type.slice(1)}`);
    if (stopBtn) {
        stopBtn.style.display = 'none';
    }
}

function showUploadPromptModal() {
    // Add modal HTML if it doesn't exist
    if (!document.getElementById('uploadPromptModal')) {
        document.body.insertAdjacentHTML('beforeend', uploadPromptModalHTML);
    }
    
    // Show modal
    const modal = document.getElementById('uploadPromptModal');
    if (modal) {
        modal.style.display = 'flex';
        setTimeout(() => modal.classList.add('active'), 10);
    }
}

function closeUploadPromptModal() {
    const modal = document.getElementById('uploadPromptModal');
    if (modal) {
        modal.classList.remove('active');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }
}

function goToJudgingPage() {
    closeUploadPromptModal();
    
    // Customize this to your judging page location
    const judgingSection = document.getElementById('judging-section');
    if (judgingSection) {
        judgingSection.scrollIntoView({ behavior: 'smooth' });
    }
    
    setTimeout(() => {
        closeRecordingSetup();
    }, 500);
}

function closeRecordingSetup() {
    // Close all modals
    closeDownloadModal();
    closeUploadPromptModal();
    
    // Hide recording interface
    const recordingContainer = document.getElementById('recordingContainer');
    if (recordingContainer) {
        recordingContainer.style.display = 'none';
    }
    
    // Stop streams and reset state
    if (window.currentStream) {
        window.currentStream.getTracks().forEach(track => track.stop());
    }
    
    // Reset variables
    isRecording = false;
    recordedChunks = [];
    mediaRecorder = null;
    
    // Clear timers and URLs
    if (window.recordingTimer) {
        clearInterval(window.recordingTimer);
    }
    if (window.recordingURL) {
        URL.revokeObjectURL(window.recordingURL);
    }
}

const uploadPromptModalHTML = `
<div id="uploadPromptModal" class="upload-prompt-modal">
    <div class="upload-prompt-modal-content">
        <div class="upload-prompt-header">
            <h3>ðŸŽ‰ Great Job!</h3>
        </div>
        <div class="upload-prompt-body">
            <div class="upload-message">
                <p>Your recording has been downloaded successfully!</p>
                <p><strong>Now upload it to the judging page for feedback!</strong></p>
                <div class="upload-icon">ðŸ“¤</div>
            </div>
            <div class="upload-prompt-actions">
                <button class="go-to-upload-btn" onclick="goToJudgingPage()">
                    ðŸš€ Go to Judging Page
                </button>
                <button class="close-recording-btn" onclick="closeRecordingSetup()">
                    âœ… Close Recording Setup
                </button>
            </div>
        </div>
    </div>
</div>`;


function downloadCameraRecording() {
    console.log('Downloading camera recording...');
    
    if (!window.recordedBlob) {
        alert('No recording found. Please record first.');
        return;
    }
    
    // Create download link
    const url = URL.createObjectURL(window.recordedBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `camera_recording_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.webm`;
    
    // Trigger download
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    // Clean up
    URL.revokeObjectURL(url);
    
    console.log('Download triggered successfully');
}

const downloadModalHTML = `
<div id="downloadModal" class="download-modal">
    <div class="download-modal-content">
        <div class="download-modal-header">
            <h3>Recording Complete!</h3>
            <button class="close-btn" onclick="closeDownloadModal()">&times;</button>
        </div>
        <div class="download-modal-body">
            <div id="recordingPreview" class="recording-preview">
                <!-- Preview will be inserted here -->
            </div>
            <div class="download-actions">
                <button id="downloadBtn" class="download-btn" onclick="downloadRecording()">
                    ðŸ“¥ Download Recording
                </button>
                <button class="upload-btn" onclick="showUploadPromptModal()">
                    ðŸ“¤ Upload & Continue
                </button>
                <div class="file-info">
                    <small>ðŸ’¡ Tip: Open the downloaded .webm file in your browser for best playback</small>
                </div>
            </div>
        </div>
    </div>
</div>`;


function addDownloadModalCSS() {
    if (document.getElementById('downloadModalStyles')) return;
    
    const style = document.createElement('style');
    style.id = 'downloadModalStyles';
    style.textContent = `
        .download-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .download-modal.active {
            opacity: 1;
        }
        
        .download-modal-content {
            background: white;
            border-radius: 15px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .download-modal.active .download-modal-content {
            transform: scale(1);
        }
        
        .download-modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .download-modal-header h3 {
            margin: 0;
            font-size: 1.3em;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .download-modal-body {
            padding: 20px;
        }
        
        .recording-preview {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .download-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
        }
        
        .download-btn, .upload-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .download-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }
        
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }
        
        .file-info {
            margin-top: 15px;
            text-align: center;
        }
        
        .file-info small {
            color: #666;
            font-style: italic;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 15px;
            display: inline-block;
        }
        
        /* Upload Prompt Modal Styles */
        .upload-prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .upload-prompt-modal.active {
            opacity: 1;
        }
        
        .upload-prompt-modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            padding: 0;
            max-width: 450px;
            width: 90%;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s ease;
            color: white;
            text-align: center;
        }
        
        .upload-prompt-modal.active .upload-prompt-modal-content {
            transform: scale(1);
        }
        
        .upload-prompt-header {
            padding: 30px 20px 10px 20px;
        }
        
        .upload-prompt-header h3 {
            margin: 0;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .upload-prompt-body {
            padding: 20px 30px 40px 30px;
        }
        
        .upload-message {
            margin-bottom: 30px;
        }
        
        .upload-message p {
            margin: 10px 0;
            font-size: 1.1em;
            line-height: 1.4;
        }
        
        .upload-icon {
            font-size: 3em;
            margin: 20px 0;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .upload-prompt-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .go-to-upload-btn, .close-recording-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .go-to-upload-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }
        
        .go-to-upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .close-recording-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .close-recording-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
    `;
    document.head.appendChild(style);
}

function showDownloadModal() {
    // Add CSS first
    addDownloadModalCSS();
    
    // Add modal HTML if it doesn't exist
    if (!document.getElementById('downloadModal')) {
        document.body.insertAdjacentHTML('beforeend', downloadModalHTML);
    }
    
    // Use the stored blob from recording
    if (window.recordingBlob) {
        const url = URL.createObjectURL(window.recordingBlob);
        
        // Store for download
        window.recordingURL = url;
        
        // Show preview
        const preview = document.getElementById('recordingPreview');
        if (preview) {
            if (cameraEnabled) {
                preview.innerHTML = `<video src="${url}" controls style="width:100%; max-height:200px; border-radius:10px;"></video>`;
            } else {
                preview.innerHTML = `<audio src="${url}" controls style="width:100%;"></audio>`;
            }
        }
    }
    
    // Show modal
    const modal = document.getElementById('downloadModal');
    if (modal) {
        modal.style.display = 'flex';
        setTimeout(() => modal.classList.add('active'), 10);
    }
}


function downloadRecording(type) {
    console.log(`Downloading ${type} recording...`);
    
    if (!recordedBlob) {
        alert('No recording found. Please record first.');
        return;
    }
    
    // Create download link
    const url = URL.createObjectURL(recordedBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${type}_recording_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.webm`;
    
    // Trigger download
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    // Clean up
    URL.revokeObjectURL(url);
    
    console.log('Download triggered successfully');
}

function downloadRecording() {
    if (!window.recordingBlob) {
        alert('No recording available');
        return;
    }
    
    try {
        // Create download link
        const url = URL.createObjectURL(window.recordingBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `CertQuest_Recording_${Date.now()}.webm`;
        a.style.display = 'none';
        
        // Add to DOM, click, and remove
        document.body.appendChild(a);
        a.click();
        
        // Cleanup
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        // Show success feedback
        const downloadBtn = document.getElementById('downloadBtn');
        if (downloadBtn) {
            const originalText = downloadBtn.innerHTML;
            downloadBtn.innerHTML = 'âœ… Downloaded!';
            downloadBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
            
            setTimeout(() => {
                downloadBtn.innerHTML = originalText;
            }, 2000);
        }
        
        // Close download modal and show upload prompt modal
        setTimeout(() => {
            closeDownloadModal();
            showUploadPromptModal(); // Fixed: correct function name
        }, 1000);
        
    } catch (error) {
        console.error('Download failed:', error);
        alert('Download failed. Please try again.');
    }
}


function closeDownloadModal() {
    const modal = document.getElementById('downloadModal');
    if (modal) {
        modal.classList.remove('active');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }
    
    // Clean up blob URLs
    if (window.recordingURL) {
        URL.revokeObjectURL(window.recordingURL);
        window.recordingURL = null;
    }
}
document.addEventListener('click', function(event) {
    const modal = document.getElementById('downloadModal');
    if (modal && event.target === modal) {
        closeDownloadModal();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        closeDownloadModal();
    }
});
// 5. ADD THESE NEW FUNCTIONS
function showUploadModal() {
    // Add modal HTML if it doesn't exist
    if (!document.getElementById('uploadModal')) {
        document.body.insertAdjacentHTML('beforeend', uploadModalHTML);
        setupUploadModal(); // Make sure this is called
    }
    
    // Show modal with animation
    const modal = document.getElementById('uploadModal');
    modal.style.display = 'flex';
    setTimeout(() => modal.classList.add('active'), 10);
}


function closeUploadModal() {
    const modal = document.getElementById('uploadModal');
    modal.classList.remove('active');
    setTimeout(() => {
        modal.style.display = 'none';
        resetUploadModal();
    }, 300);
}


function updateRecordingUI(recording) {
    const recordButton = document.getElementById('recordButton');
    const recordingIndicator = document.getElementById('recordingIndicator');
    const recordingTimer = document.getElementById('recordingTimer');
    
    if (recording) {
        recordButton.textContent = 'â¹';
        recordButton.classList.add('recording');
        recordingIndicator.classList.add('active');
        recordingTimer.classList.add('active');
    } else {
        recordButton.textContent = 'â—';
        recordButton.classList.remove('recording');
        recordingIndicator.classList.remove('active');
        recordingTimer.classList.remove('active');
    }
}

function startRecordingTimer() {
    recordingSeconds = 0;
    recordingTimer = setInterval(() => {
        recordingSeconds++;
        const minutes = Math.floor(recordingSeconds / 60);
        const seconds = recordingSeconds % 60;
        const timerElement = document.getElementById('recordingTimer');
        if (timerElement) {
            timerElement.textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
    }, 1000);
}

function stopRecordingTimer() {
    if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
    }
}

function resetRecordingUI() {
    isRecording = false;
    updateRecordingUI(false);
    stopRecordingTimer();
    document.getElementById('submitRecording').disabled = true;
}

function showRecordingComplete() {
    // Show a brief success message
    const recordButton = document.getElementById('recordButton');
    const originalText = recordButton.textContent;
    recordButton.textContent = 'âœ“';
    recordButton.style.background = '#2ecc71';
    
    setTimeout(() => {
        recordButton.textContent = originalText;
        recordButton.style.background = '';
    }, 2000);
}

function addCameraModalHTML() {
    const cameraModalHTML = `
    <!-- Camera Recording Modal -->
    <div id="cameraModal" class="camera-modal-overlay">
        <div class="camera-container">
            <!-- Header -->
            <div class="camera-header">
                <h2 class="camera-title" id="cameraModalTitle">Record Your Response</h2>
                <button class="camera-close" onclick="closeCameraModal()">&times;</button>
            </div>
            
            <!-- Assignment Questions Display -->
            <div class="assignment-questions">
                <div class="question-card">
                    <strong>Question 1:</strong>
                    <p id="cameraQ1">What is your strategy for this scenario?</p>
                </div>
                <div class="question-card">
                    <strong>Question 2:</strong>
                    <p id="cameraQ2">How would you handle unexpected challenges?</p>
                </div>
            </div>
            
            <!-- Main Video Area -->
            <div class="camera-main">
                <div class="video-preview">
                    <video id="cameraPreview" autoplay muted playsinline></video>
                    <canvas id="sparkCanvas" class="spark-canvas"></canvas>
                    <div id="recordingIndicator" class="recording-indicator">â— RECORDING</div>
                    <div id="recordingTimer" class="recording-timer">00:00</div>
                    <div id="noCameraView" class="no-camera" style="display: none;">
                        <div class="no-camera-icon">ðŸŽ¤</div>
                        <div>Audio Only Mode</div>
                        <div class="audio-wave">
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="camera-controls">
                <button id="cameraToggle" class="camera-toggle" onclick="toggleCamera()" title="Toggle Camera">ðŸ“¹</button>
                <button id="recordButton" class="record-btn" onclick="toggleRecording()">â—</button>
                <button id="micToggle" class="camera-toggle" onclick="toggleMic()" title="Toggle Microphone">ðŸŽ¤</button>
            </div>
            
            <!-- Actions -->
            <div class="camera-actions">
                <button id="submitRecording" class="action-btn" onclick="submitCameraRecording()" disabled>Submit Response</button>
            </div>
        </div>
    </div>`;
    
    document.body.insertAdjacentHTML('beforeend', cameraModalHTML);
}

function addImprovedCameraCSS() {
    const additionalStyles = `
    <style>
        .camera-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 16px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .camera-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .camera-toggle.camera-off {
            background: rgba(220, 38, 38, 0.3) !important;
            border-color: #dc2626 !important;
            color: #f87171 !important;
        }
        
        .camera-toggle.camera-off::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 30px;
            background: #dc2626;
            transform: translate(-50%, -50%) rotate(45deg);
            border-radius: 1px;
        }
        
        .no-camera {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #cbd5e1;
            font-size: 1.1rem;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.8));
            border: 2px solid rgba(251, 146, 60, 0.3);
        }
        
        .no-camera-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.8;
        }
        
        .audio-wave {
            display: flex;
            gap: 4px;
            margin: 20px 0;
        }
        
        .wave-bar {
            width: 4px;
            height: 20px;
            background: linear-gradient(to top, #fb923c, #fbbf24);
            border-radius: 2px;
            animation: wave 1s infinite ease-in-out;
            box-shadow: 0 0 8px rgba(251, 146, 60, 0.5);
        }
        
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes wave {
            0%, 40%, 100% { transform: scaleY(0.4); }
            20% { transform: scaleY(1); }
        }
    </style>`;
    
    document.head.insertAdjacentHTML('beforeend', additionalStyles);
}

function initializeSparkAnimation() {
    const canvas = document.getElementById('sparkCanvas');
    if (!canvas) return;
    
    const videoPreview = document.querySelector('.video-preview');
    if (!videoPreview) return;
    
    // Set canvas size to match video preview
    const updateCanvasSize = () => {
        const rect = videoPreview.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
    };
    
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);
    
    const ctx = canvas.getContext('2d');
    
    // Create spark class
    class Spark {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8 - 2;
            this.life = 1;
            this.decay = Math.random() * 0.02 + 0.015;
            this.size = Math.random() * 3 + 1;
            this.color = Math.random() > 0.5 ? '#fb923c' : '#fbbf24';
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.15; // gravity
            this.vx *= 0.98; // friction
            this.life -= this.decay;
            this.size *= 0.99;
        }
        
        draw(ctx) {
            if (this.life <= 0) return;
            
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Add trail
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size * 0.5;
            ctx.stroke();
            
            ctx.restore();
        }
    }
    
    // Generate sparks from edges of video preview
    function generateSparks() {
        const rect = videoPreview.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        // Generate more sparks (increased from default)
        const sparkCount = 15; // More sparks
        
        for (let i = 0; i < sparkCount; i++) {
            // Generate sparks from random points around the edges
            let x, y;
            const side = Math.floor(Math.random() * 4);
            
            switch(side) {
                case 0: // top
                    x = Math.random() * rect.width;
                    y = 0;
                    break;
                case 1: // right
                    x = rect.width;
                    y = Math.random() * rect.height;
                    break;
                case 2: // bottom
                    x = Math.random() * rect.width;
                    y = rect.height;
                    break;
                case 3: // left
                    x = 0;
                    y = Math.random() * rect.height;
                    break;
            }
            
            // Also generate some from center occasionally
            if (Math.random() > 0.7) {
                x = centerX + (Math.random() - 0.5) * rect.width * 0.3;
                y = centerY + (Math.random() - 0.5) * rect.height * 0.3;
            }
            
            window.sparks.push(new Spark(x, y));
        }
    }
    
    function animateSparks() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Generate new sparks continuously
        if (Math.random() > 0.7) {
            generateSparks();
        }
        
        // Update and draw sparks
        for (let i = window.sparks.length - 1; i >= 0; i--) {
            window.sparks[i].update();
            window.sparks[i].draw(ctx);
            
            // Remove dead sparks
            if (window.sparks[i].life <= 0 || 
                window.sparks[i].x < -50 || window.sparks[i].x > canvas.width + 50 ||
                window.sparks[i].y < -50 || window.sparks[i].y > canvas.height + 50) {
                window.sparks.splice(i, 1);
            }
        }
        
        // Limit spark count
        if (window.sparks.length > 100) {
            window.sparks = window.sparks.slice(-80);
        }
        
        window.sparkAnimationId = requestAnimationFrame(animateSparks);
    }
    
    // Start animation
    if (window.sparkAnimationId) {
        cancelAnimationFrame(window.sparkAnimationId);
    }
    window.sparks = [];
    animateSparks();
}

function stopSparkAnimation() {
    if (window.sparkAnimationId) {
        cancelAnimationFrame(window.sparkAnimationId);
        window.sparkAnimationId = null;
    }
    window.sparks = [];
}

async function submitCameraRecording() {
    if (!window.recordedBlob) {
        alert('No recording found. Please record first.');
        return;
    }
    
    const submitBtn = document.getElementById('submitRecording');
    const originalText = submitBtn.textContent;
    
    try {
        submitBtn.textContent = 'Uploading...';
        submitBtn.disabled = true;
        
        // Here you would upload to Firebase Storage
        // For now, just simulate success
        console.log('Submitting recording, size:', window.recordedBlob.size);
        
        // Simulate upload delay
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        submitBtn.textContent = 'Submitted âœ“';
        
        // Close modal after success
        setTimeout(() => {
            closeCameraModal();
        }, 1500);
        
    } catch (error) {
        console.error('Submit error:', error);
        alert('Failed to submit recording');
        submitBtn.textContent = originalText;
        submitBtn.disabled = false;
    }
}



// Update the click outside listener to handle both modals:
document.addEventListener('click', function(event) {
    const downloadModal = document.getElementById('downloadModal');
    const uploadModal = document.getElementById('uploadPromptModal');
    
    if (downloadModal && event.target === downloadModal) {
        closeDownloadModal();
    }
    if (uploadModal && event.target === uploadModal) {
        closeUploadPromptModal();
    }
});

// Close modals with Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        closeDownloadModal();
        closeUploadPromptModal();
    }

  
});

firebase.auth().onAuthStateChanged((user) => {
    if (user) {
         populateCompetitionDropdown();
    }
});

// ======== SIMPLER MODAL RESET SOLUTION ========
function setupModalReset() {
    console.log('ðŸ”„ Setting up modal reset...');
    
    const modal = document.getElementById('caseModal');
    if (!modal) {
        setTimeout(setupModalReset, 500);
        return;
    }

    const closeBtn = modal.querySelector('.close');
    
    // Simple approach: just reset and close when confirmed
    closeBtn.onclick = function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const resultSection = document.getElementById('caseResultSection');
        if (resultSection && resultSection.style.display !== 'none') {
            if (confirm('Are you sure you want to close? Once closed, you cannot go back to this case study.')) {
                // Reset the modal
                resultSection.style.display = 'none';
                document.getElementById('casePromptSection').style.display = 'block';
                
                const caseContent = document.getElementById('caseContent');
                if (caseContent) caseContent.remove();
                
                const generateBtn = document.querySelector('#caseModal .generate-btn');
                if (generateBtn) generateBtn.textContent = 'Generate Case';
                
                // Close the modal
                modal.style.display = 'none';
            }
        } else {
            // No content to reset, just close
            modal.style.display = 'none';
        }
    };

    // Handle outside clicks
    window.addEventListener('click', function(event) {
        if (event.target === modal) {
            const resultSection = document.getElementById('caseResultSection');
            if (resultSection && resultSection.style.display !== 'none') {
                if (confirm('Are you sure you want to close? Once closed, you cannot go back to this case study.')) {
                    // Reset the modal
                    resultSection.style.display = 'none';
                    document.getElementById('casePromptSection').style.display = 'block';
                    
                    const caseContent = document.getElementById('caseContent');
                    if (caseContent) caseContent.remove();
                    
                    const generateBtn = document.querySelector('#caseModal .generate-btn');
                    if (generateBtn) generateBtn.textContent = 'Generate Case';
                    
                    // Close the modal
                    modal.style.display = 'none';
                }
            } else {
                modal.style.display = 'none';
            }
        }
    });

    console.log('âœ… Modal reset setup complete!');
}

// Initialize
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => setTimeout(setupModalReset, 1000));
} else {
    setTimeout(setupModalReset, 1000);
}

// Re-setup when modal opens
const originalOpen = window.openCaseModal;
window.openCaseModal = function() {
    if (originalOpen) originalOpen();
    setTimeout(setupModalReset, 100);
};

// ======== DEBUG MODAL RESET ========
console.log('ðŸ” Testing modal reset setup...');

// Test if elements exist
 modal = document.getElementById('caseModal');
const resultSection = document.getElementById('caseResultSection');
const promptSection = document.getElementById('casePromptSection');
 closeBtn = modal ? modal.querySelector('.close') : null;

console.log('Modal elements found:');
console.log('- caseModal:', modal);
console.log('- caseResultSection:', resultSection);
console.log('- casePromptSection:', promptSection);
console.log('- close button:', closeBtn);

if (modal && closeBtn) {
    console.log('âœ… Setting up modal reset...');
    
    // Override close button
    closeBtn.onclick = function(e) {
        console.log('Close button clicked!');
        e.preventDefault();
        e.stopPropagation();
        
        if (confirm('Are you sure you want to close? Once closed, you cannot go back to this case study.')) {
            console.log('User confirmed close - resetting modal');
            resetModalState();
            modal.style.display = 'none';
        }
    };
    
    // Override outside click
    const originalOnclick = window.onclick;
    window.onclick = function(event) {
        // Call original handler if it exists
        if (originalOnclick) originalOnclick(event);
        
        if (event.target === modal) {
            console.log('Clicked outside modal!');
            if (confirm('Are you sure you want to close? Once closed, you cannot go back to this case study.')) {
                console.log('User confirmed close - resetting modal');
                resetModalState();
                modal.style.display = 'none';
            }
        }
    };
    
    console.log('âœ… Modal reset handlers installed');
} else {
    console.log('âŒ Modal elements not found - cannot setup reset');
}

function resetModalState() {
    console.log('ðŸ”„ Resetting modal state...');
    
    // Hide result section and show prompt section
    if (resultSection) {
        resultSection.style.display = 'none';
        console.log('âœ… Hidden result section');
    }
    if (promptSection) {
        promptSection.style.display = 'block';
        console.log('âœ… Showed prompt section');
    }
    
    // Clear any generated content
    const caseContent = document.getElementById('caseContent');
    if (caseContent) {
        caseContent.remove();
        console.log('âœ… Removed case content');
    }
    
    // Reset button text
    const generateBtn = document.querySelector('#caseModal .generate-btn');
    if (generateBtn) {
        generateBtn.textContent = 'Generate Case';
        console.log('âœ… Reset button text');
    }
    
    console.log('âœ… Modal reset complete');
}

console.log('ðŸŽ¯ Modal reset setup complete. Try closing the modal now!');



  </script>
  
  
  
  
  
<script>

window.currentQuestionIndex = 0;
    window.writtenQuestions = [];
    window.writtenAnswers = {};
    window.writtenTimeRemaining = 900;
    window.currentProgress = 0;
    window.progressInterval = null;

  
async function loadCertQuestContext(userId, competition) {
  const db = firebase.firestore();

  let baselineText = "";
  if (competition) {
    const compDoc = await db.collection("competitions").doc(competition).get();
    if (compDoc.exists && compDoc.data().baseline && compDoc.data().baseline.text) {
      baselineText = compDoc.data().baseline.text;
    }
  }

  let personalText = "";
  const entriesSnap = await db
    .collection("userTraining")
    .doc(userId)
    .collection("entries")
    .orderBy("timestamp", "desc")
    .limit(10)
    .get();

  entriesSnap.forEach(d => {
    if (d.data().content) personalText += d.data().content + "\n\n";
  });

  window.__CERTQUEST_CONTEXT__ =
    "=== OFFICIAL COMPETITION STUDY GUIDE ===\n" +
    baselineText +
    "\n\n=== STUDENT PERSONAL TRAINING DATA ===\n" +
    personalText;
}

  // Create stars for background
  function createStars() {
    const starsContainer = document.getElementById("starsContainer");
    if (!starsContainer) return;
    
    for (let i = 0; i < 200; i++) {
      const star = document.createElement("div");
      star.className = "star";
      const size = Math.random() * 3 + 0.5;
      const duration = Math.random() * 4 + 2;
      const delay = Math.random() * 2;
      const randomLeft = Math.random() * 100;
      const randomTop = Math.random() * 100;
      const randomOpacity = Math.random() * 0.9 + 0.3;
      
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = randomLeft + '%';
      star.style.top = randomTop + '%';
      star.style.opacity = randomOpacity;
      star.style.animation = `twinkle ${duration}s ease-in-out infinite`;
      star.style.animationDelay = delay + 's';
      star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
      
      starsContainer.appendChild(star);
    }
  }

  // Initialize stars on page load
  document.addEventListener('DOMContentLoaded', function() {
    createStars();
  });

  // Notification Panel Toggle
  // Notification Panel Toggle
  function toggleNotificationPanel() {
    const panel = document.getElementById("notificationPanel");
    if (!panel) return;
    
    if (panel.classList.contains("active")) {
      panel.classList.remove("active");
      setTimeout(() => panel.classList.add("hidden"), 300);
    } else {
      panel.classList.remove("hidden");
      setTimeout(() => panel.classList.add("active"), 10);
      loadNotifications();
    }
  }
  window.toggleNotificationPanel = toggleNotificationPanel;

  // Setup Notifications
  function setupNotifications() {
    const user = auth.currentUser;
    if (!user) return;
    
    const notificationList = document.getElementById("notificationList");
    if (!notificationList) return;
    
    db.collection("notifications")
      .where("menteeId", "==", user.uid)
      .orderBy("timestamp", "desc")
      .limit(50)
      .onSnapshot((snapshot) => {
        notificationList.innerHTML = '';
        
        if (snapshot.empty) {
          notificationList.innerHTML = '<div class="notification-empty">No notifications</div>';
          return;
        }
        
        snapshot.forEach((doc) => {
          const notif = doc.data();
          const item = document.createElement("div");
          item.className = `notification-item ${notif.read ? 'read' : ''}`;
          
          // Format timestamp
          let timeText = "Just now";
          if (notif.timestamp && notif.timestamp.toDate) {
            const date = notif.timestamp.toDate();
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) timeText = "Just now";
            else if (diffMins < 60) timeText = `${diffMins}m ago`;
            else if (diffHours < 24) timeText = `${diffHours}h ago`;
            else timeText = `${diffDays}d ago`;
          }
          
          // Different content based on notification type
          let bodyContent = '';
          if (notif.type === 'assignment') {
            bodyContent = `
              <div class="notification-body">
                Type: ${notif.assignmentType || 'Quiz'}<br>
                Competencies: ${notif.competencies ? notif.competencies.join(', ') : 'n/a'}<br>
                ${notif.time ? `Time: ${notif.time}<br>` : ''}
                ${notif.difficulty ? `Difficulty: ${notif.difficulty}` : ''}
              </div>
            `;
          } else {
            bodyContent = `
              <div class="notification-body">
                ${notif.message || notif.title || 'Notification'}
                ${notif.score !== undefined ? `<br>Score: ${notif.score}/${notif.totalQuestions || notif.maxScore || ''}` : ''}
              </div>
            `;
          }
          
          item.innerHTML = `
            <div class="notification-header">
              <strong>${notif.message || notif.title || 'Notification'}</strong>
              <span class="notification-time">${timeText}</span>
            </div>
            ${bodyContent}
          `;
          
          // Add click handler based on notification type
          if (notif.type === 'assignment' && notif.assignmentId) {
            item.addEventListener("click", () => {
              // Mark as read
              if (!notif.read) {
                doc.ref.update({ read: true });
              }
              item.classList.add("read");
              
              // Fetch and show assignment details
              db.collection('assignments').doc(notif.assignmentId).get()
                .then(assignmentDoc => {
                  if (assignmentDoc.exists) {
                    window.currentAssignment = assignmentDoc.data();
                    window.latestAssignmentId = notif.assignmentId;
                    openFullAssignmentModal(assignmentDoc.data());
                  }
                })
                .catch(error => {
                  console.error("Error fetching assignment:", error);
                  alert("Could not load assignment details");
                });
            });
          } else {
            item.addEventListener("click", () => {
              if (!notif.read) {
                doc.ref.update({ read: true });
              }
              item.classList.add("read");
            });
          }
          
          notificationList.appendChild(item);
        });
      }, (error) => {
        console.error("Error loading notifications:", error);
      });
  }

  // Update notification badge in nav
  function updateNotificationBadge(count) {
    const notificationLink = document.querySelector('a[onclick="toggleNotificationPanel()"]');
    if (notificationLink) {
      let notificationBadge = notificationLink.querySelector('.notification-badge');
      if (!notificationBadge && count > 0) {
        notificationBadge = document.createElement('span');
        notificationBadge.className = 'notification-badge';
        notificationBadge.textContent = count;
        notificationLink.style.position = 'relative';
        notificationLink.appendChild(notificationBadge);
      } else if (notificationBadge) {
        if (count > 0) {
          notificationBadge.style.display = 'inline-flex';
          notificationBadge.textContent = count;
        } else {
          notificationBadge.style.display = 'none';
        }
      }
    }
  }

  // Load Notifications (for initial load)
  function loadNotifications() {
    setupNotifications();
  }

  // Initialize notifications when user is authenticated
  firebase.auth().onAuthStateChanged((user) => {
    if (user) {
      setupNotifications();
    }
  });

  // Function to open full assignment modal (called when clicking assignment notifications)
  function openFullAssignmentModal(assignment) {
    // Set the modal title
    document.getElementById('cq-assignment-title').innerText = assignment.title || "New Assignment";
    
    // Show info section, hide quiz section
    document.getElementById('cq-assignment-info').style.display = 'block';
    document.getElementById('cq-assignment-quiz').style.display = 'none';
    
    // Fill in all assignment details
    const fieldsElement = document.getElementById('cq-assignment-fields');
    if (fieldsElement) {
        if (assignment.type === "speaking" || assignment.type === "case") {
            // Speaking/Case assignment format
            const q1 = assignment.questions && assignment.questions[0] ? assignment.questions[0] : "No question provided";
            const q2 = assignment.questions && assignment.questions[1] ? assignment.questions[1] : "No question provided";
            
            fieldsElement.innerHTML = `
                <div><b>Type:</b> ${assignment.type === "speaking" ? "Speaking" : "Case"} Assignment</div>
                <div><b>Competencies:</b> ${assignment.competencies ? assignment.competencies.join(', ') : 'n/a'}</div>
                <div><b>Description:</b> ${assignment.description || 'n/a'}</div>
                <div><b>Questions:</b></div>
                <ul>
                    <li>${q1}</li>
                    <li>${q2}</li>
                </ul>
            `;
        } else {
            // Regular assignment format
            fieldsElement.innerHTML = `
                <div><b>Time:</b> ${assignment.time || 'n/a'}</div>
                <div><b>Competencies:</b> ${assignment.competencies ? assignment.competencies.join(', ') : 'n/a'}</div>
                <div><b>Questions:</b><br> <span style="font-weight:400; color:#374151">${assignment.questions || 'n/a'}</span></div>
                <div><b>Difficulty:</b> ${assignment.difficulty || 'n/a'}</div>
                <div><b>Simulate:</b> ${assignment.simulate ? "Yes" : "No"}</div>
            `;
        }

        if (assignment.trainingPDFs && assignment.trainingPDFs.length > 0) {
            assignment.trainingPDFs.forEach(pdf => {
                const pdfBox = document.createElement('div');
                pdfBox.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; margin: 8px 0; border-radius: 8px; cursor: pointer; font-weight: 500;';
                pdfBox.textContent = pdf.name || 'Training Document';
                pdfBox.onclick = () => downloadPDF(pdf);
                fieldsElement.appendChild(pdfBox);
            });
        }
    }
    
    // Show the modal
    document.getElementById('cq-assignment-modal').style.display = 'block';
  }

  // Function to close assignment modal
  function closeAssignmentModal() {
    document.getElementById('cq-assignment-modal').style.display = 'none';
  }

  // ========== STATE ==========
  let writtenQuestions = [];
  let currentQuestionIndex = 0;
  let writtenAnswers = {};
  let writtenTimer = null;
  let writtenTimeRemaining = 0;

  async function acceptAssignmentNow() {
  console.log("\nðŸš€ ACCEPT ASSIGNMENT NOW\n");
  
  showLoader();

  const assignment = window.currentAssignment;
  
  if (!assignment) {
    console.error("âŒ No assignment");
    hideLoader();
    return;
  }

  console.log("ðŸ“‹ Assignment type:", assignment.type);

  try {
    // Mark as seen
    if (window.latestAssignmentId) {
      const updateData = {
        status: "seen",
        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
        acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
      };

      if (assignment.type === 'written') {
        updateData.score = 0;
        updateData.maxScore = assignment.writtenQuestions?.length || 10;
      }

      try {
        await db.collection('assignments').doc(window.latestAssignmentId).update(updateData);
        console.log("âœ… Assignment marked as seen");
      } catch (error) {
        console.error("âŒ Error marking as seen:", error);
      }
    }

    // Handle speaking/case
    if (assignment.type === 'speaking' || assignment.type === 'case') {
      console.log("ðŸŽ¤ Speaking/case assignment");
      document.getElementById('cq-assignment-modal').style.display = 'none';
      hideLoader();
      openCameraModal();
      return;
    }

    // Handle written
    if (assignment.type === 'written') {
      console.log("âœï¸ Written assignment");
      console.log("â³ CIRCULAR PROGRESS LOADER VISIBLE");

      const competencies = assignment.competencies;
      const questionCount = assignment.totalQuestions || 10;
      const difficulty = assignment.difficulty || 'medium';

      if (!competencies || competencies.length === 0) {
        console.warn("âš ï¸ No competencies");
        hideLoader();
        return;
      }

      // FETCH COMPETITION ID FROM FIREBASE
      console.log("ðŸ“Š Fetching competition ID from Firebase...");
      let competitionId = assignment.competitionId 
        || window.currentCompetition?.id 
        || window.competitionId 
        || window.currentUser?.competitions?.[0];

      if (!competitionId) {
        try {
          const userId = firebase.auth().currentUser?.uid;
          if (userId) {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists && userDoc.data().competitions?.[0]) {
              competitionId = userDoc.data().competitions[0];
              console.log("âœ… Fetched competition from Firebase:", competitionId);
            }
          }
        } catch (err) {
          console.warn("âš ï¸ Could not fetch competition from Firebase:", err);
        }
      }

      console.log("ðŸŽ¯ Competition ID:", competitionId);

      // FETCH BASELINE
      console.log("ðŸ“Š Fetching baseline...");
      let baselineText = "";

      if (competitionId) {
        try {
          const competitionDoc = await db.collection('competitions').doc(competitionId).get();
          if (competitionDoc.exists) {
            const baseline = competitionDoc.data().baseline || {};
            if (baseline.text) {
              baselineText = baseline.text;
              console.log("âœ… Baseline fetched:", baselineText.length, "characters");
            }
          }
        } catch (err) {
          console.warn("âš ï¸ Baseline fetch failed");
        }
      } else {
        console.log("âš ï¸ No competition ID, skipping baseline");
      }

      // FETCH GPT CONTEXT
      console.log("ðŸ¤– Fetching GPT context...");
      let gptContextData = {};

      try {
        const userId = firebase.auth().currentUser?.uid;
        if (userId) {
          const userTrainingDoc = await db.collection('userTraining').doc(userId).get();
          if (userTrainingDoc.exists && userTrainingDoc.data().gptTrainingContext) {
            gptContextData = userTrainingDoc.data().gptTrainingContext;
            console.log("âœ… GPT context fetched");
          }
        }
      } catch (err) {
        console.warn("âš ï¸ GPT context fetch failed");
      }

      // BUILD CONTEXT STRING - Let GPT filter intelligently
      console.log("ðŸ§  Building context with full baseline + training data...");
      let contextString = "";
      
      if (baselineText) {
        contextString += "=== COMPETITION BASELINE STUDY MATERIAL ===\n";
        contextString += "Use the following baseline material to generate questions focused on: " + competencies.join(", ") + "\n";
        contextString += "Filter and extract the most relevant information for the specified competencies.\n\n";
        contextString += baselineText + "\n\n";
      }
      
      if (gptContextData.content) {
        contextString += "=== USER BACKGROUND AND TRAINING CONTEXT ===\n";
        contextString += "Consider the user's background when generating questions:\n";
        contextString += gptContextData.content;
      }
      
      window.__CERTQUEST_CONTEXT__ = contextString;
      console.log("âœ… Context ready:", contextString.length, "chars");
      console.log("ðŸ“š Competencies to focus on:", competencies);

      // GENERATE QUESTIONS
      console.log("ðŸ§  Generating questions WITH FULL BASELINE + TRAINING DATA...");
      console.log("â³ LOADER PROGRESS BAR VISIBLE & ANIMATING");
      
      const questions = await generatePersonalizedQuestionsWithGPT({
        competencies,
        time: 15,
        difficulty,
        questionCount
      });

      console.log("âœ… Generated", questions.length, "questions");

      // UPDATE ASSIGNMENT
      const updatedAssignment = {
        ...assignment,
        generatedQuestions: questions,
        baselineText,
        gptContext: gptContextData
      };

      window.currentAssignment = updatedAssignment;
      window.writtenQuestions = questions;

      console.log("ðŸ“¦ Opening modal...");

      // OPEN MODAL
      document.getElementById('cq-assignment-modal').style.display = 'none';
      await openWrittenPracticeModal(updatedAssignment);
    }

  } catch (error) {
    console.error("âŒ Error:", error);
    hideLoader();
  }
}

/**
 * Gathers baseline data for competencies from the competitions collection
 */
async function gatherBaselineData(competitionId, competencies) {
  try {
    if (!competitionId) {
      console.warn("âš ï¸ No competition ID provided");
      return {};
    }

    const competitionDoc = await db
      .collection('competitions')
      .doc(competitionId)
      .get();

    if (!competitionDoc.exists) {
      console.warn("âš ï¸ Competition not found:", competitionId);
      return {};
    }

    const competitionData = competitionDoc.data();
    console.log("ðŸ“„ Full competition data structure:", competitionData);
    console.log("ðŸ“„ Baseline field:", competitionData.baseline);

    const baseline = {};

    // Extract baseline for each competency from competition.baseline
    competencies.forEach(competencyId => {
      const competencyBaseline = competitionData.baseline?.[competencyId];

      if (competencyBaseline) {
        baseline[competencyId] = competencyBaseline;
        console.log(`âœ… Found baseline for ${competencyId}:`, competencyBaseline);
      } else {
        console.log(`âš ï¸ No baseline found for competency: ${competencyId}`);
      }
    });

    console.log("ðŸ“Š Final baseline object:", baseline);
    return baseline;
  } catch (error) {
    console.error("âŒ Error gathering baseline data:", error);
    return {};
  }
}

  function showLoader() {
    const loader = document.getElementById("assignmentLoader");
    if (loader) {
      loader.style.display = "flex";
    }
  }

  function hideLoader() {
    const loader = document.getElementById("assignmentLoader");
    if (loader) {
      loader.style.display = "none";
    }
  }

  async function openWrittenPracticeModal(assignment) {
    console.log("Opening written practice modal with assignment:", assignment);

    try {
      currentQuestionIndex = 0;
      writtenAnswers = {};
      if (!window.writtenAnswers) {
        window.writtenAnswers = {};
      }

      const timeInMinutes = parseInt(assignment.time) || 15;
      writtenTimeRemaining = timeInMinutes * 60;

      // Check if window.writtenQuestions exists (from "create your own" flow)
      if (window.writtenQuestions && window.writtenQuestions.length > 0) {
        console.log("âœ… Using window.writtenQuestions from create your own flow");
        writtenQuestions = window.writtenQuestions;
      } else if (assignment.writtenQuestions && assignment.writtenQuestions.length > 0) {
        // Use assignment's preloaded questions
        writtenQuestions = assignment.writtenQuestions;
        window.writtenQuestions = assignment.writtenQuestions;
      } else {
        // Generate new questions via GPT
        console.log("âš¡ No preloaded questions, generating via GPT...");
        assignment.writtenQuestions = await generatePersonalizedQuestionsWithGPT({
          time: assignment.time || "15 mins",
          difficulty: assignment.difficulty || "Medium",
          competencies: assignment.competencies || ["General"],
          type: "written"
        });
        writtenQuestions = assignment.writtenQuestions;
        window.writtenQuestions = assignment.writtenQuestions;
      }

      console.log("âœ… Written questions ready:", writtenQuestions);

      // Show modal and create stars
      const modal = document.getElementById('quizModal');
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      createQuizStars();
      loadWrittenQuestion();
      startWrittenTimer();

    } catch (err) {
      console.error("âŒ Error in openWrittenPracticeModal:", err);
      alert("Could not load written practice. Please try again.");
    } finally {
      hideLoader();
      console.log("ðŸ›‘ Loader hidden inside openWrittenPracticeModal");
    }
  }

  function getQuestionCount(timeStr) {
    if (!timeStr) return 5;
    const normalized = timeStr.toString().toLowerCase();
    if (normalized.includes("15")) return 10;
    if (normalized.includes("10")) return 7;
    if (normalized.includes("5")) return 5;
    return 5;
  }

  async function generatePersonalizedQuestionsWithGPT(formData) {
    const questionCount = getQuestionCount(formData.time);
    const competenciesText = formData.competencies.join(', ');

    let prompt = `Generate ${questionCount} FBLA-style multiple choice questions.
- Difficulty: ${formData.difficulty}
- Competencies to cover: ${competenciesText}
- Each question must have exactly 4 options and 1 correct answer
- Questions must be standalone, realistic for FBLA, and never reference "the document", "the text", "as stated", etc.
- Use business, finance, marketing, management, economics, law, and related topics depending on the competencies.`

    prompt += `\n\nReturn ONLY valid JSON array in format:
[
  {
    "text": "Question text?",
    "competency": "Marketing",
    "correctAnswer": "Correct option text",
    "options": ["A", "B", "C", "D"],
    "difficulty": "${formData.difficulty}",
    "source": "gpt_generated"
  }
]`;

    try {
      const response = await firebase.functions().httpsCallable("generateQuestionsWithAI")({
        messages: [
          { role: "system", content: `You are an expert FBLA written-competition exam designer.

Your role is to generate ORIGINAL, competition-accurate FBLA-style multiple-choice questions that match the structure, rigor, tone, and professional standards of official FBLA written tests.

You must follow ALL rules below.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORE FBLA PHILOSOPHY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FBLA written tests assess professional correctness, precision, and applied business literacy.

They do NOT assess creativity, opinion, or open-ended reasoning.

Each question must test exactly ONE concept.

Questions must be concise, objective, and professionally worded.

Avoid unnecessary narrative unless the question type explicitly requires a scenario.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
APPROVED FBLA QUESTION ARCHETYPES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Every question MUST clearly belong to ONE of the following archetypes:

1. Definition / Term Identification  
   - Identifying the correct term based on a definition  
   - Selecting the correct meaning of a professional word or concept  

2. Classification / Category Recognition  
   - Determining where an item belongs within a professional category system  
   - Examples include document types, account categories, system types, business forms, or classifications  

3. Procedural / Workflow Knowledge  
   - Understanding the stages of a professional workflow specific to the competition area  
   - Identifying where information originates within that workflow  
   - Determining which document, tool, or action is appropriate at a given stage  
   - Recognizing correct sequencing of professional tasks within the domain  

4. Tool-to-Function Matching  
   - Matching software features, commands, utilities, or tools to their correct purpose  
   - Selecting the correct function used to accomplish a professional task  

5. Quantitative / Calculation Application  
   - Performing single-step or limited multi-step calculations  
   - Selecting the correct numeric result based on provided data  
   - Avoid unnecessary complexity or advanced math  

6. Language Precision & Usage  
   - Correct use of professional vocabulary  
   - Distinguishing homophones, word meanings, spelling, grammar, and standard usage  

7. Error Detection / Exception Identification  
   - Identifying what is incorrect, misspelled, or does NOT belong  
   - Using negation ("NOT") carefully and intentionally  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUESTION STRUCTURE RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Each question must assess ONE idea only.  
â€¢ Do not combine multiple concepts in one question.  
â€¢ Avoid ambiguous wording.  
â€¢ Use professional, neutral language.

Acceptable stem styles include:
- "Which of the followingâ€¦"
- "What term best describesâ€¦"
- "The document used toâ€¦"
- "Which action should be takenâ€¦"
- "Which of the following is NOTâ€¦"

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ANSWER CHOICE DESIGN (CRITICAL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Each question MUST include exactly FOUR answer choices.

Answer choices must:
â€¢ Be the same grammatical form  
â€¢ Be similar in length  
â€¢ Belong to the same conceptual family  

Wrong answer choices (distractors) must be plausible and realistic.

Allowed distractor strategies include:
â€¢ Closely related terms within the same category  
â€¢ Common student misconceptions  
â€¢ Incorrect step within a workflow  
â€¢ Reversed or misapplied professional rules  
â€¢ Visually or linguistically similar words  
â€¢ Typical calculation or classification errors  

Never include joke answers or obviously incorrect options.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DIFFICULTY CALIBRATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Easy:
â€¢ Direct recall or recognition  
â€¢ Minimal traps  

Medium:
â€¢ Requires discrimination between similar concepts  
â€¢ Includes common misconceptions  

Hard:
â€¢ Includes negation ("NOT")  
â€¢ Requires precise rule awareness  
â€¢ Uses subtle wording differences  
â€¢ Penalizes shallow memorization  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CONTENT INTEGRITY RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All questions must be ORIGINAL.  
â€¢ Do NOT copy real FBLA questions.  
â€¢ Do NOT closely paraphrase known questions.  
â€¢ Use authentic structure only, not replicated wording.

Questions must feel realistic for competitive FBLA written events at the regional, state, or national level.

When study materials are provided, extract concepts, facts, names, dates, laws, and details from them. Present this information as established business knowledge. NEVER mention "the study guide", "the document", "the material", or use phrases like "according to", "as stated in", or "mentioned in".

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OUTPUT REQUIREMENTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Generate ONLY the requested number of questions.  
â€¢ Each question must have exactly four answer options.  
â€¢ Only ONE option may be correct.  
â€¢ Output valid JSON only.  
â€¢ Do not include explanations, commentary, or headings.  

You are writing as a professional exam author â€” not as a tutor or teacher.` },
          { role: "user", content: (window.__CERTQUEST_CONTEXT__ || "") + "\n\n" + prompt }
        ]
      });

      const data = response.data;
      let content = data.content || data.choices?.[0]?.message?.content || data;
      
      if (typeof content !== 'string') {
        content = JSON.stringify(content);
      }
      
      content = content.trim();
      content = content.replace(/```json|```/g, "");
      const jsonStart = content.indexOf('[');
      const jsonEnd = content.lastIndexOf(']') + 1;
      
      if (jsonStart !== -1 && jsonEnd > jsonStart) {
        content = content.slice(jsonStart, jsonEnd);
      }
      
      const generated = JSON.parse(content);
      console.log(`âœ… Generated ${generated.length} GPT questions`);
      return generated;

    } catch (err) {
      console.error("âŒ GPT error:", err);
      return getFallbackQuestions(questionCount, formData.competencies);
    }
  }

  function getFallbackQuestions(count, competencies) {
    const fallbackQuestions = [
      {
        text: "What is the primary purpose of parliamentary procedure?",
        competency: "Parliamentary Procedure",
        correctAnswer: "To make meetings more efficient",
        options: [
          "To make meetings more efficient",
          "To give the president more power",
          "To eliminate debate",
          "To make meetings longer"
        ]
      },
      {
        text: "Which motion is used to end a meeting?",
        competency: "Parliamentary Procedure",
        correctAnswer: "Adjourn",
        options: ["Adjourn", "Recess", "Postpone", "Table"]
      },
      {
        text: "What is the most effective way to communicate in business?",
        competency: "Business Communication",
        correctAnswer: "Clear and concise messaging",
        options: [
          "Clear and concise messaging",
          "Using complex terminology",
          "Lengthy detailed explanations",
          "Informal casual language"
        ]
      }
    ];
    
    const result = [];
    for (let i = 0; i < count; i++) {
      result.push(fallbackQuestions[i % fallbackQuestions.length]);
    }
    return result;
  }

  function loadWrittenQuestion() {
    // Use window.writtenQuestions if available (for "create your own"), otherwise use local writtenQuestions
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    const question = questions[currentQuestionIndex];
    if (!question) {
      console.error("No question found at index", currentQuestionIndex);
      return;
    }
    
    console.log("Loading question", currentQuestionIndex + 1, ":", question.question || question.text);
    
    const assignmentTitle = window.currentAssignment?.title || 'Written Practice';
    const difficulty = window.currentAssignment?.difficulty || 'Easy';
    document.getElementById('quizTitle').textContent = `${difficulty} ${assignmentTitle}`;
    document.getElementById('quizProgress').textContent = 
      `Question ${currentQuestionIndex + 1} of ${questions.length}`;
    
    document.getElementById('questionCompetency').textContent = question.competency || 'General';
    const questionTextEl = document.getElementById('questionText');
    questionTextEl.textContent = question.question || question.text;
    questionTextEl.style.color = '#fff';
    
    const optionsContainer = document.getElementById('optionsContainer');
    const answers = window.writtenAnswers || writtenAnswers;
    const previousAnswer = answers[currentQuestionIndex];
    
    optionsContainer.innerHTML = question.options.map((option, index) => {
      const isSelected = previousAnswer === option;
      return `
        <button class="practice-quiz-option-btn ${isSelected ? 'selected' : ''}" data-option="${option}">
          <div class="practice-quiz-option-radio ${isSelected ? 'selected' : ''}">
            ${isSelected ? '<div class="practice-quiz-option-dot"></div>' : ''}
          </div>
          <span class="practice-quiz-option-text">${option}</span>
        </button>
      `;
    }).join('');
    
    const options = optionsContainer.querySelectorAll('.practice-quiz-option-btn');
    options.forEach(optionBtn => {
      optionBtn.addEventListener('click', function(e) {
        options.forEach(opt => {
          opt.classList.remove("selected");
          const radio = opt.querySelector('.practice-quiz-option-radio');
          radio.classList.remove("selected");
          radio.innerHTML = '';
        });
        
        this.classList.add('selected');
        const radio = this.querySelector('.practice-quiz-option-radio');
        radio.classList.add('selected');
        radio.innerHTML = '<div class="practice-quiz-option-dot"></div>';
        
        // Save to both window.writtenAnswers and local writtenAnswers
        if (window.writtenAnswers) {
          window.writtenAnswers[currentQuestionIndex] = this.dataset.option;
        } else {
          writtenAnswers[currentQuestionIndex] = this.dataset.option;
        }
        console.log("Answer saved:", currentQuestionIndex, "->", this.dataset.option);
      });
    });
    
    updateWrittenProgress();
    updateWrittenNavButtons();
  }

  function updateWrittenProgress() {
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
    document.getElementById('progressFill').style.width = `${progress}%`;
    document.getElementById('progressPercent').textContent = Math.round(progress);
  }

  function updateWrittenNavButtons() {
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const submitBtn = document.getElementById('submitBtn');
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    
    prevBtn.disabled = currentQuestionIndex === 0;
    
    if (currentQuestionIndex === questions.length - 1) {
      nextBtn.style.display = 'none';
      submitBtn.style.display = 'block';
    } else {
      nextBtn.style.display = 'block';
      submitBtn.style.display = 'none';
    }
  }

  function previousQuestion() {
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    if (currentQuestionIndex > 0) {
      currentQuestionIndex--;
      loadWrittenQuestion();
    }
  }

  function nextQuestion() {
    const questions = window.writtenQuestions && window.writtenQuestions.length > 0 ? window.writtenQuestions : writtenQuestions;
    if (currentQuestionIndex < questions.length - 1) {
      currentQuestionIndex++;
      loadWrittenQuestion();
    }
  }

  function startWrittenTimer() {
    clearInterval(writtenTimer);
    
    console.log("Starting timer with", writtenTimeRemaining, "seconds");
    updateTimerDisplay();
    
    writtenTimer = setInterval(() => {
      writtenTimeRemaining--;
      updateTimerDisplay();
      
      if (writtenTimeRemaining <= 0) {
        console.log("Time's up! Auto-submitting...");
        clearInterval(writtenTimer);
        submitWrittenPractice();
      }
    }, 1000);
  }

  function updateTimerDisplay() {
    const minutes = Math.floor(writtenTimeRemaining / 60);
    const seconds = writtenTimeRemaining % 60;
    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    const timerElement = document.getElementById('quizTimer');
    if (timerElement) {
      timerElement.textContent = timeString;
      
      if (writtenTimeRemaining <= 60) {
        timerElement.style.color = '#ef4444';
      } else if (writtenTimeRemaining <= 300) {
        timerElement.style.color = '#f97316';
      } else {
        timerElement.style.color = '#fb923c';
      }
    }
  }

  function createQuizStars() {
    const starsContainer = document.getElementById('quizStarsContainer');
    if (!starsContainer) return;
    
    starsContainer.innerHTML = '';
    
    for (let i = 0; i < 200; i++) {
      const star = document.createElement('div');
      star.className = 'practice-quiz-star';
      
      const size = Math.random() * 3 + 0.5;
      const duration = Math.random() * 4 + 2;
      const delay = Math.random() * 2;
      const randomLeft = Math.random() * 100;
      const randomTop = Math.random() * 100;
      const randomOpacity = Math.random() * 0.9 + 0.3;
      
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = randomLeft + '%';
      star.style.top = randomTop + '%';
      star.style.opacity = randomOpacity;
      star.style.animation = `practice-quiz-twinkle ${duration}s ease-in-out infinite`;
      star.style.animationDelay = delay + 's';
      star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
      
      starsContainer.appendChild(star);
    }
  }

  function closeQuizModal() {
    const modal = document.getElementById('quizModal');
    if (modal) {
      modal.style.display = 'none';
    }
    document.body.style.overflow = 'auto';
    clearInterval(writtenTimer);
    writtenQuestions = [];
    currentQuestionIndex = 0;
    writtenAnswers = {};
    writtenTimeRemaining = 0;
    writtenTimer = null;
  }

  async function submitWrittenPracticeForCreateYourOwn() {
    try {
      console.log("=== SUBMITTING CREATE YOUR OWN WRITTEN PRACTICE ===");
      clearInterval(writtenTimer);
      
      // Use window.writtenQuestions and window.writtenAnswers for "create your own" tests
      const questions = window.writtenQuestions || writtenQuestions;
      const answers = window.writtenAnswers || writtenAnswers;
      
      if (!questions || questions.length === 0) {
        console.error("âŒ CRITICAL ERROR: No questions found!");
        alert("Error: No questions found. Cannot submit written practice.");
        closeQuizModal();
        return;
      }
      
      let score = 0;
      const competencyStats = {};
      const detailedAnswers = [];
      const totalQuestions = questions.length;
      
      questions.forEach((question, index) => {
        const userAnswer = answers[index];
        const correctAnswer = question.correctAnswer;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) score++;
        
        const competency = question.competency;
        if (!competencyStats[competency]) {
          competencyStats[competency] = { total: 0, correct: 0 };
        }
        competencyStats[competency].total++;
        if (isCorrect) competencyStats[competency].correct++;
        
        detailedAnswers.push({
          questionIndex: index,
          question: question.question || question.text,
          competency: competency,
          userAnswer: userAnswer || "No answer",
          correctAnswer: correctAnswer,
          isCorrect: isCorrect
        });
      });
      
      // Get time from form data or default
      const timeStr = document.getElementById('quizTitle')?.textContent?.match(/\d+/)?.[0] || '15';
      const originalTime = parseInt(timeStr) * 60 || 900;
      const timeSpent = originalTime - writtenTimeRemaining;
      const percentage = Math.round((score / totalQuestions) * 100);
      
      // Get difficulty from quiz title or default
      const difficulty = document.getElementById('quizTitle')?.textContent?.match(/(Easy|Medium|Hard)/i)?.[0] || 'medium';
      
      const quizResults = {
        correct: score,
        total: totalQuestions,
        percentage: percentage,
        timeUsed: timeSpent,
        questionResults: detailedAnswers.map((ans, idx) => {
          const originalQuestion = questions[ans.questionIndex];
          return {
            question: ans.question,
            userAnswer: ans.userAnswer,
            correctAnswer: ans.correctAnswer,
            isCorrect: ans.isCorrect,
            competency: ans.competency,
            options: originalQuestion ? (originalQuestion.options || []) : []
          };
        }),
        competencyStats: competencyStats,
        quizSettings: {
          difficulty: difficulty.toLowerCase(),
          time: timeStr,
          competencies: Object.keys(competencyStats)
        }
      };
      
      console.log("=== SAVING NEW TEST RESULT DOCUMENT (CREATE YOUR OWN) ===");
      await saveQuizResultsToFirebase(quizResults);
      console.log("âœ… New test result document created");
      
      // Reload performance cards
      await reloadQuizCardsFromFirebase();
      
      const resultsData = {
        message: `Excellent work! You scored ${score}/${totalQuestions}`,
        assignmentName: 'Written Practice',
        competencyStats: competencyStats,
        score: score,
        totalQuestions: totalQuestions,
        percentage: percentage,
        timeSpent: timeSpent
      };
      
      closeQuizModal();
      
      confetti({
        particleCount: 150,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#3b82f6', '#1d4ed8', '#1e40af']
      });
      
      showCongratsModal(resultsData);
      
      // Clear window variables
      window.writtenQuestions = null;
      window.writtenAnswers = null;
      
    } catch (error) {
      console.error("âŒ Create your own written practice submission error:", error);
      alert("Failed to submit practice: " + error.message);
    }
  }

  async function submitWrittenPractice() {
    try {
      console.log("=== SUBMITTING WRITTEN PRACTICE ===");
      clearInterval(writtenTimer);
      
      if (!window.latestAssignmentId) {
        console.error("âŒ CRITICAL ERROR: No assignment ID found!");
        alert("Error: No assignment ID found. Cannot submit written practice.");
        closeQuizModal();
        return;
      }
      
      // Use local writtenQuestions for assignment-based tests
      const questions = writtenQuestions;
      const answers = writtenAnswers;
      
      let score = 0;
      const competencyStats = {};
      const detailedAnswers = [];
      const totalQuestions = questions.length;
      
      questions.forEach((question, index) => {
        const userAnswer = answers[index];
        const correctAnswer = question.correctAnswer;
        const isCorrect = userAnswer === correctAnswer;
        
        if (isCorrect) score++;
        
        const competency = question.competency;
        if (!competencyStats[competency]) {
          competencyStats[competency] = { total: 0, correct: 0 };
        }
        competencyStats[competency].total++;
        if (isCorrect) competencyStats[competency].correct++;
        
        detailedAnswers.push({
          questionIndex: index,
          question: question.question || question.text,
          competency: competency,
          userAnswer: userAnswer || "No answer",
          correctAnswer: correctAnswer,
          isCorrect: isCorrect
        });
      });
      
      const originalTime = parseInt(window.currentAssignment?.time) * 60 || 900;
      const timeSpent = originalTime - writtenTimeRemaining;
      const percentage = Math.round((score / totalQuestions) * 100);
      
      const quizResults = {
        correct: score,
        total: totalQuestions,
        percentage: percentage,
        timeUsed: timeSpent,
        questionResults: detailedAnswers.map((ans, idx) => {
          const originalQuestion = questions[ans.questionIndex];
          return {
            question: ans.question,
            userAnswer: ans.userAnswer,
            correctAnswer: ans.correctAnswer,
            isCorrect: ans.isCorrect,
            competency: ans.competency,
            options: originalQuestion ? (originalQuestion.options || []) : []
          };
        }),
        competencyStats: competencyStats,
        quizSettings: {
          difficulty: window.currentAssignment?.difficulty || 'medium',
          time: window.currentAssignment?.time || '15',
          competencies: Object.keys(competencyStats)
        }
      };
      
      console.log("=== SAVING NEW TEST RESULT DOCUMENT ===");
      await saveQuizResultsToFirebase(quizResults);
      console.log("âœ… New test result document created");
      
      // Update original assignment document (for mentor tracking) - but DON'T set status to 'complete'
      // The new test result document already has status 'complete' for performance breakdown
      const updateData = {
        // Keep status as 'seen' or 'in_progress' - don't set to 'complete' to avoid duplicates
        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
        score: score,
        totalQuestions: totalQuestions,
        maxScore: totalQuestions,
        competencyStats: competencyStats,
        timeSpent: timeSpent,
        detailedAnswers: detailedAnswers,
        competencies: Object.keys(competencyStats),
        correctCompetencies: Object.entries(competencyStats)
          .filter(([_, stats]) => stats.correct === stats.total)
          .map(([comp, _]) => comp),
        percentage: percentage,
        submittedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      
      await db.collection('assignments').doc(window.latestAssignmentId).update(updateData);
      console.log("âœ… Assignment updated successfully (status NOT set to 'complete' to avoid duplicates)");
      
      const resultsData = {
        message: `Excellent work! You scored ${score}/${totalQuestions}`,
        assignmentName: window.currentAssignment?.title || 'Written Practice',
        competencyStats: competencyStats,
        score: score,
        totalQuestions: totalQuestions,
        percentage: percentage,
        timeSpent: timeSpent
      };
      
      closeQuizModal();
      
      confetti({
        particleCount: 150,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#3b82f6', '#1d4ed8', '#1e40af']
      });
      
      showCongratsModal(resultsData);
      
      window.latestAssignmentId = null;
      window.currentAssignment = null;
      
    } catch (error) {
      console.error("âŒ Written practice submission error:", error);
      alert("Failed to submit practice: " + error.message);
    }
  }

  function showCongratsModal(results) {
    const modal = document.getElementById('congratsModal');
    
    const percentage = results.percentage || Math.round((results.score / results.totalQuestions) * 100);
    
    document.getElementById('congratsTitle').textContent = 'Congratulations!';
    document.getElementById('congratsScore').textContent = `${results.score}/${results.totalQuestions}`;
    document.getElementById('congratsSubtitle').innerHTML = 
      `Excellent work! You scored <span id="congratsScoreSpan" style="background: linear-gradient(to right, #ef4444, #f97316, #eab308); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900; font-size: 1.75rem;">${results.score}/${results.totalQuestions}</span>`;
    
    document.getElementById('congratsAssignmentName').textContent = results.assignmentName || 'Written Practice';
    
    const competenciesContainer = document.getElementById('congratsCompetencies');
    if (results.competencyStats && Object.keys(results.competencyStats).length > 0) {
      competenciesContainer.innerHTML = Object.entries(results.competencyStats).map(([comp, stats]) => {
        const percentage = Math.round((stats.correct / stats.total) * 100);
        const isFull = stats.correct === stats.total;
        return `
          <div class="congrats-competency-item">
            <div class="congrats-competency-header">
              <span class="congrats-competency-name">${comp}</span>
              <span class="congrats-competency-score">${stats.correct}/${stats.total} correct</span>
            </div>
            <div class="congrats-competency-progress-bar">
              <div class="congrats-competency-progress-fill ${isFull ? 'full' : ''}" style="width: ${percentage}%"></div>
            </div>
          </div>
        `;
      }).join('');
    } else {
      competenciesContainer.innerHTML = '<p style="color: #94a3b8; text-align: center;">No competency breakdown available</p>';
    }
    
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    createCongratsStars();
    
    confetti({
      particleCount: 200,
      spread: 80,
      origin: { y: 0.6 },
      colors: ['#ef4444', '#f97316', '#eab308', '#dc2626']
    });
  }

  function createCongratsStars() {
    const starsContainer = document.getElementById('congratsStarsContainer');
    if (!starsContainer) return;
    
    starsContainer.innerHTML = '';
    
    for (let i = 0; i < 200; i++) {
      const star = document.createElement('div');
      star.className = 'practice-quiz-star';
      
      const size = Math.random() * 3 + 0.5;
      const duration = Math.random() * 4 + 2;
      const delay = Math.random() * 2;
      const randomLeft = Math.random() * 100;
      const randomTop = Math.random() * 100;
      const randomOpacity = Math.random() * 0.9 + 0.3;
      
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = randomLeft + '%';
      star.style.top = randomTop + '%';
      star.style.opacity = randomOpacity;
      star.style.animation = `practice-quiz-twinkle ${duration}s ease-in-out infinite`;
      star.style.animationDelay = delay + 's';
      star.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.8)`;
      
      starsContainer.appendChild(star);
    }
  }

  function closeCongratsModal() {
    const modal = document.getElementById('congratsModal');
    if (modal) {
      modal.style.display = 'none';
    }
    document.body.style.overflow = 'auto';
  }

  function snoozeAssignment() {
    closeAssignmentModal();
  }
</script>

  <!-- Assignment Modal -->
  <div id="cq-assignment-modal" class="cq-modal" style="display: none;">
    <div class="cq-modal-content">
      <span class="cq-close" onclick="closeAssignmentModal()">&times;</span>
      <div id="cq-assignment-title" class="cq-modal-title">New Assignment</div>
      
      <!-- Assignment Info (shown first) -->
      <div id="cq-assignment-info">
        <div id="cq-assignment-fields" class="cq-modal-fields"></div>
        <div class="cq-modal-footer" style="margin-top:1.5rem; text-align:right;">
          <button class="cq-modal-btn" onclick="acceptAssignmentNow()">I'll do it now</button>
          <button class="cq-modal-btn" onclick="snoozeAssignment()">I'll do it later</button>
        </div>
      </div>
      
      <!-- Quiz Section (hidden initially) -->
      <div id="cq-assignment-quiz" style="display:none;">
        <div id="quizQuestions" class="cq-modal-fields"></div>
        <div class="cq-modal-footer">
          <button class="cq-modal-btn" id="submitQuizBtn" disabled>Submit Answers</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Congratulations Modal - Fullscreen -->
  <div id="congratsModal" class="practice-quiz-fullscreen" style="display:none;">
    <!-- Galaxy Background -->
    <div class="practice-quiz-galaxy-bg">
      <div class="practice-quiz-galaxy-gradient"></div>
      <div class="practice-quiz-stars-container" id="congratsStarsContainer"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-1"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-2"></div>
      <div class="practice-quiz-nebula practice-quiz-nebula-3"></div>
    </div>

    <!-- Main Content - Centered -->
    <div class="practice-quiz-main" style="display: flex; align-items: center; justify-content: center; min-height: calc(100vh - 80px);">
      <div class="congrats-content">
        <!-- Congratulations Header - Centered -->
        <div class="congrats-header">
          <h1 id="congratsTitle" class="congrats-title">Congratulations!</h1>
          <p class="congrats-subtitle" id="congratsSubtitle">
            Excellent work! You scored <span id="congratsScore">0/0</span>
          </p>
        </div>

        <!-- Assignment Info - Centered -->
        <div class="congrats-assignment-info">
          <p class="congrats-assignment-label">For completing:</p>
          <h2 id="congratsAssignmentName" class="congrats-assignment-name">Written Practice</h2>
        </div>

        <!-- Competency Breakdown - Grid Layout -->
        <div class="congrats-competencies-grid" id="congratsCompetencies">
          <!-- Competencies will be populated here -->
        </div>

        <!-- Action Button -->
        <div class="congrats-actions">
          <button class="practice-quiz-next-btn" onclick="closeCongratsModal()">Got it!</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Assignment Loader - Fullscreen Blurred -->
  <div id="assignmentLoader" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); z-index: 10000; justify-content: center; align-items: center; flex-direction: column;">
    <div class="circular-progress-loader">
      <svg class="circular-progress-svg" viewBox="0 0 100 100">
        <defs>
          <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#f97316;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#eab308;stop-opacity:1" />
          </linearGradient>
        </defs>
        <circle class="circular-progress-bg" cx="50" cy="50" r="45"></circle>
        <circle class="circular-progress-fill" cx="50" cy="50" r="45" id="circularProgressFill"></circle>
      </svg>
      <div class="circular-progress-text" id="circularProgressText">0%</div>
    </div>
  </div>
  
  <style>
    .circular-progress-loader {
      position: relative;
      width: 120px;
      height: 120px;
    }

    .circular-progress-svg {
      width: 100%;
      height: 100%;
      transform: rotate(-90deg);
    }

    .circular-progress-bg {
      fill: none;
      stroke: rgba(255, 255, 255, 0.2);
      stroke-width: 8;
    }

    .circular-progress-fill {
      fill: none;
      stroke: url(#progressGradient);
      stroke-width: 8;
      stroke-linecap: round;
      stroke-dasharray: 283;
      stroke-dashoffset: 283;
      transition: stroke-dashoffset 0.3s ease;
    }

    .circular-progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 1.5rem;
      font-weight: 700;
      font-family: 'Inter', sans-serif;
    }

    .congrats-content {
      max-width: 80rem;
      margin: 0 auto;
      width: 100%;
      text-align: center;
    }

    .congrats-header {
      margin-bottom: 3rem;
    }

    .congrats-title {
      font-size: 3.5rem;
      font-weight: 900;
      background: linear-gradient(to right, #ef4444, #f97316, #eab308);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0 0 1rem 0;
      line-height: 1.2;
    }

    .congrats-subtitle {
      font-size: 1.5rem;
      color: #fff;
      margin: 0;
      font-weight: 500;
    }

    .congrats-subtitle span {
      background: linear-gradient(to right, #ef4444, #f97316, #eab308);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 900;
    }

    .congrats-assignment-info {
      text-align: center;
      margin-bottom: 4rem;
    }

    .congrats-assignment-label {
      color: #94a3b8;
      font-size: 0.875rem;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 700;
    }

    .congrats-assignment-name {
      font-size: 2.5rem;
      font-weight: 900;
      background: linear-gradient(to right, #ef4444, #f97316, #eab308);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }

    .congrats-competencies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 4rem;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }

    .congrats-competency-item {
      background: rgba(30, 41, 59, 0.3);
      border: 2px solid rgba(71, 85, 105, 0.5);
      border-radius: 1rem;
      padding: 1.5rem;
      transition: all 0.2s;
      text-align: left;
    }

    .congrats-competency-item:hover {
      border-color: rgba(251, 146, 60, 0.5);
      background: rgba(251, 146, 60, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(251, 146, 60, 0.2);
    }

    .congrats-competency-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .congrats-competency-name {
      font-size: 1rem;
      font-weight: 900;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .congrats-competency-score {
      font-size: 1rem;
      font-weight: 700;
      color: #94a3b8;
    }

    .congrats-competency-progress-bar {
      width: 100%;
      height: 0.75rem;
      background: rgba(30, 41, 59, 0.5);
      border-radius: 9999px;
      overflow: hidden;
      border: 1px solid rgba(71, 85, 105, 0.5);
    }

    .congrats-competency-progress-fill {
      height: 100%;
      background: linear-gradient(to right, #dc2626, #f97316);
      border-radius: 9999px;
      transition: width 0.5s;
    }

    .congrats-competency-progress-fill.full {
      background: linear-gradient(to right, #16a34a, #22c55e);
    }

    .congrats-actions {
      display: flex;
      justify-content: center;
      margin-top: 3rem;
    }
  </style>

  <script>
    // Circular progress loader
    (function() {
      let progressInterval = null;
      let currentProgress = 0;

      function updateCircularProgress(progress) {
        const fill = document.getElementById('circularProgressFill');
        const text = document.getElementById('circularProgressText');
        
        if (fill && text) {
          const circumference = 2 * Math.PI * 45;
          const offset = circumference - (progress / 100) * circumference;
          fill.style.strokeDashoffset = offset;
          text.textContent = Math.round(progress) + '%';
        }
      }

      function startCircularProgress() {
        currentProgress = 0;
        updateCircularProgress(0);
        
        progressInterval = setInterval(() => {
          currentProgress += 2;
          if (currentProgress > 95) {
            currentProgress = 95;
          }
          updateCircularProgress(currentProgress);
        }, 100);
      }

      function completeCircularProgress() {
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }
        updateCircularProgress(100);
      }

      function stopCircularProgress() {
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }
        currentProgress = 0;
      }

      const originalShowLoader = window.showLoader;
      const originalHideLoader = window.hideLoader;

      window.showLoader = function() {
        if (originalShowLoader) originalShowLoader();
        const loader = document.getElementById("assignmentLoader");
        if (loader) {
          loader.style.display = "flex";
          startCircularProgress();
        }
      };

      window.hideLoader = function() {
        completeCircularProgress();
        setTimeout(() => {
          stopCircularProgress();
          if (originalHideLoader) originalHideLoader();
        }, 300);
      };
    })();
  </script>

  <!-- Confetti Library -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
</body>
</html> 